#!/usr/bin/perl
# 99aeabc9ec7fe80b1b39f5e53dc7e49e      <- self-modifying Perl magic

# This is a self-modifying Perl file. I'm sorry you're viewing the source (it's
# really gnarly). If you're curious what it's made of, I recommend reading
# http://github.com/spencertipping/writing-self-modifying-perl.
#
# If you got one of these from someone and don't know what to do with it, send
# it to spencer@spencertipping.com and I'll see if I can figure out what it
# does.

# For the benefit of HTML viewers (this is hack):
# <div id='cover' style='position: absolute; left: 0; top: 0; width: 10000px; height: 10000px; background: white'></div>

$|++;

my %data;
my %transient;
my %externalized_functions;
my %datatypes;

my %locations;          # Maps eval-numbers to attribute names

my $global_data = join '', <DATA>;

sub meta::define_form {
  my ($namespace, $delegate) = @_;
  $datatypes{$namespace} = $delegate;
  *{"meta::${namespace}::implementation"} = $delegate;
  *{"meta::$namespace"} = sub {
    my ($name, $value, %options) = @_;
    chomp $value;
    $data{"${namespace}::$name"} = $value unless $options{no_binding};
    &$delegate($name, $value) unless $options{no_delegate}}}

sub meta::eval_in {
  my ($what, $where) = @_;

  # Obtain next eval-number and alias it to the designated location
  @locations{eval('__FILE__') =~ /\(eval (\d+)\)/} = ($where);

  my $result = eval $what;
  $@ =~ s/\(eval \d+\)/$where/ if $@;
  warn $@ if $@;
  $result}

meta::define_form 'meta', sub {
  my ($name, $value) = @_;
  meta::eval_in($value, "meta::$name")};

meta::meta('configure', <<'__');
# A function to configure transients. Transients can be used to store any number of
# different things, but one of the more common usages is type descriptors.

sub meta::configure {
  my ($datatype, %options) = @_;
  $transient{$_}{$datatype} = $options{$_} for keys %options;
}
__
meta::meta('externalize', <<'__');
# Function externalization. Data types should call this method when defining a function
# that has an external interface.

sub meta::externalize {
  my ($name, $attribute, $implementation) = @_;
  my $escaped = $name;
  $escaped =~ s/[^A-Za-z0-9:]/_/go;
  $externalized_functions{$name} = $externalized_functions{$escaped} = $attribute;
  *{"::$name"} = *{"::$escaped"} = $implementation || $attribute;
}

__
meta::meta('functor::editable', <<'__');
# An editable type. This creates a type whose default action is to open an editor
# on whichever value is mentioned. This can be changed using different flags.

sub meta::functor::editable {
  my ($typename, %options) = @_;

  meta::configure $typename, %options;
  meta::define_form $typename, sub {
    my ($name, $value) = @_;

    $options{on_bind} && &{$options{on_bind}}($name, $value);

    meta::externalize $options{prefix} . $name, "${typename}::$name", sub {
      my $attribute             = "${typename}::$name";
      my ($command, @new_value) = @_;

      return &{$options{default}}(retrieve($attribute)) if ref $options{default} eq 'CODE' and not defined $command;
      return edit($attribute) if $command eq 'edit' or $options{default} eq 'edit' and not defined $command;
      return associate($attribute, @new_value ? join(' ', @new_value) : join('', <STDIN>)) if $command eq '=' or $command eq 'import' or $options{default} eq 'import' and not defined $command;
      return retrieve($attribute)}}}
__
meta::meta('functor::html-templates', <<'__');
my @html_elements = qw/html head title meta script style link body div/;    # Very incomplete list

for my $e (@html_elements) {
  meta::externalize "template::$e", "template::$e", sub {
    my ($line, $block) = @_;
    "<$e $line>\n$block\n</$e>";
  };
}

__
meta::meta('type::alias', <<'__');
meta::configure 'alias', inherit => 0;
meta::define_form 'alias', sub {
  my ($name, $value) = @_;
  meta::externalize $name, "alias::$name", sub {
    # Can't pre-tokenize because shell::tokenize doesn't exist until the library::
    # namespace has been evaluated (which will be after alias::).
    shell::run(shell::tokenize($value), shell::tokenize(@_));
  };
};
__
meta::meta('type::bootstrap', <<'__');
# Bootstrap attributes don't get executed. The reason for this is that because
# they are serialized directly into the header of the file (and later duplicated
# as regular data attributes), they will have already been executed when the
# file is loaded.

meta::configure 'bootstrap', extension => '.pl', inherit => 1;
meta::define_form 'bootstrap', sub {};
__
meta::meta('type::bzip2', <<'__');
meta::configure 'bzip2', inherit => 1;
meta::define_form 'bzip2', sub {
  my ($name, $value) = @_;

  meta::externalize $name, "bzip2::$name", sub {
    my ($command, @arguments) = @_;
    return terminal::error("temporary uncompressed attribute $name already exists") if exists $data{$name};

    uncompress($name);
    my $result = dangerous('', sub {&$command($name, @arguments)});
    compress($name);

    $result;
  };
};

__
meta::meta('type::cache', <<'__');
meta::configure 'cache', inherit => 0;
meta::define_form 'cache', \&meta::bootstrap::implementation;
__
meta::meta('type::data', 'meta::functor::editable \'data\', extension => \'\', inherit => 0, default => \'cat\';');
meta::meta('type::function', <<'__');
meta::configure 'function', extension => '.pl', inherit => 1;
meta::define_form 'function', sub {
  my ($name, $value) = @_;
  meta::externalize $name, "function::$name", meta::eval_in("sub {\n$value\n}", "function::$name");
};
__
meta::meta('type::hook', <<'__');
meta::configure 'hook', extension => '.pl', inherit => 0;
meta::define_form 'hook', sub {
  my ($name, $value) = @_;
  *{"hook::$name"} = meta::eval_in("sub {\n$value\n}", "hook::$name");
};
__
meta::meta('type::inc', <<'__');
meta::configure 'inc', inherit => 1, extension => '.pl';
meta::define_form 'inc', sub {
  use File::Path 'mkpath';
  use File::Basename qw/basename dirname/;

  my ($name, $value) = @_;
  my $tmpdir   = basename($0) . '-' . $$;
  my $filename = "/tmp/$tmpdir/$name";

  push @INC, "/tmp/$tmpdir" unless grep /^\/tmp\/$tmpdir$/, @INC;

  mkpath(dirname($filename));
  unless (-e $filename) {
    open my $fh, '>', $filename;
    print $fh $value;
    close $fh;
  }
};
__
meta::meta('type::indicator', <<'__');
# Shell indicator function. The output of each of these is automatically
# appended to the shell prompt.

meta::configure 'indicator', inherit => 1, extension => '.pl';
meta::define_form 'indicator', sub {
  my ($name, $value) = @_;
  *{"indicator::$name"} = meta::eval_in("sub {\n$value\n}", "indicator::$name");
};
__
meta::meta('type::internal_function', <<'__');
meta::configure 'internal_function', extension => '.pl', inherit => 1;
meta::define_form 'internal_function', sub {
  my ($name, $value) = @_;
  *{$name} = meta::eval_in("sub {\n$value\n}", "internal_function::$name");
};
__
meta::meta('type::library', <<'__');
meta::configure 'library', extension => '.pl', inherit => 1;
meta::define_form 'library', sub {
  my ($name, $value) = @_;
  meta::eval_in($value, "library::$name");
};
__
meta::meta('type::message_color', <<'__');
meta::configure 'message_color', extension => '', inherit => 1;
meta::define_form 'message_color', sub {
  my ($name, $value) = @_;
  terminal::color($name, $value);
};
__
meta::meta('type::meta', <<'__');
# This doesn't define a new type. It customizes the existing 'meta' type
# defined in bootstrap::initialization. Note that horrible things will
# happen if you redefine it using the editable functor.

meta::configure 'meta', extension => '.pl', inherit => 1;
__
meta::meta('type::page', <<'__');
meta::functor::editable 'page', inherit => 0, default => 'edit', extension => sub {
  extension_for(attribute($_[0])) . '.sdoc';
};

__
meta::meta('type::parent', <<'__');
meta::define_form 'parent', \&meta::bootstrap::implementation;
meta::configure 'parent', extension => '', inherit => 1;
__
meta::meta('type::post', <<'__');
meta::functor::editable 'post', inherit => 0, default => 'edit', extension => sub {
  extension_for(attribute($_[0])) . '.sdoc';
};

__
meta::meta('type::retriever', <<'__');
meta::configure 'retriever', extension => '.pl', inherit => 1;
meta::define_form 'retriever', sub {
  my ($name, $value) = @_;
  $transient{retrievers}{$name} = meta::eval_in("sub {\n$value\n}", "retriever::$name");
};
__
meta::meta('type::sdoc', <<'__');
# A meta-type for other types. So retrieve('js::main') will work if you have
# the attribute 'sdoc::js::main'. The filename will be main.js.sdoc.

meta::functor::editable 'sdoc', inherit => 1, extension => sub {
  extension_for(attribute($_[0])) . '.sdoc';
};
__
meta::meta('type::slibrary', <<'__');
meta::configure 'slibrary', extension => '.pl.sdoc', inherit => 1;
meta::define_form 'slibrary', sub {
  my ($name, $value) = @_;
  meta::eval_in(sdoc("slibrary::$name"), "slibrary::$name");
};

__
meta::meta('type::spage', <<'__');
meta::functor::editable 'spage', inherit => 0, default => 'edit', extension => sub {
  extension_for(attribute($_[0])) . '.sdoc';
};

__
meta::meta('type::state', <<'__');
# Allows temporary or long-term storage of states. Nothing particularly insightful
# is done about compression, so storing alternative states will cause a large
# increase in size. Also, states don't contain other states -- otherwise the size
# increase would be exponential.

# States are created with the save-state function.

meta::configure 'state', inherit => 0, extension => '.pl';
meta::define_form 'state', \&meta::bootstrap::implementation;
__
meta::meta('type::template', <<'__');
meta::configure 'template', extension => '.pl', inherit => 1;
meta::define_form 'template', sub {
  my ($name, $value) = @_;
  meta::externalize "template::$name", "template::$name", meta::eval_in("sub {\n$value\n}", "template::$name");
};
__
meta::meta('type::wpage', <<'__');
meta::functor::editable 'wpage', inherit => 0, default => 'edit', extension => sub {
  extension_for(attribute($_[0])) . '.waul.sdoc';
};

__
meta::alias('eh', 'edit sdoc::index.html');
meta::alias('ehh', 'edit sdoc::header.html');
meta::alias('ei', 'edit page::index');
meta::alias('eps', 'edit sdoc::posts.html');
meta::alias('erf', 'edit function::render');
meta::alias('es', 'edit sdoc::style.css');
meta::alias('ez', 'edit spage::zeroconsulting');
meta::bootstrap('html', <<'__');
<html>
  <head>
  <meta http-equiv='content-type' content='text/html; charset=UTF-8' />
  <link rel='stylesheet' href='http://spencertipping.com/perl-objects/web/style.css'/>

  <script src='http://ajax.googleapis.com/ajax/libs/jquery/1.5.2/jquery.min.js'></script>
  <script src='http://spencertipping.com/caterwaul/caterwaul.all.min.js'></script>
  <script src='http://spencertipping.com/montenegro/montenegro.client.js'></script>
  <script src='http://spencertipping.com/perl-objects/web/attribute-parser.js'></script>
  <script src='http://spencertipping.com/perl-objects/web/interface.js'></script>
  </head>
  <body></body>
</html>

__
meta::bootstrap('initialization', <<'__');
#!/usr/bin/perl
# 99aeabc9ec7fe80b1b39f5e53dc7e49e      <- self-modifying Perl magic

# This is a self-modifying Perl file. I'm sorry you're viewing the source (it's
# really gnarly). If you're curious what it's made of, I recommend reading
# http://github.com/spencertipping/writing-self-modifying-perl.
#
# If you got one of these from someone and don't know what to do with it, send
# it to spencer@spencertipping.com and I'll see if I can figure out what it
# does.

# For the benefit of HTML viewers (this is hack):
# <div id='cover' style='position: absolute; left: 0; top: 0; width: 10000px; height: 10000px; background: white'></div>

$|++;

my %data;
my %transient;
my %externalized_functions;
my %datatypes;

my %locations;          # Maps eval-numbers to attribute names

my $global_data = join '', <DATA>;

sub meta::define_form {
  my ($namespace, $delegate) = @_;
  $datatypes{$namespace} = $delegate;
  *{"meta::${namespace}::implementation"} = $delegate;
  *{"meta::$namespace"} = sub {
    my ($name, $value, %options) = @_;
    chomp $value;
    $data{"${namespace}::$name"} = $value unless $options{no_binding};
    &$delegate($name, $value) unless $options{no_delegate}}}

sub meta::eval_in {
  my ($what, $where) = @_;

  # Obtain next eval-number and alias it to the designated location
  @locations{eval('__FILE__') =~ /\(eval (\d+)\)/} = ($where);

  my $result = eval $what;
  $@ =~ s/\(eval \d+\)/$where/ if $@;
  warn $@ if $@;
  $result}

meta::define_form 'meta', sub {
  my ($name, $value) = @_;
  meta::eval_in($value, "meta::$name")};

__
meta::bootstrap('perldoc', <<'__');
=head1 Self-modifying Perl script

=head2 Original implementation by Spencer Tipping L<http://spencertipping.com>

The prototype for this script is licensed under the terms of the MIT source code license.
However, this script in particular may be under different licensing terms. To find out how
this script is licensed, please contact whoever sent it to you. Alternatively, you may
run it with the 'license' argument if they have specified a license that way.

You should not edit this file directly. For information about how it was constructed, go
to L<http://spencertipping.com/writing-self-modifying-perl>. For quick usage guidelines,
run this script with the 'usage' argument.

=cut

__
meta::bzip2('wpage::js-quiz', <<'__');
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
%(=-9:I``

__
meta::bzip2('wpage::pl-quiz', <<'__');
M0EIH,3%!629362OT_/$`!][_@'_X(B#_______?_[O____]@$%SUW?.ND533
MNMWO<M>Y4>*>]I*0`5IHD>C$$CE30`--'N&FB)E!3V(:!3R)M3TCR:(R&CU#
M1HT]0]3T@,@````T!#2`(R1HU)ZGJ;4]0]33)H`-``````T#(#@`&@T-!H`-
M,@T,@::```R`#(#(`"34B)H4_4U3\FBFU-J`::`!H`T:`9--`T#30!D&@$41
M)J-/4RFF30]1HT:-`--!H```:``T`T#0:"1$$:(:33(`$32GIBF3TCU/U31D
M`T```,FC1D,3D-LBR0.4J$0!X:X)(Q9&*Q$%(*(D4(JR3K_74\!%"Z3'P:+6
M[M6TPFEOZT106J#^84HP'SB49Q@R->H"-HN**!*23&JL(JA"T41M67W=GN/<
MRHLD:]U>IF60G-/-CSU:[O34`@4@17W5LQ8[F_&?X+VH_?O1N%FOAA]O6YA=
M+S5DW7?@SP=`,?K9%(D@E$X#>?/A<BRJ#1ZE();.&:)E=(4OMK)AB\9\'U>,
M4_9R_+G>8+-0_E)P'FT>APZEW+9Q1VK%:0./5)4]*4O>\HM2]JBA,*-N%%[I
M0Q$J]:;$E\KW+\UG9SLQ"9MESX'4+P9;:$./^J\Z[9VXNAQH?%DL8R(DG4=;
M^Y]^<]TQ>K"0C<MG1DHG`.?0BGHJS#DZRODJE/R/J+[?EQ>T,C_WB==#H]\$
M$-$,VB0ZC,V]-IK?+K:%N7M_!W5'T"K++>FU$=;Q[TXH4U,]+"X6T2:"RT#:
M_`EPJ/!''\L#?U-G2X@ZC5*]F]-3&E3`$H(S`AR`M*G)2C"*#F5\==*4J?5P
MOJ6?*BTO/+@B&2YM1;C)\UB4@LDYUS:*F>V,A@X&^9.:YFJETG&U)<)+E%&<
MBL.L";)Y[SA:#2%92:1VR"W)RJ`_,+!`@&9@&9;$O0J4W%*-EUQ/,MPYL[[!
MC&&N9=HCA/&CI$-$)&^#_[8C@G9?#W35\1\LX#;L(*]M3$J$E'Q(9&`&XIH+
M.G4%CLEIR<M+ACS':IYOG3-_`2>G7HI[8R'/7+D;;Q<F,"^VXQ4T@8-1[,@A
MNXM)OKH::-(FC*K.9F02C*&5J+(M0&&:I3;7C&VD@@<;G2^Y+MU,`?"RL[RD
MRB(6P0.!Y&>+G./<JR[<=]2>008G9>C@%@FDROEL10:E_NO542IP;%?JV]9E
M@<(F"X%KPG;%3%=4EY%&.6"D0%=8T,)K523.:_OX9FE=-]&@_B8!]36]GZWA
M!^.ED?:\?GYE?3^L"K!H@E=D<;$=>MMV%A`6*3\V73''&+7-VW4PC8U=MMBK
ME>XBZKG48Y*H1$/QW4V-.Z[-VXA7XNPX`[7+M6;#XIKSD6P_Z(#ZJJ0&Q%%5
M8HL50%@42D18!B&0)A9)SP1A#TTD-BP6A1S8,CRY(;?)$,XC8C^Q@$(6316I
M'::>7VZ'9E6V7TS[TP.+5Q.1.G0C*"))&+A9C*?ELDF#)+`F!XIV]EM]2\4A
MUS(KACEK4_2&YRF&`C3+6P=Q!:_?H5PO]`\KMEY8&L''%!(=H""S((W9?8UR
MGZ-,\Q+'=`+N*#0NE8KG6Z=!!E4B`M@F54L+LI$:(;:,J$N@"Y/ID=?5W?53
MTN8?CYZ]M:GBS8$]#7'!NB1=H!,CYT>%&X]1;3,P4=&RM^V58;)2X4098A2@
M,[]S7[S&8ID[*NK\>A[JKXSWVHDH6EM%$:)V$AW7%L,C"]DX6^S"/7WF;JO*
MEK*QG58Q9STLB,1J?20*4E8K?\M`+CB('`@0CE/R,RX&';[ZA4T:"SB`I'#I
MTPWGQ3X'#P<6D"L$'\-%2M&F*TN(@*&/,+504&#!G=5DIE`($"'8&@,YG7AJ
M:DDA^8S(K%$H*(,%/2^UY]]J/1Z88`*64<_)9K%"1D94F%DHV,R5I1LYJO4J
MT2S3TTNRA.640>8IK'CXE=QJ@8AQ$"!K#>*H+"34%4MF]<63#I7G"+&((]L:
M$1B+$&*@"]-I(D42?9^<M`DLL015&2)&"=(^0J6!!B*QG1[7:N27+H3MRQ2)
M.I_VRT_```3X?Z18C(:4C($2T="JEJY&0IQ<)?4Q[79QYXR&2(4L/G_#S+?.
M<P^71HZ_-\;C"5JKHN&DDHI%B@L@Q6101B]Y;BJH2N2WL=CC.0C"?><O)LU'
M50>LRGB8&RA6&8)WE^IB]5IJZ6X,-BW-4J&K;.L`?T&3!K-J5_4'R8:FA01M
MFT$B^JBIYF0H;L"9G#-U><,+Y"B8`:JA,AHZQ?%`,0['9N^WIGWZ(7^/8LL:
M&QOYG,5DH&J#(!A0<@K?[B[FN[M_&EIDL/"`E"MQXK0DS_GU[2S+906[NTEF
MDXC1.Y+H3.M0H\8)C-FN6ZE@*PE$>D-?;AN*EXW%(I.@9!3`SQLLUT3V2;6<
M[#GH#?[$VY+Z]VIE'.SLE,[DTB!K&B5<20B/7[U@W,<J!D\S@-)(>J@9BON4
MJFP+;Q_5WR;:(%!-<VP!,B"*RHR9E4*\M&RU:,)8M\[.\I8*F5VI)M%5)"+L
M\TS.PP"PTV=5,W`X%P&#V@1$JT2L"HX-J."_RPK&\3A!N[.`;J+<R`WWW,\S
MBQP8?MC5>-XK:_PDO8LQ6K=GPK-%5!?/G9T*BR;1Z08/\KSC76340ZXS9AD.
MM&8U09P=3]+TO33"T,5=M%,(&*6D%ZQ1KL>I5H16"9!S"05H62],]Q:V4X)Z
MU3@;XEHXII0N:_02DOI6_(S^2.A,6W).Q2V.H`.I%A9+="]CCV)<5RB-4TLL
MQZ=:VT=.A-QK:ZU!Y,YBQM<)Q$&I:0?'@97'Q@AFI6N^@;@C>'(*47_@$8&&
M@])PN!-#M$EIP4G#>[VJJP1WA5.#BX&9]#B"RSRJ*L1!`+-(!X&:E$#@L<#;
M=7"KO]*H2^:<9;G[KLT0&`-^OA;X^L"W++P5UEO,"NT-)B(A!9OZ4*]:(ZED
MN@0M<1*7&!E*7D7(X42S:)H*TEFO:'!4\K%4LX!%#BN9WW8B&0UK+)(AM,=U
M1D_ZB7<3*"6@;2-ME%DF6!@K>WYZ-J&[$+6QU(:A(+%(2V$*%!$O'7-I/@_;
M@5L$OB'J<J"4%4Q@T%27M[+)5.AF[BS]>`9U#O-->F+?<!I"XL]SR!;V!@E8
MT1L)CO$0*'[;%0XP/-!GFI9^EZD`2Q<4D9#$48$1@(QB!SVX2V[+B#40R`UL
M0C)$4(HC(HD8D$-AIU']FT.%_G67<,`[O+3H=J"O+/>!M]^#BI1W^N0+<),/
M$8C@L-IFD0/V[4G4[*V!B($68.8A5)@A^,A"EE"2DZN@C&Q\3K%EH`9&FR%"
MHK2$\D/(HZSJ$%2O/,81(D.`31D8O$B`IA@A"K">331";B%!U(&EL??-ZWE3
MXC,Z`MV1@)$R,LR!9XKXJY,%ECDU3C1&>3YKAY\,?9$ZGRH5`NLS0-6!89*H
M5+U%0H62B$1-8WD>HQS-*AIO8-^>6/3DK0@&,%DCKJHBLJ508-6*LTR][HVN
M-^[@D*EC$1PH,;40+N;<27HHA;5B3+"KP@PH:9&I0Q;+*GY"M"L4%<;$,2N7
M@C5VI1-H2NQL3`+!:E$&1E.0.UPE+)UJ5%"=\Y"4DI;*%T4";I3@&216RKX!
M135!0&0.$5S,J"E'IST8+T&2Y9LZ-0FI?0ZEK=,7B[7J5U\4(CN#-*@D<[&F
M:5_"AWH*&!AWPERY[B!WR&I)I29VH$_K.T`NFL9+()8ZI#2&G7BCO:"D%*$*
MH)4,7NFPG,-)(BH8-*D?10E2;ZZ&`&!7<S=1)7XHW`^9B"QDBP=ITG6GA^A,
MZJ5C@YNURXDZ)7W7']UB/V@>]>#']'N8"T=/9"K0]7YM'4D=!)#.@0$N7;Q!
MS+V6[V1FVY,D</X[!Y*4B-:9@:$Q+:MR.`)$RL`-SJ5MS-,T8#-ICWJ=,5D7
M7K9R:E;R2U-?.@<].Z"2`::'`T0-,/29#[1#1[XD)MV#,+]F.6C+"XIC=(,5
M7!O=%N+RWU;]X3"&-&G(4,,NA5I`=4+?\9FE5DB5H4-07PT1<#\T"A[`55A?
M>;/G"QQ*?-NGLZ:7"OZLI*35E,N&\A1:"PV@40#;T-=N+PZRTI&I2-.W*GQ<
M-3$4*@!K$7BI(*H[W;',@JJ8/=>,018.RFHIP_F>+BG*DLK`14<1`U?&3K#H
MU%(J31!8J0@C\UM_5E;QQ14H9,&T6FYDSC[_K/)3Y[`N9LS"1T_<="YR3I96
M:*WBQK*4E_<ZE%Q)C%+4(+M-BJ!WTH8!4!ER(2'WSD!5,TB807Y0.$S($$*I
MNB%?B6H6<3J7HE1`PTSG+/EZ3K4Q8&!?RDDH.,TDQ3)Y;K%3)1;(QB?.M;4N
M:5%I0-(OBC1+2AWK%IUJ60.#)"F0W8#S%1*B-K%<JE)BE4SE%0N0C)AI9&?R
M[X-(5+I)=0TC*L`([&:'D&I-O%+/<,X"4!N:F((9*2A0$*!J98INY5BXD-/L
MV"HI_>9OQ>2"#$6,;5"G0LT84,9S&MA>K?B!Q9P!8'6NB791@SZ"M79%0A&0
M9]B'(CC@]]CR(TK!"9O+*5RS,/@09B6`H52=1FAO*M9"^P=$$4WJXCD.PC?\
MTQ$,]X&4<-"HIQ5/"M6$)DN&+=*+24R=A\R=^]$4/)-((0,HJ!Y$B*,.O[,:
MO?!N)KS_=@*LI%7]9]-0F(K]QA0.H$4)@/".20NAUIWD)4C'TB*\839UJ0T[
MB.-*E[V;P7BBNS"`M`.11OH`1$;27YQ0*Q2(\!"6,ZCG:]?5)\EE2O=+=VH?
+\7<D4X4)`K]/SQ``

__
meta::cache('parent-identification', <<'__');
/home/spencertipping/bin/object 99aeabc9ec7fe80b1b39f5e53dc7e49e
/home/spencertipping/bin/preprocessor 70dae4b46eb4e06798ec6f38d17d4c7b
/home/spencertipping/conjectures/perl-objects/sdoc a1e8480e579614c01dabeecf0f963bcc
compressed 520b552d3a50a6c14067471f08aaddab
encrypted 6a38f6fbcf92173ff757305a534a002b
html 1df113f7cef70e75214a2f28ca266c5e
object 99aeabc9ec7fe80b1b39f5e53dc7e49e
preprocessor 70dae4b46eb4e06798ec6f38d17d4c7b
__
meta::data('author', 'Spencer Tipping');
meta::data('default-action', 'shell');
meta::data('license', <<'__');
MIT License
Copyright (c) 2010 Spencer Tipping

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
__
meta::data('permanent-identity', '04e0eac60d14b32751ddb9f823b75200');
meta::data('watching', '1');
meta::function('ad', <<'__');
return @{$transient{path}} = () unless @_;
push @{$transient{path}}, @_;

__
meta::function('alias', <<'__');
my ($name, @stuff) = @_;
@_ ? @stuff ? around_hook('alias', @_, sub {associate("alias::$name", join(' ', @stuff), execute => 1)})
            : retrieve("alias::$name") // "Undefined alias $name"
   : table_display([select_keys('--namespace' => 'alias')], [map retrieve($_), select_keys('--namespace' => 'alias')]);

__
meta::function('cat', 'join "\\n", retrieve(@_);');
meta::function('cc', <<'__');
# Stashes a quick one-line continuation. (Used to remind me what I was doing.)
@_ ? associate('data::current-continuation', hook('set-cc', join(' ', @_))) : retrieve('data::current-continuation');
__
meta::function('ccc', 'rm(\'data::current-continuation\');');
meta::function('child', <<'__');
around_hook('child', @_, sub {
  my ($child_name) = @_;
  clone($child_name);
  enable();
  qx($child_name update-from $0 -n);
  disable()});
__
meta::function('clone', <<'__');
for (grep length, @_) {
  around_hook('clone', $_, sub {
    hypothetically(sub {
      rm('data::permanent-identity');
      file::write($_, serialize(), noclobber => 1);
      chmod(0700, $_)})})}
__
meta::function('compress', <<'__');
# Compresses one or more attributes.
exists $data{$_} or die "$_ doesn't exist; not compressing anything" for @_;
associate("bzip2::$_", compress_data(retrieve($_))), rm($_) for @_;

__
meta::function('cp', <<'__');
my $from = shift @_;
my $value = retrieve($from);
associate($_, $value) for @_;
__
meta::function('create', <<'__');
my ($name, $value) = @_;
around_hook('create', $name, $value, sub {
  return edit($name) if exists $data{$name};
  associate($name, defined $value ? $value : '');
  edit($name) unless defined $value});
__
meta::function('current-state', 'serialize(\'-pS\');');
meta::function('disable', 'hook(\'disable\', chmod_self(sub {$_[0] & 0666}));');
meta::function('edit', <<'__');
my ($name, %options) = @_;
my $extension = extension_for($name);

die "$name is virtual or does not exist" unless exists $data{$name};
die "$name is inherited; use 'edit $name -f' to edit anyway" unless is($name, '-u') || is($name, '-d') || exists $options{'-f'};

around_hook('edit', @_, sub {
  associate($name, invoke_editor_on($data{$name} // '', %options, attribute => $name, extension => $extension), execute => 1)});

save() unless $data{'data::edit::no-save'};
'';

__
meta::function('edit-self', <<'__');
$global_data = invoke_editor_on($global_data);
save();

__
meta::function('enable', 'hook(\'enable\', chmod_self(sub {$_[0] | $_[0] >> 2}));');
meta::function('export', <<'__');
# Exports data into a text file.
#   export attr1 attr2 attr3 ... file.txt
my $name = pop @_;
@_ or die 'Expected filename';
file::write($name, join "\n", retrieve(@_));
__
meta::function('extern', '&{$_[0]}(retrieve(@_[1 .. $#_]));');
meta::function('grep', <<'__');
# Looks through attributes for a pattern. Usage is grep pattern [options], where
# [options] is the format as provided to select_keys.

my ($pattern, @args)     = @_;
my ($options, @criteria) = separate_options(@args);
my @attributes           = select_keys(%$options, '--criteria' => join('|', @criteria));

$pattern = qr/$pattern/;

my @m_attributes;
my @m_line_numbers;
my @m_lines;

for my $k (@attributes) {
  next unless length $k;
  my @lines = split /\n/, retrieve($k);
  for (0 .. $#lines) {
    next unless $lines[$_] =~ $pattern;
    push @m_attributes,   $k;
    push @m_line_numbers, $_ + 1;
    push @m_lines,        '' . ($lines[$_] // '')}}

unless ($$options{'-C'}) {
  s/($pattern)/\033[1;31m\1\033[0;0m/g for @m_lines;
  s/^/\033[1;34m/o for @m_attributes;
  s/^/\033[1;32m/o && s/$/\033[0;0m/o for @m_line_numbers}

table_display([@m_attributes], [@m_line_numbers], [@m_lines]);
__
meta::function('hash', 'fast_hash(@_);');
meta::function('hook', <<'__');
my ($hook, @args) = @_;
$transient{active_hooks}{$hook} = 1;
dangerous('', sub {&$_(@args)}) for grep /^hook::${hook}::/, sort keys %data;
@args;
__
meta::function('hooks', 'join "\\n", sort keys %{$transient{active_hooks}};');
meta::function('identity', 'retrieve(\'data::permanent-identity\') || associate(\'data::permanent-identity\', fast_hash(rand() . name() . serialize()));');
meta::function('import', <<'__');
my $name = pop @_;
associate($name, @_ ? join('', map(file::read($_), @_)) : join('', <STDIN>)); 
__
meta::function('initial-state', '$transient{initial};');
meta::function('is', <<'__');
my ($attribute, @criteria) = @_;
my ($options, @stuff) = separate_options(@criteria);
exists $data{$attribute} and attribute_is($attribute, %$options);

__
meta::function('load-state', <<'__');
around_hook('load-state', @_, sub {
  my ($state_name) = @_;
  my $state = retrieve("state::$state_name");

  terminal::state('saving current state into _...');
  save_state('_');

  delete $data{$_} for grep ! /^state::/, keys %data;
  %externalized_functions = ();

  terminal::state("restoring state $state_name...");
  meta::eval_in($state, "state::$state_name");
  terminal::error(hook('load-state-failed', $@)) if $@;
  reload();
  verify()});

__
meta::function('lock', 'hook(\'lock\', chmod_self(sub {$_[0] & 0555}));');
meta::function('ls', <<'__');
my ($options, @criteria) = separate_options(@_);
my ($external, $shadows, $sizes, $flags, $long, $hashes, $parent_hashes) = @$options{qw(-e -s -z -f -l -h -p)};
$sizes = $flags = $hashes = $parent_hashes = 1 if $long;

return table_display([grep ! exists $data{$externalized_functions{$_}}, sort keys %externalized_functions]) if $shadows;

my $criteria    = join('|', @criteria);
my @definitions = select_keys('--criteria' => $criteria, '--path' => $transient{path}, %$options);

my %inverses  = map {$externalized_functions{$_} => $_} keys %externalized_functions;
my @externals = map $inverses{$_}, grep length, @definitions;
my @internals = grep length $inverses{$_}, @definitions;
my @sizes     = map sprintf('%6d %6d', length(serialize_single($_)), length(retrieve($_))), @{$external ? \@internals : \@definitions} if $sizes;

my @flags     = map {my $k = $_; join '', map(is($k, "-$_") ? $_ : '-', qw(d i m u))} @definitions if $flags;
my @hashes    = map fast_hash(retrieve($_)), @definitions if $hashes;

my %inherited     = parent_attributes(grep /^parent::/o, keys %data) if $parent_hashes;
my @parent_hashes = map $inherited{$_} || '-', @definitions if $parent_hashes;

join "\n", map strip($_), split /\n/, table_display($external ? [grep length, @externals] : [@definitions],
                                                    $sizes ? ([@sizes]) : (), $flags ? ([@flags]) : (), $hashes ? ([@hashes]) : (), $parent_hashes ? ([@parent_hashes]) : ());

__
meta::function('mv', <<'__');
my ($from, $to) = @_;
die "'$from' does not exist" unless exists $data{$from};
associate($to, retrieve($from), execute => 1);
rm($from);

__
meta::function('name', <<'__');
my $name = $0;
$name =~ s/^.*\///;
$name;
__
meta::function('parents', 'join "\\n", grep s/^parent:://o, sort keys %data;');
meta::function('perl', <<'__');
my @result = eval(join ' ', @_);
$@ ? terminal::error($@) : wantarray ? @result : $result[0];

__
meta::function('post', <<'__');
use POSIX qw/strftime/;

my $title = join ' ', @_;
my $date  = strftime '%Y.%m%d', localtime;

$title =~ s/[^A-Za-z0-9.]/-/g;
$title =~ s/-+/-/g;

associate('sdoc::posts.html', "- include-post $date $title\n" . retrieve('sdoc::posts.html'));
create("post::$date.$title");

__
meta::function('preprocess', <<'__');
# Implements a simple preprocessing language.
# Syntax follows two forms. One is the 'line form', which gives you a way to specify arguments inline
# but not spanning multiple lines. The other is 'block form', which gives you access to both one-line
# arguments and a block of lines. The line parameters are passed in verbatim, and the block is
# indentation-adjusted and then passed in as a second parameter. (Indentation is adjusted to align
# with the name of the command.)
#
# Here are the forms:
#
# - line arguments to function
#
# - block line arguments << eof
#   block contents
#   block contents
#   ...
# - eof

my ($string, %options) = @_;
my $expansions         = 0;
my $old_string         = '';
my $limit              = $options{expansion_limit} || 100;
my @pieces             = ();

sub adjust_spaces {
  my ($spaces, $string) = @_;
  $string =~ s/^$spaces  //mg;
  chomp $string;
  $string;
}

while ($old_string ne $string and $expansions++ < $limit) {
  $old_string = $string;

  while ((my @pieces = split  /(^(\h*)-\h \S+ \h* \V* <<\h*(\w+)$ \n .*?  ^\2-\h\3$)/xms, $string) > 1 and $expansions++ < $limit) {
    $pieces[1 + ($_ << 2)] =~ /^ (\h*)-\h(\S+)\h*(\V*)<<\h*(\w+)$ \n(.*?) ^\1-\h\4 $/xms && $externalized_functions{"template::$2"} and
      $pieces[1 + ($_ << 2)] = &{"template::$2"}($3, adjust_spaces($1, $5))
      for 0 .. $#pieces / 4;

    @pieces[2 + ($_ << 2), 3 + ($_ << 2)] = '' for 0 .. $#pieces / 4;
    $string = join '', @pieces;
  }

  if ((my @pieces = split     /^(\h*-\h \S+ \h* .*)$/xom, $string) > 1) {
    $pieces[1 + ($_ << 1)] =~ /^ \h*-\h(\S+)\h*(.*)$/xom && $externalized_functions{"template::$1"} and
      $pieces[1 + ($_ << 1)] = &{"template::$1"}($2)
      for 0 .. $#pieces >> 1;

    $string = join '', @pieces;
  }
}

$string;
__
meta::function('rd', <<'__');
if (@_) {my $pattern = join '|', @_;
         @{$transient{path}} = grep $_ !~ /^$pattern$/, @{$transient{path}}}
else    {pop @{$transient{path}}}

__
meta::function('reload', 'around_hook(\'reload\', sub {execute($_) for grep ! /^bootstrap::/, keys %data});');
meta::function('render', <<'__');
my ($options, @stuff) = separate_options(@_);

terminal::info('rendering pages');
file::write("pages/" . attribute($_) . ".html", render_page($_, '--sdoc=' . /^spage::/), mkpath => 1) for grep /^s?page::/, sort keys %data;

unless ($$options{-W}) {
  file::write("pages/" . attribute($_) . ".html", render_waul_page($_), mkpath => 1) for grep /^wpage::/, sort keys %data}

terminal::info('rendering posts');
/^post::(\d{4}\.\d{4})\.(.*)/ and
file::write("posts/$1.$2.html", render_page("pp::id::- include-post $1 $2", '--sdoc=0'), mkpath => 1) for sort keys %data;

file::write("quiz-source/README.md", retrieve("markdown::quiz-readme"), mkpath => 1);
file::write("quiz-source/$_.md",     retrieve("markdown::wpage::$_")) for grep s/^wpage::(.*-quiz)$/\1/, sort keys %data;

file::write('feed.atom', render_atom());

__
meta::function('render-atom', <<'__');
my $convert_date   = sub {my ($d) = @_; $d =~ s/^(\d{4})\.(\d\d)(\d\d)/\1-\2-\3T00:00:00Z/; $d};
my $convert_text   = sub {my ($text) = @_; $text =~ s/<[^>]+>//g; substr($text, 0, 200)};

my @ordered_posts  = sort {$b cmp $a} grep s/^post:://, keys %data;
my %post_titles    = map {$_ => substr($_, 10)}                   @ordered_posts;
my %post_dates     = map {$_ => &$convert_date(substr($_, 0, 9))} @ordered_posts;

my %post_summaries = map {$_ => &$convert_text(retrieve("post::$_"))} @ordered_posts;

my @post_fragments = map "<entry>\n$_\n</entry>\n\n",
                     map join("\n", "<title>$post_titles{$_}</title>"
                                  , "<link href='http://spencertipping.com/posts/$_.html'/>"
                                  , "<id>http://spencertipping.com/posts/$_.html</id>"
                                  , "<updated>" . $post_dates{$_} . "</updated>"
                                  , "<summary>" . $post_summaries{$_} . "...</summary>"
                                  , "<author><name>Spencer Tipping</name><email>spencer\@spencertipping.com</email></author>"), @ordered_posts;

my ($sec, $min, $hour, $mday, $mon, $year, undef, undef, undef) = localtime();
my $updated = sprintf "%04d-%02d-%02dT%02d:%02d:%02dZ", $year + 1900, $mon + 1, $mday, $hour, $min, $sec;

<<end;
<?xml version='1.0' encoding='utf-8'?>
<feed xmlns='http://www.w3.org/2005/Atom'>
  <title>spencertipping's blog</title>
  <link href='http://spencertipping.com/feed.atom' rel='self'/>
  <link href='http://spencertipping.com/'/>
  <id>http://spencertipping.com/</id>
  <updated>$updated</updated>

  @post_fragments
</feed>
end

__
meta::function('render-page', <<'__');
my ($options, @pages) = separate_options(@_);
my $template          = preprocess(retrieve('sdoc::page.html'));
my $page_contents     = preprocess(cat(@pages));

$page_contents = sdoc_html("id::\n\n$page_contents") if $$options{'--sdoc'};

$template =~ s/^Page contents go here$/$page_contents/m;
$template;

__
meta::function('render-waul-page', <<'__');
my ($waul_source) = @_;

terminal::info("waul-compiling $waul_source...");
my $js_source = with_exported($waul_source, sub {
  my ($file) = @_;
  rename $file, "$file.waul.sdoc";
  terminal::info("running waul -e deps/future.js $file.waul.sdoc"),
  sh("waul -e deps/future.js $file.waul.sdoc") or unlink "$file.waul.sdoc";
  my $result = file::read("$file.js");
  unlink "$file.js";
  $result});

my @deps     = qw/jquery.min caterwaul.min caterwaul.std.min caterwaul.ui.min future/;

my $template = preprocess(retrieve("sdoc::page.html"));
my $scripts  = join "\n", cat(map "deps/$_.js", @deps);
my $contents = <<end;
<script>
$scripts
$js_source
</script>
end

$template =~ s/Page contents go here/$contents/;
$template;

__
meta::function('rm', <<'__');
around_hook('rm', @_, sub {
  exists $data{$_} or terminal::warning("$_ does not exist") for @_;
  delete @data{@_}});
__
meta::function('rmparent', <<'__');
# Removes one or more parents.
my ($options, @parents) = separate_options(@_);
my $clobber_divergent = $$options{'-D'} || $$options{'--clobber-divergent'};

my %parents = map {$_ => 1} @parents;
my @other_parents = grep !$parents{$_}, grep s/^parent:://, select_keys('--namespace' => 'parent');
my %kept_by_another_parent;

$kept_by_another_parent{$_} = 1 for grep s/^(\S+)\s.*$/\1/, split /\n/o, cat(@other_parents);

for my $parent (@parents) {
  my $keep_parent_around = 0;

  for my $line (split /\n/, retrieve("parent::$parent")) {
    my ($name, $hash) = split /\s+/, $line;
    next unless exists $data{$name};

    my $local_hash = fast_hash(retrieve($name));
    if ($clobber_divergent or $hash eq $local_hash or ! defined $hash) {rm($name) unless $kept_by_another_parent{$name}}
    else {terminal::info("local attribute $name exists and is divergent; use rmparent -D $parent to delete it");
          $keep_parent_around = 1}}

  $keep_parent_around ? terminal::info("not deleting parent::$parent so that you can run", "rmparent -D $parent if you want to nuke divergent attributes too")
                      : rm("parent::$parent")}

__
meta::function('save', 'around_hook(\'save\', sub {dangerous(\'\', sub {file::write($0, serialize()); $transient{initial} = state()}) if verify()});');
meta::function('save-state', <<'__');
# Creates a named copy of the current state and stores it.
my ($state_name) = @_;
around_hook('save-state', $state_name, sub {
  associate("state::$state_name", current_state(), execute => 1)});

__
meta::function('sdoc', <<'__');
# Applies SDoc processing to a file or attribute. Takes the file or attribute
# name as the first argument and returns the processed text.

my %comments_for_extension = 
  qw|c     /*,*/  cpp   //    cc   //    h    //    java //  py  #    rb   #    pl  #   pm   #         ml   (*,*)  js  //
     hs    --     sh    #     lisp ;;;   lsp  ;;;   s    #   scm ;;;  sc   ;;;  as  //  html <!--,-->  mli  (*,*)  cs  //
     vim   "      elisp ;     bas  '     ada  --    asm  ;   awk #    bc   #    boo #   tex  %         fss  (*,*)  erl %
     scala //     hx    //    io   //    j    NB.   lua  --  n   //   m    %    php //  sql  --        pov  //     pro %
     r     #      self  ","   tcl  #     texi @c    tk   #   csh #    vala //   vbs '   v    /*,*/     vhdl --     ss  ;;;
     haml  -#     sass  /*,*/ scss /*,*/ css  /*,*/ fig  /   waul #|;

# No extension suggests a shebang line, which generally requires # to denote a comment.
$comments_for_extension{''} = '#';

my $generated_string = 'Generated by SDoc';

sub is_code    {map /^\s*[^A-Z\|\s]/o, @_}
sub is_blank   {map /^\n/o, @_}
sub comment    {my ($text, $s, $e) = @_; join "\n", map("$s $_$e", split /\n/, $text)}

sub paragraphs {map split(/((?:\n\h*){2,})/, $_), @_}

my ($filename, $specified_extension) = @_;

# Two possibilities here. One is that the filename is an attribute, in which case
# we want to look up the extension in the transients table. The other is that
# it's a real filename.
my ($extension)       = $specified_extension || ($filename =~ /\.sdoc$/io ? $filename =~ /\.(\w+)\.sdoc$/igo : $filename =~ /\.(\w+)$/igo);
my ($other_extension) = extension_for($filename);
$other_extension =~ s/\.sdoc$//io;
$other_extension =~ s/^\.//o;

my ($start, $end) = split /,/o, $comments_for_extension{lc($other_extension || $extension)} // $comments_for_extension{''} // '#';

join '', map(is_code($_) || is_blank($_) ? ($_ =~ /^\s*c\n(.*)$/so ? $1 : $_) : comment($_, $start, $end), paragraphs retrieve($filename)),
         "\n$start $generated_string $end\n";

__
meta::function('sdoc-html', <<'__');
# Converts SDoc to logically-structured HTML. Sections end up being nested,
# and code sections and examples are marked as such. For instance, here is some
# sample output:

# <div class='section level1'>
#   <h1 class='title'>Foo</h1>
#   <p>This is a paragraph...</p>
#   <p>This is another paragraph...</p>
#   <pre class='code'>int main () {return 0;}</pre>
#   <pre class='quoted'>int main () {return 0} // Won't compile</pre>
#   <div class='section level2'>
#     <h2 class='title'>Bar</h2>
#     ...
#   </div>
# </div>

# It is generally good about escaping things that would interfere with HTML,
# but within text paragraphs it lets you write literal HTML. The heuristic is
# that known tags that are reasonably well-formed are allowed, but unknown ones
# are escaped.

my ($attribute)   = @_;
my @paragraphs    = split /\n(?:\s*\n)+/, retrieve($attribute);

my $known_tags    = join '|', qw[html head body meta script style link title div a span input button textarea option select form label iframe blockquote code caption
                                 table tbody tr td th thead tfoot img h1 h2 h3 h4 h5 h6 li ol ul noscript p pre samp sub sup var canvas audio video strong em];
my $section_level = 0;
my @markup;

my $indent        = sub {'  ' x ($_[0] || $section_level)};
my $unindent      = sub {my $spaces = '  ' x ($section_level - 1); s/^$spaces//gm};

my $escape_all    = sub {s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g};
my $escape_some   = sub {s/&/&amp;/g; s/<(?!\/|($known_tags)[^>]*>.*<\/\1>)/&lt;/gs};

my $code          = sub {&$escape_all(); &$unindent(); s/^c\n//;                   push @markup, &$indent() . "<pre class='code'>$_</pre>"};
my $quoted        = sub {&$escape_all(); &$unindent(); s/^\|(\s?)/ \1/; s/^  //mg; push @markup, &$indent() . "<pre class='quoted'>$_</pre>"};

my $paragraph     = sub {&$escape_some(); push @markup, &$indent() . "<p>$_</p>"};

my $section       = sub {my $h = $_[0] > 6 ? 6 : $_[0]; push @markup, &$indent($_[0] - 1) . "<div class='section level$_[0]'>", &$indent($_[0]) . "<h$h>$2</h$h>"};
my $close_section = sub {push @markup, &$indent($_[0]) . "</div>"};

my $title = sub {
  my $indentation = (length($1) >> 1) + 1;
  &$close_section($section_level) while $section_level-- >= $indentation;
  &$section($indentation);
  $section_level = $indentation;
};

for (@paragraphs) {
  &$code(),   next unless /^\h*[A-Z|]/;
  &$quoted(), next if     /^\h*\|/;

  &$title(), s/^.*\n// if /^(\s*)(\S.*)\.\n([^\n]+)/ and length("$1$2") < 60 and length("$1$2") - 10 < length($3);
  &$paragraph();
}

&$close_section($section_level) while $section_level--;

join "\n", @markup;

__
meta::function('sdoc-markdown', <<'__');
# Renders a chunk of SDoc as Markdown. This involves converting quoted and
# unquoted code and section headings, but not numbered lists.

my ($attribute)   = @_;
my @paragraphs    = split /\n(?:\s*\n)+/, retrieve($attribute);

my $section_level = 0;
my @markup;

my $indent        = sub {'  ' x ($_[0] || $section_level)};
my $unindent      = sub {my $spaces = '  ' x ($section_level - 1); s/^$spaces//gm; $_};

my $code          = sub {&$unindent(); s/^c\n//;                   push @markup, join("\n", map &$indent(2) . $_, split /\n/)};
my $quoted        = sub {&$unindent(); s/^\|(\s?)/ \1/; s/^  //mg; push @markup, join("\n", map &$indent(2) . $_, split /\n/)};

my $heading       = sub {'#' x $_[0]};
my $section       = sub {&$unindent(); push @markup, &$heading($_[0]) . ' ' . $2};

my $title = sub {
  my $indentation = (length($1) >> 1) + 1;
  &$section($indentation);
  $section_level = $indentation;
};

for (@paragraphs) {
  &$code(),   next unless /^\h*[A-Z|]/;
  &$quoted(), next if     /^\h*\|/;

  &$title(), s/^.*\n// if /^(\s*)(\S.*)\.\n([^\n]+)/ and length("$1$2") < 60 and length("$1$2") - 10 < length($3);
  push @markup, join "\n", map &$unindent(), split /\n/;
}

join "\n\n", @markup;

__
meta::function('sdocp', <<'__');
# Renders an attribute as SDocP. This logic was taken directly from the sdoc script.
my $attribute = retrieve($_[0]);
sub escape {my @results = map {s/\\/\\\\/go; s/\n/\\n/go; s/'/\\'/go; $_} @_; wantarray ? @results : $results[0]}
"sdocp('" . escape($_[0]) . "', '" . escape($attribute) . "');";
__
meta::function('serialize', <<'__');
my ($options, @criteria) = separate_options(@_);
my $partial     = $$options{'-p'};
my $criteria    = join '|', @criteria;
my @attributes  = map serialize_single($_), select_keys(%$options, '-m' => 1, '--criteria' => $criteria), select_keys(%$options, '-M' => 1, '--criteria' => $criteria);
my @final_array = @{$partial ? \@attributes : [retrieve('bootstrap::initialization'), @attributes, 'internal::main();', '', '__DATA__', $global_data]};
join "\n", @final_array;

__
meta::function('serialize-single', <<'__');
# Serializes a single attribute and optimizes for content.

my $name          = $_[0] || $_;
my $contents      = $data{$name};
my $meta_function = 'meta::' . namespace($name);
my $invocation    = attribute($name);
my $escaped       = $contents;
$escaped =~ s/\\/\\\\/go;
$escaped =~ s/'/\\'/go;

return "$meta_function('$invocation', '$escaped');" unless $escaped =~ /\v/;

my $delimiter = '__' . fast_hash($contents);
my $chars     = 2;

++$chars until $chars >= length($delimiter) || index("\n$contents", "\n" . substr($delimiter, 0, $chars)) == -1;
$delimiter = substr($delimiter, 0, $chars);

"$meta_function('$invocation', <<'$delimiter');\n$contents\n$delimiter";
__
meta::function('sh', 'system(@_);');
meta::function('shb', <<'__');
# Backgrounded shell job.
exec(@_) unless fork;

__
meta::function('shell', <<'__');
my ($options, @arguments) = separate_options(@_);
$transient{repl_prefix} = $$options{'--repl-prefix'};

terminal::cc(retrieve('data::current-continuation')) if length $data{'data::current-continuation'};
around_hook('shell', sub {shell::repl(%$options)});

__
meta::function('size', <<'__');
my $size = 0;
$size += length $data{$_} for keys %data;
sprintf "   full logical  unique    self\n% 7d % 7d % 7d % 7d", length(serialize()), $size, length(serialize('-up')), length $global_data;

__
meta::function('snapshot', <<'__');
my ($name) = @_;
file::write(my $finalname = temporary_name($name), serialize(), noclobber => 1);
chmod 0700, $finalname;
hook('snapshot', $finalname);
__
meta::function('state', <<'__');
my @keys = sort keys %data;
my $hash = fast_hash(fast_hash(scalar @keys) . join '|', @keys);
$hash = fast_hash("$data{$_}|$hash") for @keys;
$hash;
__
meta::function('touch', 'associate($_, \'\') for @_;');
meta::function('uncompress', <<'__');
# Compresses one or more attributes.
exists $data{"bzip2::$_"} or die "bzip2::$_ doesn't exist; not uncompressing anything" for @_;
associate($_, uncompress_data(retrieve("bzip2::$_"))), rm("bzip2::$_") for @_;

__
meta::function('unlock', 'hook(\'unlock\', chmod_self(sub {$_[0] | 0200}));');
meta::function('update', <<'__');
update_from(@_, grep s/^parent:://o, sort keys %data);

__
meta::function('update-from', <<'__');
# Upgrade all attributes that aren't customized. Customization is defined when the data type is created,
# and we determine it here by checking for $transient{inherit}{$type}.

# Note that this assumes you trust the remote script. If you don't, then you shouldn't update from it.

around_hook('update-from-invocation', separate_options(@_), sub {
  my ($options, @targets) = @_;
  my %parent_id_cache = cache('parent-identification');
  my %already_seen;

  @targets or return;

  my @known_targets     = grep s/^parent:://, parent_ordering(map "parent::$_", grep exists $data{"parent::$_"}, @targets);
  my @unknown_targets   = grep ! exists $data{"parent::$_"}, @targets;
  @targets = (@known_targets, @unknown_targets);

  my $save_state        = $$options{'-s'} || $$options{'--save'};
  my $no_parents        = $$options{'-P'} || $$options{'--no-parent'} || $$options{'--no-parents'};
  my $force             = $$options{'-f'} || $$options{'--force'};
  my $clobber_divergent = $$options{'-D'} || $$options{'--clobber-divergent'};

  save_state('before-update');

  for my $target (@targets) {
    dangerous("updating from $target", sub {
    around_hook('update-from', $target, sub {
      my $identity = $parent_id_cache{$target} ||= join '', qx($target identity);
      next if $already_seen{$identity};
      $already_seen{$identity} = 1;

      my $attributes = join '', qx($target ls -ahiu);
      my %divergent;
      die "skipping unreachable $target" unless $attributes;

      for my $to_rm (split /\n/, retrieve("parent::$target")) {
        my ($name, $hash) = split(/\s+/, $to_rm);
        next unless exists $data{$name};

        my $local_hash = fast_hash(retrieve($name));
        if ($clobber_divergent or $hash eq $local_hash or ! defined $hash) {rm($name)}
        else {terminal::info("preserving local version of divergent attribute $name (use update -D to clobber it)");
              $divergent{$name} = retrieve($name)}}

      associate("parent::$target", $attributes) unless $no_parents;

      dangerous('', sub {eval qx($target serialize -ipmu)});
      dangerous('', sub {eval qx($target serialize -ipMu)});

      map associate($_, $divergent{$_}), keys %divergent unless $clobber_divergent;

      reload()})})}

  cache('parent-identification', %parent_id_cache);

  if (verify()) {hook('update-from-succeeded', $options, @targets);
                 terminal::info("Successfully updated. Run 'load-state before-update' to undo this change.") if $save_state;
                 rm('state::before-update') unless $save_state}
  elsif ($force) {hook('update-from-failed', $options, @targets);
                  terminal::warning('Failed to verify: at this point your object will not save properly, though backup copies will be created.',
                                    'Run "load-state before-update" to undo the update and return to a working state.')}
  else {hook('update-from-failed', $options, @targets);
        terminal::error('Verification failed after the upgrade was complete.');
        terminal::info("$0 has been reverted to its pre-upgrade state.", "If you want to upgrade and keep the failure state, then run 'update-from $target --force'.");
        load_state('before-update');
        rm('state::before-update')}});

__
meta::function('usage', '"Usage: $0 action [arguments]\\nUnique actions (run \'$0 ls\' to see all actions):" . ls(\'-u\');');
meta::function('verify', <<'__');
file::write(my $other = $transient{temporary_filename} = temporary_name(), my $serialized_data = serialize());
chomp(my $observed = join '', qx|perl '$other' state|);

unlink $other if my $result = $observed eq (my $state = state());
terminal::error("Verification failed; expected $state but got $observed from $other") unless $result;
hook('after-verify', $result, observed => $observed, expected => $state);
$result;
__
meta::hook('after-shell::compress-wpages', <<'__');
compress($_) for grep /^wpage::/, sort keys %data;

__
meta::hook('before-shell::ad', <<'__');
ad('post::|[ws]?page::');

__
meta::hook('before-shell::uncompress-wpages', <<'__');
uncompress($_) for grep s/^bzip2:://, sort keys %data;

__
meta::indicator('cc', 'length ::retrieve(\'data::current-continuation\') ? "\\033[1;36mcc\\033[0;0m" : \'\';');
meta::indicator('locked', 'is_locked() ? "\\033[1;31mlocked\\033[0;0m" : \'\';');
meta::indicator('path', <<'__');
my @highlighted = map join("\033[1;30m|\033[0;0m", split /\|/, $_), @{$transient{path}};
join "\033[1;30m/\033[0;0m", @highlighted;

__
meta::internal_function('around_hook', <<'__');
# around_hook('hookname', @args, sub {
#   stuff;
# });

# Invokes 'before-hookname' on @args before the sub runs, invokes the
# sub on @args, then invokes 'after-hookname' on @args afterwards.
# The after-hook is not invoked if the sub calls 'die' or otherwise
# unwinds the stack.

my $hook = shift @_;
my $f    = pop @_;

hook("before-$hook", @_);
my $result = &$f(@_);
hook("after-$hook", @_);
$result;
__
meta::internal_function('associate', <<'__');
my ($name, $value, %options) = @_;
die "Namespace does not exist" unless exists $datatypes{namespace($name)};
$data{$name} = $value;
execute($name) if $options{execute};
$value;

__
meta::internal_function('attribute', <<'__');
my ($name) = @_;
$name =~ s/^[^:]*:://;
$name;
__
meta::internal_function('attribute_is', <<'__');
my ($a, %options) = @_;
my %inherited     = parent_attributes(grep /^parent::/o, sort keys %data) if grep exists $options{$_}, qw/-u -U -d -D/;
my $criteria      = $options{'--criteria'} || $options{'--namespace'} && "^$options{'--namespace'}::" || '.';

my %tests = ('-u' => sub {! $inherited{$a}},
             '-d' => sub {$inherited{$a} && fast_hash(retrieve($a)) ne $inherited{$a}},
             '-i' => sub {$transient{inherit}{namespace($a)}},
             '-s' => sub {$a =~ /^state::/o},
             '-m' => sub {$a =~ /^meta::/o});

return 0 unless scalar keys %tests == scalar grep ! exists $options{$_}    ||   &{$tests{$_}}(), keys %tests;
return 0 unless scalar keys %tests == scalar grep ! exists $options{uc $_} || ! &{$tests{$_}}(), keys %tests;

$a =~ /$_/ || return 0 for @{$options{'--path'}};
$a =~ /$criteria/;

__
meta::internal_function('cache', <<'__');
my ($name, %pairs) = @_;
if (%pairs) {associate("cache::$name", join "\n", map {$pairs{$_} =~ s/\n//g; "$_ $pairs{$_}"} sort keys %pairs)}
else        {map split(/\s/, $_, 2), split /\n/, retrieve("cache::$name")}
__
meta::internal_function('chmod_self', <<'__');
my ($mode_function)      = @_;
my (undef, undef, $mode) = stat $0;
chmod &$mode_function($mode), $0;
__
meta::internal_function('compress_data', <<'__');
use IO::Compress::Bzip2 qw/bzip2/;
my ($data) = @_;
my $output = '';
bzip2 \$data => \$output;
pack 'u*', $output;

__
meta::internal_function('dangerous', <<'__');
# Wraps a computation that may produce an error.
my ($message, $computation) = @_;
terminal::info($message) if $message;
my @result = eval {&$computation()};
terminal::warning(translate_backtrace($@)), return undef if $@;
wantarray ? @result : $result[0];
__
meta::internal_function('debug_trace', <<'__');
terminal::debug(join ', ', @_);
wantarray ? @_ : $_[0];
__
meta::internal_function('execute', <<'__');
my ($name, %options) = @_;
my $namespace = namespace($name);
eval {&{$datatypes{$namespace}}(attribute($name), retrieve($name))};
warn $@ if $@ && $options{'carp'};

__
meta::internal_function('exported', <<'__');
# Allocates a temporary file containing the concatenation of attributes you specify,
# and returns the filename. The filename will be safe for deletion anytime.
my $filename = temporary_name();
file::write($filename, cat(@_));
$filename;

__
meta::internal_function('extension_for', <<'__');
my $extension = $transient{extension}{namespace($_[0])};
$extension = &$extension($_[0]) if ref $extension eq 'CODE';
$extension || '';
__
meta::internal_function('fast_hash', <<'__');
my ($data)     = @_;
my $piece_size = length($data) >> 3;

my @pieces     = (substr($data, $piece_size * 8) . length($data), map(substr($data, $piece_size * $_, $piece_size), 0 .. 7));
my @hashes     = (fnv_hash($pieces[0]));

push @hashes, fnv_hash($pieces[$_ + 1] . $hashes[$_]) for 0 .. 7;

$hashes[$_] ^= $hashes[$_ + 4] >> 16 | ($hashes[$_ + 4] & 0xffff) << 16 for 0 .. 3;
$hashes[0]  ^= $hashes[8];

sprintf '%08x' x 4, @hashes[0 .. 3];
__
meta::internal_function('file::read', <<'__');
my $name = shift;
open my($handle), "<", $name;
my $result = join "", <$handle>;
close $handle;
$result;
__
meta::internal_function('file::write', <<'__');
use File::Path     'mkpath';
use File::Basename 'dirname';

my ($name, $contents, %options) = @_;
die "Choosing not to overwrite file $name" if $options{noclobber} and -f $name;
mkpath(dirname($name)) if $options{mkpath};

open my($handle), $options{append} ? '>>' : '>', $name or die "Can't open $name for writing";
print $handle $contents;
close $handle;
__
meta::internal_function('fnv_hash', <<'__');
# A rough approximation to the Fowler-No Voll hash. It's been 32-bit vectorized
# for efficiency, which may compromise its effectiveness for short strings.

my ($data) = @_;

my ($fnv_prime, $fnv_offset) = (16777619, 2166136261);
my $hash                     = $fnv_offset;
my $modulus                  = 2 ** 32;

$hash = ($hash ^ ($_ & 0xffff) ^ ($_ >> 16)) * $fnv_prime % $modulus for unpack 'L*', $data . substr($data, -4) x 8;
$hash;
__
meta::internal_function('hypothetically', <<'__');
# Applies a temporary state and returns a serialized representation.
# The original state is restored after this, regardless of whether the
# temporary state was successful.

my %data_backup   = %data;
my ($side_effect) = @_;
my $return_value  = eval {&$side_effect()};
%data = %data_backup;

die $@ if $@;
$return_value;
__
meta::internal_function('internal::main', <<'__');
disable();

$SIG{'INT'} = sub {snapshot(); exit 1};

$transient{initial}      = state();
chomp(my $default_action = retrieve('data::default-action'));

my $function_name = shift(@ARGV) || $default_action || 'usage';
terminal::warning("unknown action: '$function_name'") and $function_name = 'usage' unless $externalized_functions{$function_name};

around_hook('main-function', $function_name, @ARGV, sub {
  dangerous('', sub {
    chomp(my $result = &$function_name(@ARGV));
    print "$result\n" if $result})});

save() unless state() eq $transient{initial};

END {
  enable();
}
__
meta::internal_function('invoke_editor_on', <<'__');
my ($data, %options) = @_;
my $editor    = $options{editor} || $ENV{VISUAL} || $ENV{EDITOR} || die 'Either the $VISUAL or $EDITOR environment variable should be set to a valid editor';
my $options   = $options{options} || $ENV{VISUAL_OPTS} || $ENV{EDITOR_OPTS} || '';
my $attribute = $options{attribute};
$attribute =~ s/\//-/g;
my $filename  = temporary_name() . "-$attribute$options{extension}";

file::write($filename, $data);
system("$editor $options '$filename'");

my $result = file::read($filename);
unlink $filename;
$result;
__
meta::internal_function('is_locked', '!((stat($0))[2] & 0222);');
meta::internal_function('namespace', <<'__');
my ($name) = @_;
$name =~ s/::.*$//;
$name;
__
meta::internal_function('parent_attributes', <<'__');
my $attributes = sub {my ($name, $value) = split /\s+/o, $_; $name => ($value || 1)};
map &$attributes(), split /\n/o, join("\n", retrieve(@_));
__
meta::internal_function('parent_ordering', <<'__');
# Topsorts the parents by dependency chain. The simplest way to do this is to
# transitively compute the number of parents referred to by each parent.

my @parents = @_;
my %all_parents = map {$_ => 1} @parents;

my %parents_of = map {
  my $t = $_;
  my %attributes = parent_attributes($_);
  $t => [grep /^parent::/, keys %attributes]} @parents;

my %parent_count;
my $parent_count;
$parent_count = sub {
  my ($key) = @_;
  return $parent_count{$key} if exists $parent_count{$key};
  my $count = 0;
  $count += $parent_count->($_) + exists $data{$_} for @{$parents_of{$key}};
  $parent_count{$key} = $count};

my %inverses;
push @{$inverses{$parent_count->($_)} ||= []}, $_ for @parents;
grep exists $all_parents{$_}, map @{$inverses{$_}}, sort keys %inverses;
__
meta::internal_function('retrieve', <<'__');
my @results = map defined $data{$_} ? $data{$_} : retrieve_with_hooks($_), @_;
wantarray ? @results : $results[0];

__
meta::internal_function('retrieve_with_hooks', <<'__');
# Uses the hooks defined in $transient{retrievers}, and returns undef if none work.
my ($attribute) = @_;
my $result      = undef;

defined($result = &$_($attribute)) and return $result for map $transient{retrievers}{$_}, sort keys %{$transient{retrievers}};
return undef;
__
meta::internal_function('select_keys', <<'__');
my %options = @_;
grep attribute_is($_, %options), sort keys %data;
__
meta::internal_function('separate_options', <<'__');
# Things with one dash are short-form options, two dashes are long-form.
# Characters after short-form are combined; so -auv4 becomes -a -u -v -4.
# Also finds equivalences; so --foo=bar separates into $$options{'--foo'} eq 'bar'.
# Stops processing at the -- option, and removes it. Everything after that
# is considered to be an 'other' argument.

# The only form not supported by this function is the short-form with argument.
# To pass keyed arguments, you need to use long-form options.

my @parseable;
push @parseable, shift @_ until ! @_ or $_[0] eq '--';

my @singles = grep /^-[^-]/, @parseable;
my @longs   = grep /^--/,    @parseable;
my @others  = grep ! /^-/,   @parseable;

my @singles = map /-(.{2,})/ ? map("-$_", split(//, $1)) : $_, @singles;

my %options;
/^([^=]+)=(.*)$/ and $options{$1} = $2 for @longs;
++$options{$_} for grep ! /=/, @singles, @longs;

({%options}, @others, @_);

__
meta::internal_function('strip', 'wantarray ? map {s/^\\s*|\\s*$//g; $_} @_ : $_[0] =~ /^\\s*(.*?)\\s*$/ && $1;');
meta::internal_function('table_display', <<'__');
# Displays an array of arrays as a table; that is, with alignment. Arrays are
# expected to be in column-major order.

sub maximum_length_in {
  my $maximum = 0;
  length > $maximum and $maximum = length for @_;
  $maximum;
}

my @arrays    = @_;
my @lengths   = map maximum_length_in(@$_), @arrays;
my @row_major = map {my $i = $_; [map $$_[$i], @arrays]} 0 .. $#{$arrays[0]};
my $format    = join '  ', map "%-${_}s", @lengths;

join "\n", map strip(sprintf($format, @$_)), @row_major;
__
meta::internal_function('temporary_name', <<'__');
use File::Temp 'tempfile';
my (undef, $temporary_filename) = tempfile("$0." . 'X' x 4, OPEN => 0);
$temporary_filename;
__
meta::internal_function('translate_backtrace', <<'__');
my ($trace) = @_;
$trace =~ s/\(eval (\d+)\)/$locations{$1 - 1}/g;
$trace;
__
meta::internal_function('uncompress_data', <<'__');
use IO::Uncompress::Bunzip2 qw/bunzip2/;
my ($packed) = @_;
my $data   = join '', unpack 'u*', $packed;
my $output = '';
bunzip2 \$data => \$output;
$output;

__
meta::internal_function('with_exported', <<'__');
# Like exported(), but removes the file after running some function.
# Usage is with_exported(@files, sub {...});
my $f      = pop @_;
my $name   = exported(@_);
my $result = eval {&$f($name)};
terminal::warning("$@ when running with_exported()") if $@;
unlink $name;
$result;
__
meta::library('shell', <<'__');
# Functions for shell parsing and execution.
package shell;
use Term::ReadLine;

sub tokenize {grep length, split /\s+|("[^"\\]*(?:\\.)?")/o, join ' ', @_};

sub parse {
  my ($fn, @args) = @_;
  s/^"(.*)"$/\1/o, s/\\\\"/"/go for @args;
  {function => $fn, args => [@args]}}

sub execute {
  my %command = %{$_[0]};
  die "undefined command: $command{function}" unless exists $externalized_functions{$command{function}};
  &{"::$command{function}"}(@{$command{args}})}

sub run {execute(parse(tokenize(@_)))}

sub prompt {
  my %options = @_;
  my $name    = $options{name} // ::name();

  my $indicators = join '', map &{"::$_"}(), ::select_keys('--namespace' => 'indicator');
  my $prefix     = $transient{repl_prefix} // '';

  "$prefix\033[1;32m$name\033[0;0m$indicators "}

sub repl {
  my %options = @_;

  my $term = new Term::ReadLine "$0 shell";
  $term->ornaments(0);
  my $attribs = $term->Attribs;
  $attribs->{completion_entry_function} = $attribs->{list_completion_function};

  my $autocomplete = $options{autocomplete} || sub {[sort(keys %data), grep !/-/, sort keys %externalized_functions]};
  my $prompt       = $options{prompt}       || \&prompt;
  my $parse        = $options{parse}        || sub {parse(tokenize(@_))};
  my $output       = $options{output}       || sub {print join("\n", @_), "\n"};
  my $command      = $options{command}      || sub {my ($command) = @_; ::around_hook('shell-command', $command, sub {&$output(::dangerous('', sub {execute($command)}))})};

  length $_ && &$command(&$parse($_)) while ($attribs->{completion_word} = &$autocomplete(), defined($_ = $term->readline(&$prompt())))}

__
meta::library('terminal', <<'__');
# Functions for nice-looking terminal output.
package terminal;

my $process = ::name();

sub message {print STDERR "[$_[0]] $_[1]\n"}
sub color {
  my ($name, $color) = @_;
  *{"terminal::$name"} = sub {chomp($_), print STDERR "\033[1;30m$process(\033[1;${color}m$name\033[1;30m)\033[0;0m $_\n" for map join('', $_), @_}}

my %preloaded = (info => 32, progress => 32, state => 34, debug => 34, warning => 33, error => 31);
color $_, $preloaded{$_} for keys %preloaded;
__
meta::message_color('cc', '36');
meta::message_color('state', 'purple');
meta::message_color('states', 'yellow');
meta::page('index', <<'__');
- include pp::posts.html

__
meta::parent('/home/spencertipping/bin/object', <<'__');
bootstrap::html                         f44dd03cb0c904b3a5f69fbda5f018d0
bootstrap::initialization               d22fafa2938ecb0d4728e2958b54ed3d
bootstrap::perldoc                      5793df44bdd2526bb461272924abfd4b
function::ad                            9220b9dc131f8f79878a6209adfe8ef2
function::alias                         8eeeeb4e064ef3aba7edf8f254427bc2
function::cat                           f684de6c8776617a437b76009114f52e
function::cc                            12ea9176e388400704d823433c209b7a
function::ccc                           d151a9793edd83f80fb880b7f0ab9b34
function::child                         f5764adf0b4e892f147a9b6b68d4816f
function::clone                         bb42e04e10a8e54e88786b6fbc4fb213
function::cp                            3fe69d1b58d90045ad520048977538c4
function::create                        3010d55f4dfa59a998742e07823ed54d
function::current-state                 6f03f86f1901e9ef07fdb5d4079a914c
function::cwd                           fd9b58e76c474a8fe93dc3abdccb8857
function::disable                       53b449708cc2ffdefa352e53bb7d847d
function::edit                          ac12f5f65211caf9b14ab1054004c8bc
function::edit-self                     71790df00f941ed9b56e17f789b93871
function::enable                        7de1cedc36841f5de8f9fdfbc3b65097
function::export                        2374cd1dbf7616cb38cafba4e171075d
function::extern                        1290a5223e2824763eecfb3a54961eff
function::grep                          55c3cea8ff4ec2403be2a9d948e59f14
function::hash                          6ee131d093e95b80039b4df9c7c84a02
function::hook                          675cdb98b5dd8567bdd5a02ead6184b5
function::hooks                         3d989899c616f7440429a2d9bf1cc44b
function::identity                      6523885762fcc2f354fc25cf6ed126ce
function::import                        5d0f0634cbd01274f2237717507198a2
function::initial-state                 03d8ed608855a723124e79ca184d8e73
function::is                            41564c8f21b12ab80824ac825266d805
function::load-state                    b6cf278a1f351f316fa6e070359b6081
function::lock                          5d8db258704e6a8623fac796f62fac02
function::ls                            01a23d51d5b529e03943bd57e33f92df
function::mv                            ccd000960db4cf627d9246c43d87ba4c
function::name                          955ba2d1fe1d67cd78651a4042283b00
function::parents                       3da9e63b5aae9e2f5dcc946a86d166aa
function::perl                          9f9fd744f0ed225ad8fb3b79fa53dd9a
function::rd                            2adb16d7e819d2e87a27201744a581e7
function::reload                        1589f4cf8374e0011991cb8907afca3e
function::rm                            6f6fd7a6c25558eb469d78ea888f8551
function::rmparent                      fc2884910a6939a47898a778f277332c
function::save                          3cbe5c3735ee4ff99cb60ccf68bc8b91
function::save-state                    5af59ebc4ad8965767e4dc106d3b557e
function::serialize                     a97c7391c635a93b0a710d10eb8cb3cd
function::serialize-single              8bac97e94a1162947d274421053387b0
function::sh                            1b2f542ca9dd63ad437058b7f6f61aac
function::shb                           21139548efb79500d9c999dba024ab32
function::shell                         a87f389b94713e5855e62241d649d01d
function::size                          69f6ab4a100c6ef05d4d41510004d645
function::snapshot                      56939a47f2758421669641e15ebd66eb
function::state                         88bc24e732c55aac68a103eab96b9e48
function::touch                         3991b1b7c7187566f50e5e58ce01fa06
function::unlock                        b4aac02f7f3fb700acf4acfd9b180ceb
function::update                        ac391dc90e507e7586c81850e7c2ecdd
function::update-from                   06fef658374d482adb2e62fbeed9efb4
function::usage                         5bdd370f5a56cfbf199e08d398091444
function::verify                        0c0cc1dfeab7d705919df122f7850a4f
indicator::cc                           3db7509c521ee6abfedd33d5f0148ed3
indicator::locked                       fc2b4f4ca0d6a334b9ac423d06c8f18c
indicator::path                         b5e2cb524caa0283f713a0ddf9f4c162
internal_function::around_hook          7cc876e7c5f78c34654337fc95255587
internal_function::associate            55f202ffdbc6b9005e53d3e82f5f9bfe
internal_function::attribute            dd6f010f9688977464783f60f5b6d3dd
internal_function::attribute_is         d28ac825b3937029386372c560a65775
internal_function::cache                eb9da45580a9ac0882baf98acd2ecd60
internal_function::chmod_self           2035e861eedab55ba0a9f6f5a068ca70
internal_function::dangerous            46c4baaa214ab3d05af43e28083d5141
internal_function::debug_trace          0faf9d9f4159d72dfe4481f6f3607ce1
internal_function::execute              f0924e087d978ff2ab1e117124db3042
internal_function::exported             ae35afef7d4762f2818aee5872c75be0
internal_function::extension_for        9de8261d69cc93e9b92072b89c89befd
internal_function::fast_hash            ee5eba48f837fda0fe472645fdd8899a
internal_function::file::read           e647752332c8e05e81646a3ff98f9a8e
internal_function::file::write          460e2343283eb9fd0e1815389f4e07e6
internal_function::fnv_hash             c36d56f1e13a60ae427afc43ba025afc
internal_function::hypothetically       b83e3f894a6df8623ccd370515dfd976
internal_function::internal::main       12c18f86d766ffb67b8dc0572985bf98
internal_function::invoke_editor_on     5eb976796f0ec172d6ec036116a2f41e
internal_function::is_locked            da12ced6aa38295251f7e748ffd22925
internal_function::namespace            784d2e96003550681a4ae02b8d6d0a27
internal_function::parent_attributes    f6ccfaa982ab1a4d066043981aaca277
internal_function::parent_ordering      57b6da88f76b59f3fed9abfa61280e5e
internal_function::retrieve             721a6800f328da05047fd7392758f55d
internal_function::retrieve_with_hooks  0f1b0220ccd973d57a2e96ff00458cf2
internal_function::select_keys          a5e3532ec6d58151d0ee24416ea1e2b5
internal_function::separate_options     34ec41a6edaa15adde607a0db3ccfa36
internal_function::strip                14f490b10ebd519e829d8ae20ea4d536
internal_function::table_display        d575f4dc873b2e0be5bd7352047fd904
internal_function::temporary_name       6f548d101fc68356515ffd0fc9ae0c93
internal_function::translate_backtrace  d77a56d608473b3cd8a3c6cb84185e10
internal_function::with_cwd             928bae9caa3cb212f0c5c977ba55166c
internal_function::with_exported        df345d5095d5ed13328ddd07ea922b36
internal_function::with_fork            b252464d1efd12dc4a5ee6890076b6a9
library::process                        9fe4e2320eae9f6661a6eb6e777fb6ca
library::shell                          f561500cf223df1bf6daf43af93577a5
library::terminal                       7e2d045782405934a9614fe04bcfe559
message_color::cc                       2218ef0f7425de5c717762ffb100eb43
message_color::state                    03621cd6ac0b1a40d703f41e26c5807f
message_color::states                   ac66eeeff487b5f43f88a78ea18b3d56
meta::configure                         69c2e727c124521d074fde21f8bbc4db
meta::externalize                       aa44e27e0bbee6f0ca4de25d603a1fc7
meta::functor::editable                 48246c608f363de66511400e00b26164
meta::type::alias                       889d26d2df385e9ff8e2da7de4e48374
meta::type::bootstrap                   51108ab2ddb8d966e927c8f62d9ef3e5
meta::type::cache                       9267171f2eace476f64a1a670eaaf2c7
meta::type::data                        120e1649a468d3b3fd3fb783b4168499
meta::type::function                    8ea626198861dc59dd7f303eecb5ff88
meta::type::hook                        ff92aef328b6bdc6f87ddd0821f3e42f
meta::type::inc                         78e0375b6725487cb1f0deca41e96bbe
meta::type::indicator                   feb54a2624e6983617685047c717427f
meta::type::internal_function           eff3cf31e2635f51c83836f116c99d2f
meta::type::library                     7622e8d65e03066668bade74715d65ad
meta::type::message_color               557a1b44979cbf77a7251fbdc4c5b82c
meta::type::meta                        c6250056816b58a9608dd1b2614246f8
meta::type::parent                      09d1d03379e4e0b262e06939f4e00464
meta::type::retriever                   71a29050bf9f20f6c71afddff83addc9
meta::type::state                       84da7d5220471307f1f990c5057d3319
retriever::file                         3bbc9d8a887a536044bafff1d54def7e
retriever::global                       4fe8df0cca548075169968772843a156
retriever::id                           4da6080168d32445150cc4200af7af6e
retriever::object                       c7633990b4e01bdc783da7e545799f4f
retriever::perl                         f41938e6dbad317f62abffc1e4d28cca

__
meta::parent('/home/spencertipping/bin/preprocessor', <<'__');
function::preprocess           ab5526a02ff417d4c162357dc327e7c4
meta::type::template           bc4b0c80b5efc716b19e99b832c22bf3
parent::object                 5e8c5be71d2d512cca8dfc1677f94466
retriever::pp                  3b5f5c5d30c5a04f72056dedaacfe7b7
template::comment              dfe273d2dad3d8159b847545e4e5c309
template::eval                 1a0e2124a05056be4abc11803883c294
template::failing_conditional  e3a4523110dd859e828f342185de7c62
template::include              47b5552d609d97fe7f2522d5c1027014
template::pinclude             c07ff79bf8d642cceaa9ef844bfcb189

__
meta::parent('/home/spencertipping/conjectures/perl-objects/sdoc', <<'__');
function::sdoc                           b2f9066417ce3368f093796e1180e9b2
function::sdoc-html                      b23152b3f5be696e5bae842ec43fc5a4
function::sdoc-markdown                  a35a6441dd750466f2d0e636bee2b382
function::sdocp                          c3d738d982ba87418a298ff58478a85b
meta::type::sdoc                         22cd7315641d38c9d536344e83c36bed
meta::type::slibrary                     95474943c4a5f8ff17d3cf66ddb7c386
parent::/home/spencertipping/bin/object  5e8c5be71d2d512cca8dfc1677f94466
retriever::code-sdoc                     03b87ff8d1ecf7594db9ca0669fc69a1
retriever::html-sdoc                     8ab7705d03276945b23a71677153233c
retriever::markdown-sdoc                 67c34ba8223ec36a3ae018e411354db2
retriever::sdoc                          662061e9e41491e2a1debd6862ccf1e7
retriever::sdocp                         330694ea14a23bb04b65c761075cd946

__
meta::parent('compressed', <<'__');
function::compress                       70408dde290c164219dadd70f3f40524
function::uncompress                     5f7d0f3274d0fe0652ccdfa0059049fa
internal_function::compress_data         e94cf515212be7e5d01d482baaf684fb
internal_function::uncompress_data       4ffa231fa6a6eaaed192c5f0bfdfa821
meta::type::bzip2                        d0ec4034cc6e078d6968b0394330fed1
parent::/home/spencertipping/bin/object  95fa6ef5120e9a213ad9781a31d69584
retriever::bunzip2                       e218e119a85eca5752d9064b14ed50c3
retriever::bzip2                         a60b49e7dcd79f466f2137eafd761630

__
meta::parent('html', <<'__');
meta::functor::html-templates            2771200f87e9cbfeecfb5f8a0f796f18
parent::/home/spencertipping/bin/object  5e8c5be71d2d512cca8dfc1677f94466
parent::preprocessor                     803d46480e579c764e7704149fecd7cc
template::script-include                 76be051ad116449ddebd10e7c3729afd
template::style-include                  8e5a06b70e1b00379765f319bf6c8066

__
meta::parent('object', <<'__');
bootstrap::html                         f44dd03cb0c904b3a5f69fbda5f018d0
bootstrap::initialization               d22fafa2938ecb0d4728e2958b54ed3d
bootstrap::perldoc                      5793df44bdd2526bb461272924abfd4b
function::ad                            77a05d9a6fef7871b2c3e8e94b56870a
function::alias                         8eeeeb4e064ef3aba7edf8f254427bc2
function::cat                           f684de6c8776617a437b76009114f52e
function::cc                            12ea9176e388400704d823433c209b7a
function::ccc                           d151a9793edd83f80fb880b7f0ab9b34
function::child                         f5764adf0b4e892f147a9b6b68d4816f
function::clone                         bb42e04e10a8e54e88786b6fbc4fb213
function::cp                            3fe69d1b58d90045ad520048977538c4
function::create                        3010d55f4dfa59a998742e07823ed54d
function::current-state                 6f03f86f1901e9ef07fdb5d4079a914c
function::disable                       53b449708cc2ffdefa352e53bb7d847d
function::edit                          beae8b1d7292e2ce2913199ff32f2501
function::edit-self                     71790df00f941ed9b56e17f789b93871
function::enable                        7de1cedc36841f5de8f9fdfbc3b65097
function::export                        2374cd1dbf7616cb38cafba4e171075d
function::extern                        1290a5223e2824763eecfb3a54961eff
function::grep                          55c3cea8ff4ec2403be2a9d948e59f14
function::hash                          6ee131d093e95b80039b4df9c7c84a02
function::hook                          675cdb98b5dd8567bdd5a02ead6184b5
function::hooks                         3d989899c616f7440429a2d9bf1cc44b
function::identity                      6523885762fcc2f354fc25cf6ed126ce
function::import                        5d0f0634cbd01274f2237717507198a2
function::initial-state                 03d8ed608855a723124e79ca184d8e73
function::is                            41564c8f21b12ab80824ac825266d805
function::load-state                    b6cf278a1f351f316fa6e070359b6081
function::lock                          5d8db258704e6a8623fac796f62fac02
function::ls                            01a23d51d5b529e03943bd57e33f92df
function::mv                            ccd000960db4cf627d9246c43d87ba4c
function::name                          955ba2d1fe1d67cd78651a4042283b00
function::parents                       3da9e63b5aae9e2f5dcc946a86d166aa
function::perl                          9f9fd744f0ed225ad8fb3b79fa53dd9a
function::rd                            2adb16d7e819d2e87a27201744a581e7
function::reload                        1589f4cf8374e0011991cb8907afca3e
function::rm                            6f6fd7a6c25558eb469d78ea888f8551
function::rmparent                      fc2884910a6939a47898a778f277332c
function::save                          778c0e1043b9c6c96fb8f266f8061624
function::save-state                    5af59ebc4ad8965767e4dc106d3b557e
function::serialize                     a97c7391c635a93b0a710d10eb8cb3cd
function::serialize-single              aa77af032272f5a2664e21713739a223
function::sh                            1b2f542ca9dd63ad437058b7f6f61aac
function::shb                           7b2685a4041c25bc495816e472bdace5
function::shell                         a87f389b94713e5855e62241d649d01d
function::size                          69f6ab4a100c6ef05d4d41510004d645
function::snapshot                      56939a47f2758421669641e15ebd66eb
function::state                         8c68044dccae28f33244d0c7e9e9acfb
function::touch                         3991b1b7c7187566f50e5e58ce01fa06
function::unlock                        b4aac02f7f3fb700acf4acfd9b180ceb
function::update                        ac391dc90e507e7586c81850e7c2ecdd
function::update-from                   06fef658374d482adb2e62fbeed9efb4
function::usage                         5bdd370f5a56cfbf199e08d398091444
function::verify                        0c0cc1dfeab7d705919df122f7850a4f
indicator::cc                           3db7509c521ee6abfedd33d5f0148ed3
indicator::locked                       fc2b4f4ca0d6a334b9ac423d06c8f18c
indicator::path                         b5e2cb524caa0283f713a0ddf9f4c162
internal_function::around_hook          7cc876e7c5f78c34654337fc95255587
internal_function::associate            55f202ffdbc6b9005e53d3e82f5f9bfe
internal_function::attribute            dd6f010f9688977464783f60f5b6d3dd
internal_function::attribute_is         40bda8226322505e323ea6d405388f08
internal_function::cache                eb9da45580a9ac0882baf98acd2ecd60
internal_function::chmod_self           2035e861eedab55ba0a9f6f5a068ca70
internal_function::dangerous            46c4baaa214ab3d05af43e28083d5141
internal_function::debug_trace          0faf9d9f4159d72dfe4481f6f3607ce1
internal_function::execute              f0924e087d978ff2ab1e117124db3042
internal_function::exported             ae35afef7d4762f2818aee5872c75be0
internal_function::extension_for        9de8261d69cc93e9b92072b89c89befd
internal_function::fast_hash            ee5eba48f837fda0fe472645fdd8899a
internal_function::file::read           e647752332c8e05e81646a3ff98f9a8e
internal_function::file::write          3e290fdcb353c6f842eb5a40f2e575f8
internal_function::fnv_hash             c36d56f1e13a60ae427afc43ba025afc
internal_function::hypothetically       b83e3f894a6df8623ccd370515dfd976
internal_function::internal::main       f31f2945a19a668d92505f114ab29c78
internal_function::invoke_editor_on     5eb976796f0ec172d6ec036116a2f41e
internal_function::is_locked            da12ced6aa38295251f7e748ffd22925
internal_function::namespace            784d2e96003550681a4ae02b8d6d0a27
internal_function::parent_attributes    f6ccfaa982ab1a4d066043981aaca277
internal_function::parent_ordering      57b6da88f76b59f3fed9abfa61280e5e
internal_function::retrieve             721a6800f328da05047fd7392758f55d
internal_function::retrieve_with_hooks  0f1b0220ccd973d57a2e96ff00458cf2
internal_function::select_keys          a5e3532ec6d58151d0ee24416ea1e2b5
internal_function::separate_options     34ec41a6edaa15adde607a0db3ccfa36
internal_function::strip                14f490b10ebd519e829d8ae20ea4d536
internal_function::table_display        d575f4dc873b2e0be5bd7352047fd904
internal_function::temporary_name       6f548d101fc68356515ffd0fc9ae0c93
internal_function::translate_backtrace  d77a56d608473b3cd8a3c6cb84185e10
internal_function::with_exported        df345d5095d5ed13328ddd07ea922b36
library::shell                          f561500cf223df1bf6daf43af93577a5
library::terminal                       7e2d045782405934a9614fe04bcfe559
message_color::cc                       2218ef0f7425de5c717762ffb100eb43
message_color::state                    03621cd6ac0b1a40d703f41e26c5807f
message_color::states                   ac66eeeff487b5f43f88a78ea18b3d56
meta::configure                         69c2e727c124521d074fde21f8bbc4db
meta::externalize                       aa44e27e0bbee6f0ca4de25d603a1fc7
meta::functor::editable                 48246c608f363de66511400e00b26164
meta::type::alias                       889d26d2df385e9ff8e2da7de4e48374
meta::type::bootstrap                   51108ab2ddb8d966e927c8f62d9ef3e5
meta::type::cache                       9267171f2eace476f64a1a670eaaf2c7
meta::type::data                        120e1649a468d3b3fd3fb783b4168499
meta::type::function                    8ea626198861dc59dd7f303eecb5ff88
meta::type::hook                        ff92aef328b6bdc6f87ddd0821f3e42f
meta::type::inc                         78e0375b6725487cb1f0deca41e96bbe
meta::type::indicator                   feb54a2624e6983617685047c717427f
meta::type::internal_function           eff3cf31e2635f51c83836f116c99d2f
meta::type::library                     7622e8d65e03066668bade74715d65ad
meta::type::message_color               557a1b44979cbf77a7251fbdc4c5b82c
meta::type::meta                        c6250056816b58a9608dd1b2614246f8
meta::type::parent                      09d1d03379e4e0b262e06939f4e00464
meta::type::retriever                   71a29050bf9f20f6c71afddff83addc9
meta::type::state                       84da7d5220471307f1f990c5057d3319
retriever::file                         3bbc9d8a887a536044bafff1d54def7e
retriever::global                       4fe8df0cca548075169968772843a156
retriever::id                           4da6080168d32445150cc4200af7af6e
retriever::object                       c7633990b4e01bdc783da7e545799f4f
retriever::perl                         f41938e6dbad317f62abffc1e4d28cca

__
meta::parent('preprocessor', <<'__');
function::preprocess           ab5526a02ff417d4c162357dc327e7c4
meta::type::template           bc4b0c80b5efc716b19e99b832c22bf3
parent::object                 5e8c5be71d2d512cca8dfc1677f94466
retriever::pp                  3b5f5c5d30c5a04f72056dedaacfe7b7
template::comment              dfe273d2dad3d8159b847545e4e5c309
template::eval                 1a0e2124a05056be4abc11803883c294
template::failing_conditional  e3a4523110dd859e828f342185de7c62
template::include              47b5552d609d97fe7f2522d5c1027014
template::pinclude             c07ff79bf8d642cceaa9ef844bfcb189

__
meta::post('2012.0205.great-abstractions', <<'__');
Great abstractions.
jQuery didn't take long to become the dominant Javascript library, and it's easy to see why. For someone who already knows DOM programming, it's trivial to learn and provides great ways to get
stuff done with less work. jQuery also managed to achieve a kind of minimalism; you can't remove much without changing something fundamental. And for many purposes, it has replaced the DOM.

Another platform like this is the C programming language. It allows you to write assembly-level code far faster than you could in assembly, and it conveniently obscures the details of
architecture/platform-specific instructions and ABIs. The vast majority of C programmers feel no need to look underneath the hood of GCC, the linker, the calling conventions, the standard C
library, or any number of other complex pieces of C's infrastructure.

Each of these abstractions has an interesting property: people who use them rarely find the need to work around them. Put differently, these abstractions don't leak. Most abstractions, of
course, aren't like this. For instance, X11 implementations use direct-memory rendering for local connections to provide hardware acceleration. All of the rendering could be done over its
network protocol, but it would be dog-slow and nobody would use it.

  Good abstractions vanish.
  CPU-bound programs written in Perl or Ruby usually take much longer to run than the same programs written in C. As such, there's a case to be made against, for example, writing ray-tracers
  or programming language interpreters in Perl. C, on the other hand, is not appreciably slower than assembly language for the vast majority of tasks. For most purposes, you'd never know the
  result wasn't written in assembly to begin with, except that C is so cool that nobody would do that. (Actually, this isn't true. C imposes a lot of structure on the resulting assembly that
  makes it easy to detect. But none of this structure impedes the program's functionality/performance very much.)

  Like C, jQuery also doesn't add much overhead. Last time I <a href='http://spencertipping.com/js-instabench'>measured it</a>, the cost of creating a Javascript object is 1%
  of the cost of creating an HTML element; although jQuery isn't erased per se, it is such a thin layer, and it's so aggressively optimized, that jQuery itself is rarely the cause of
  performance problems.

  Here's where things get slightly counterintuitive: both jQuery and C will generally result in a net performance <em>increase</em> despite each creating some overhead over the perfect
  hand-coded solution. Not only do the abstractions vanish, but they result in a faster end product. And we use these libraries because low performance is one of the most harmful side-effects
  that an application can have.

  Put differently, asking the question, <em>is using this abstraction making my application slow</em> is just as problematic as asking, <em>is my app failing because this abstraction has a
  bug</em>.

  Good abstractions are culturally accessible.
  jQuery uses CSS syntax to select things, and while it did invent (as far as I know) its own accessor/mutator convention, this was so unsurprising and easy to use that things like Java's
  getter/setter pattern looked clunky and outdated by comparison. C allowed programmers to keep doing the kinds of cool stuff you could do in assembly (pointer typecasting, computed jumps),
  but made it easier and less error-prone to write programs with consistent structure.

  Also, and just as importantly, jQuery didn't present some grand unified replacement for the DOM. Instead, it leveraged one of the DOM's core properties (the structured node hierarchy) and
  made it accessible in a reliable, cross-browser way. C didn't try to manage memory, create a new paradigm, or ignore the fact that you're ultimately writing machine language. Instead, it
  embraced these things and made them work consistently across every major platform (at least as far as the end-programmer is concerned).

  The last, and perhaps most important, component of accessibility is ergonomics. C is much terser than assembly language for common use cases, just as jQuery is often much terser than direct
  DOM programming.

  C and jQuery aren't the only libraries that have great ergonomics, of course. The UNIX filesystem and shell are also so useful that there isn't a decisively better alternative. Ditto for
  text editors as IDE components, despite how non-textual most programs are. Whatever design flaws these systems have, their ease of use is so compelling that we don't want to switch away.

  Great abstractions withstand adaptation.
  Adaptation comes in two ways. One is when the abstraction author changes something, often breaking code that uses the abstraction. This happened with Ruby; 1.9.x isn't backwards-compatible
  with 1.8.x, yielding workarounds like the RVM. Perl and Javascript are examples of the opposite; they have preserved horrible design flaws throughout their evolution so that old programs
  would keep working without modification.

  The other, and more interesting, form of adaptation is when people start misusing something. A great example of this is the C++ template system, which was probably in no way designed with
  the idea that people would be using it for general-purpose metaprogramming. The fact that this misuse is so reliable that it has become commonplace is a significant compliment to C++
  templates. They have held up to unforeseen use where a lesser system would have broken down. The Web is perhaps the greatest example of misuse; what started as a simple linked document
  management system has ended up nearly replacing desktop applications.

__
meta::post('2012.0207.occams-razor', <<'__');
Occam's Razor.
In real life, true facts are often both counterintuitive and simplifying. Finding out that the earth is round is a significant mental leap considering that it looks flat from every angle. But
it simplifies our perception of deeper questions like gravity, and it explains how airplanes can keep going west and end up where they started.

The same is true of great platforms and frameworks. Rather than obscuring things or creating noise, they use a less-than-obvious presentation of something that ends up making your world a
simpler place.

__
meta::post('2012.0209.not-invented-here', <<'__');
Not invented here.
I have a terrible case of NIH. This means I reimplement stuff that other people have written because I think I can do a better job (or based on other shaky reasoning). It does end somewhere; I
haven't yet written an operating system, browser, terminal emulator, machine-code compiler, or even a replacement for jQuery. But I have written a couple of programming languages, data
structure implementations, serialization formats, and other stuff that I could have gotten for free with open-source software.

Strangely enough, I'm not sure I want to outgrow this bad habit just yet. I've learned a lot by reinventing the wheel. It's also been productive in some cases; when I find a problem in my
stack I can fix it quickly and move on.

__
meta::post('2012.0215.software-reliability', <<'__');
Software reliability.
When I was working for startups, it seemed like something was always burning down. The database would spontaneously become read-only, the middleware would sponataneously fail, or something
similarly catastrophic, and everyone would be in red-alert mode to try to fix the problem. It isn't hard to see why, either: we used brand-new technologies that weren't mature.

Big companies don't seem to do it this way, and it isn't hard to see why. They can't afford the risk. (Using immature technologies is a huge risk, by the way; when we used Tokyo Tyrant, for
example, it would have started silently losing our data after we put more than 40GB into it.) Startups are lured into making risky choices by the promise of more rapid software development.

At the same time, though, I wonder how many startups fail because they jumped the gun and tried to be more technologically savvy (in the use-what's-cool way) than their competitors, only to
end up with a technology Jenga tower that collapsed at some crucial moment (or worse, a development team whose performance was crippled by fighting fires). The ideal risk isn't blind, it's
calculated.

__
meta::post('2012.0217.syntax-as-a-constraint', <<'__');
Syntax as a constraint.
Someone at some point said something like "constraints breed creativity." It's an interesting thing to say considering that constraints also limit your options. But sometimes the burden of
choice is much more significant than the flexibility it provides.

I'm running into this with <a href='http://github.com/spencertipping/mulholland'>Mulholland</a> and its very complex operator precedence model. The language doesn't present
enough of an opinion to guide library design, and as a result I'm not sure what to do with it. <a href='http://caterwauljs.org'>Caterwaul</a> didn't have this problem because
working inside Javascript's syntax was very limiting; there was rarely more than one way to do something. And it's one of the most useful (to me) things I've written. The necessary compromises
haven't held it back much at all.

Put differently, syntax should be friendly both to library designers and to library users. Users, obviously, should be able to write what they mean and have that translated into something
useful. But more subtly, designers should have a set of constructive constraints so they aren't making decisions in a vacuum.

__
meta::post('2012.0222.perfection-is-irrecoverable', <<'__');
Perfection is irrecoverable.
Haskell emulates something close to perfection on an imperfect platform. Rather than embracing the platform's idiosyncrasies and imperfections, it attempts to create a world where they don't
exist. C, on the other hand, doesn't hide the fact that the platform is imperfect. It simply refines the world into a less imperfect one if you're writing normal assembly code.

In general, I don't think it's possible to cover up significant amounts of imperfection. It's possible to use the Church encoding for numbers, for instance, but we don't do it because the cost
of introducing this abstraction is far too expensive. I would argue, too, that it's unnecessary. Purity is beautiful, but we're better off asymptotically approaching it than we are living in a
world where it's the only option.

__
meta::post('2012.0222.the-wrong-tool', <<'__');
The wrong tool.
As a programmer who likes functional paradigms, I have a hard time accepting the fact that Java is so popular. But it is, and so much so that it's noteworthy. Great software is built in Java,
C++, C, and other very non-functional languages with tons of mutable state and edge-triggering. (For example, my OS, window manager, editor, terminal emulator, and browser are all written in
one of these languages.)

I think there are some interesting dynamics behind Java's popularity and empirical success (and Haskell's empirical non-success, despite being signficantly more academically meritorious). What
is it that Java has that Haskell doesn't? My best guess is that Haskell gives you the ability to create tools easily; this is the default way of developing. So in order to make progress, you
are continuously defining abstractions. Put differently, you have the freedom, and the burden, of choosing your tools.

Java is simple. It gives you one mediocre abstraction that leads to slow, complex, bug-ridden software. Its model of objects is, in my opinion, the wrong tool for any job. However, and this is
the genius of it, you don't have to think about your toolset. You just write stuff using the wrong tool, and slowly but surely you make progress without solving unnecessary problems.

Another way to look at it is that this is a reflection of the software process as a whole: Most failures occur in the requirements phase, not design or implementation. By making programmers
think about their own requirements during the development phase, languages like Haskell create another point of failure. What interests me particularly is that this point of failure is
evidently so large that the average corporate programmer (even at Google!) is better off using the wrong tools than they are taking a shot at inventing their own. Maybe the true measure of a
programmer's usefulness is not their ability to write software, but their ability to know what needs to be written.

__
meta::post('2012.0226.indirect-jumps-in-gnu-assembler', <<'__');
Indirect jumps in GNU assembler.
I'm not great at assembly-level programming, but I've been getting into it recently to implement a new programming language that I'll probably never finish. While working on it, I decided to
use some <a href='http://en.wikipedia.org/wiki/Continuation_passing_style'>continuation-passing style</a> patterns to minimize the amount of stack manipulation that would need
to happen. So I started out with some code like this:

| movq continuation, %r12
  jmp f
  ...
  f:
  ...
  jmp *%r12
  ...
  continuation:

If you're familiar with AT&T assembler syntax, you probably won't be surprised to hear that this segfaulted and <code>gdb</code> showed <code>%r12</code> as having a value way outside of the
program's code space. After a lot of reading online, it turns out that you need to do it this way:

| movq $continuation, %r12

Linguistically, this makes sense: you're <code>jmp</code>ing to the code itself (which is similar to a dereference), but you're talking about the code's address when you put the value into a
register.

__
meta::post('2012.0229.performance-as-a-side-effect', <<'__');
Performance as a side effect.
Someone on Twitter posed a good question recently: "What is state?" (that is, statefulness vs statelessness in code). I thought about that for a while. It's a difficult thing to pin down
because you could argue that any stored data is really state. My answer was that state is an implicit dependency on time.

If it's true, this answer has some strange ramifications. For example, performance is another variable that involves time. And I would argue that something with unpredictable performance is,
in production scenarios, as dangerous as something that randomly emits side-effects. On the aggregate, it wouldn't surprise me if Java and C++ were actually the two languages with the highest
level of abstraction for the generally low total time dependency.

__
meta::post('2012.0302.a-caterwaul-bug', <<'__');
A Caterwaul bug.
Not all bugs are created equal. They range from the stupidly obvious mistakes of late-night coding to the intriguingly subtle nonlocal consequences of reasonable design decisions. In my
experience, most bugs tend towards the obvious side of this scale. But sometimes I run into a legendary bit of pathology that is so convoluted or mysterious that it qualifies as a work of art.
Yesterday I was fortunate enough to encounter one of these in Caterwaul.

I was a little worried about it because I had seen it happen at least once before and had no idea why. The symptom was that, for some input programs that made heavy use of syntax quotation,
<code>waul</code> would die with output similar to the following:

| node.js:201
        throw e; // process.nextTick error, or 'error' event on first tick
              ^
  TypeError: Object , has no method 'reach'
      at eval at <anonymous> (waul-1.2:140:119)
      at [object Object].each (eval at <anonymous> (waul-1.2:140:119))
      at [object Object].reach (eval at <anonymous> (waul-1.2:140:119))
      at eval at <anonymous> (waul-1.2:140:119)
      at [object Object].each (eval at <anonymous> (waul-1.2:140:119))
      at [object Object].reach (eval at <anonymous> (waul-1.2:140:119))
      at eval at <anonymous> (waul-1.2:140:119)
      at [object Object].each (eval at <anonymous> (waul-1.2:140:119))
      at [object Object].reach (eval at <anonymous> (waul-1.2:140:119))
      at eval at <anonymous> (waul-1.2:140:119)

One of the problems with writing your own programming language is that you also have to write your own debugger. Right now Caterwaul has no debugger, so figuring out why this was happening was
a real challenge. Fortunately, I had a hunch: I suspected that I was building a syntax tree with a string child instead of a syntax tree child. Caterwaul lets you use either as a convenience,
but the <code>push()</code> method of syntax trees doesn't do that conversion. So I refactored <code>push()</code> to use the same logic as the constructor and figured that would take care of
it.

It didn't.

Instead, I saw this in the generated output:

| ... .call(this, ..., , , , , , , , );

Node was understandably unhappy. Also strange was that my <code>.qse</code> literal expression refs had been replaced by variables called <code>e1</code>, <code>e2</code>, etc (normally they'd
be called <code>qse1</code>, <code>qse2</code>, ...). At first I thought I had some macro that was re-expanding something and generating anonymous expression refs, so I poked around. To my
surprise, no macro like this existed in the Caterwaul standard library. This meant that the bug was in the Caterwaul core itself.

I copied the failing program and started trimming it down until the problem went away. I found out that constructs like <code>'g[_x]'.qse /-f/ y</code> would cause an <code>e</code> variable
to be created. As soon as I got rid of the <code>/-f/ y</code>, the <code>qse</code> would behave normally. I then tried it out on the REPL and found the same strange behavior:

| $ waul -c js_all
  waul> '"foo".qse /-f/ bar'.qse.toString()
  'f(qse_h_azCSgoP86KF16yaWYRruza)'             <- notice: no 'bar'!
  waul> '"foo".qse / z /-f/ bar'.qse.toString()
  'f(qse_j_azCSgoP86KF16yaWYRruza,z,bar)'       <- now it's there

At this point it was clear that it was some strange case of the infix function syntax. After some more poking around and random guesses, I found that calling <code>flatten()</code> on
expression refs didn't work correctly. It turns out that tree coercion had a subtle bug in this function (it's written on one line in the Caterwaul source):

| as: function (d) {
    return this.data === d
      ? this
      : new this.constructor(d).push(this);
  }

This appeared to be doing the right thing: Either return the node or wrap it in a new <code>d</code> node and return that. It would be appropriately generic, too: <code>new
this.constructor</code> would be closed over the node type.

And that's when everything made sense. Expression refs aren't instantiated like regular nodes. Most syntax trees take the "data", or their name, as the first argument. So if you said <code>new
caterwaul.syntax('foo')</code>, you'd have a syntax tree representing the identifier <code>foo</code>. But the expression ref and closure ref constructors are front-loaded to take the value
before the name. The name is entirely optional; normally Caterwaul will just use a gensym.

The result of this was that when <code>flatten</code> was called on an expression ref, the expression ref was parenting itself with another expression ref, not a regular syntax node.
Expression refs don't have children, so this caused the original expression ref to be hidden and replaced by a nullary comma node. Expression refs serialize to their data, so the nullary comma
would be serialized as just ',', hence the syntactically incorrect output.

Long story short, it turns out that <code>as</code> is an anomaly among tree transform methods in that it shouldn't respect type closure. The fix was to write it this way:

| as: function (d) {
    return this.data === d
      ? this
      : new caterwaul_global.syntax(d).push(this);
  }

If only all bugs could be this cool.

__
meta::post('2012.0307.developing-without-unit-tests', <<'__');
Developing without unit tests.
About a year ago I removed caterwaul's unit tests. Now it has only a large functional test: can it bootstrap-compile itself? I think the change has been really good for the project, all things
considered.

Tests are a time investment. You hope that the effort you spend maintaining tests is less than the amount of effort you would spend debugging/fixing regressions that would have occurred
without them. Whether or not this is true depends on a few factors, a significant one of which is how quickly the project requirements change. Caterwaul's API doesn't change very often, but
its internals change more often.

Unit tests are also protection against other developers. I deliberately wrote caterwaul to be difficult for other developers to modify so I wouldn't need to worry about this (and because
writing software this way is just more fun IMO). I'm convinced that team development has some significant game theory problems, and unit tests mitigate these problems to some extent.

Finally, caterwaul has had some interesting philosophical changes since I removed unit tests. It has gotten simpler because I needed to keep it manageable. If I tried to write some
ill-defined, complex library, something would break somewhere and it would take a lot of time to fix. The result is that the code is roughly uniform in its distribution of fragility *
modification frequency.

__
meta::post('2012.0310.becoming-a-dad', <<'__');
Becoming a dad.
<a href='http://adamtipping.com'>Adam Tipping</a> was born two days ago at about 8 in the morning. He's our first, so <a href='http://joycetipping.com'>Joyce</a> and I went
from a low-maintenance child-free existence to something totally different. I haven't thought much about technology since Adam was born, so for the next little while I'll post <a
href='http://adamtipping.com/sleeping.jpg'>cute baby pics</a> instead.

__
meta::post('2012.0312.type-theory-considered-distracting', <<'__');
Type theory considered distracting.
Assembly language is untyped. By the time you're writing assembly programs, all types have been erased into instruction patterns that happen to reflect the semantics of what you're doing. If
you're in a higher-level language, those semantics could even vary depending on runtime variants; the fixity of in-memory representation is, from what I can tell, primarily a historical nod to
low-level type erased languages that depend on it being a compile-time invariant. (And compacting garbage collectors loosen this restriction somewhat by making pointers opaque, so we're slowly
losing aspects of this codependency even in situations where it seems like it should be difficult.)

C inherits its type system from the constraints of assembly language: Types were not particularly used to guarantee correctness or to prove complex compile-time invariants; rather, they
dictated the memory layout in a consistent way. And C has a desirable property because of this. All of its types can be erased at compile-time; there is no runtime type information. This isn't
always the fastest way to do things because of the overhead associated with x86 calling conventions and indirect jumps, but the type system arguably leaves off where it makes sense -- before
the program is run.

Fast forward to the development of the JVM Hotspot compiler, which includes an impressive array of optimizations including <a href='http://en.wikipedia.org/wiki/Inline_caching'
>inline caching</a> that deal specifically with compile-time unknowns whose runtime impact is generally mitigated by heuristic observation. There isn't anything wrong with
heuristic optimization; generational GC, for instance, makes a tremendous amount of sense. But it's worth thinking a bit about the kinds of optimizations that <em>didn't</em> happen even when
they would be relatively trivial to implement.

For example, loop invariant-analyzing compilers do not, to the best of my knowledge, hoist invariants across function boundaries, even when the function is provably monomorphic. This matters
in languages like Javascript; for example:

| var process = function (data, x) {
    return (data instanceof Array ? f1 : f2)(data, x);
  };
  for (var i = 0; i < xs.length; ++i)
    process(constant_array, xs[i]);

Here, <code>process</code> and <code>constant_array</code> are loop invariants, but even sophisticated compilers like V8 are unlikely to include an optimization step that inlines the loop body
into the single expression <code>f1(constant_array, xs[i])</code> even after executing it many times. However, if the dispatch were made implicit by using prototype methods, the inline cache
would kick in and provide a significant benefit.

__
meta::post('2012.0315.too-little-structure', <<'__');
Too little structure.
Caterwaul's parser and syntax trees are much looser than the Javascript language specification. I did this mostly out of laziness; it seemed simpler to write an ad-hoc parser and stick to
operator-precedence parsing as much as possible. It turns out that my laziness enabled a whole range of very cool stuff to be done. For example, caterwaul can parse expressions like this:

| S[for (var L[i] = R[10]; R[i < 10]) S[{_body}]]

This means that you can annotate arbitrary subtrees, including ones in statement mode (!), with markers and then pattern-match against those markers and their contents. Caterwaul has used this
for some time; the <code>seq</code> library uses it to descend through subtrees and parse out the sequence operators. And because the caterwaul parser handles all of the cases uniformly,
markers can be seamlessly integrated into <code>qs</code> and <code>qse</code> forms.

The interesting thing about this is that I wouldn't have even thought of the marker approach had I been using a highly-structured parser and AST representation, and I would have worked harder
to write the parser and AST in the first place. So I've got a new approach: Write APIs with too little structure and fix it later.

__
meta::post('2012.0319.the-value-of-heuristics', <<'__');
The value of heuristics.
Some problems don't have clean, elegant solutions. One example of this is object traversal in Javascript. I was working on a serialization library that crawled through a series of Javascript
objects, serializing each one and encoding the object graph as a series of references that could later be reconstructed. In order to do this, you need to be able to reliably mark each object
and be able to reverse-map objects to their IDs. And the catch is that Javascript only lets you use strings as object keys.

The hard but correct way to do this is to keep an array of <code>[ID, object]</code> pairs that you could then search each time you encountered an object. But this is time-consuming; O(n^2)
overall. Better is to find some way to store the ID directly on each object. This can be done if you choose an extremely improbable name, like
<code>extremely_improbable_name_for_serialization_library</code>. But this approach breaks down once you want to serialize the source tree of your serializer (if you ever did want to do such a
thing), since the name is present verbatim.

I ended up generating a pseudorandom name using at least 128 bits of entropy. This isn't too hard; Javascript identifier characters (A-Z, a-z, 0-9, $, _) encode 6 bits each, so 22 characters
contains 132 bits of information. I chose 128 because for a long time this was considered cryptographically secure; if you could guess someone's 128-bit key then you could see everything they
were saying to each other. Pseudorandom data isn't cryptographically secure, but it is difficult enough to predict that it seemed like a reasonable choice.

The beauty of this solution is that it isn't correct, but it always works. If you can put an upper bound on the degree of pathology of your problem domain, then you don't have to implement
something that is universally functional; you just need to handle the most pathological case that comes your way.

__
meta::post('2012.0323.solving-the-wrong-problem', <<'__');
Solving the wrong problem?.
Source code is represented as text. On the face of it, this is a strange format to use; it requires complex parsing algorithms, makes it easy to write nonsensical statements, and introduces a
large layer of indirection when debugging. Yet I am unaware of any remotely palatable non-text programming environment.

This, of course, bugs me. I would love to see text be replaced by something closer to a program's true representation. Yet more than fifty years after the development of the first programming
languages, we are still using text exclusively. Why?

My guess is that the proposed solutions don't get at the real problem with using text to represent code. For example, structural solutions that I've seen (and I'm no expert, so I may be
overgeneralizing) have worse ergonomics than text, generally take up far more space to represent the same amount of information, and don't provide any particularly compelling advantage other
than constraining the programmer to known-valid constructs.

What about a structural representation that did things differently? How about one which let the programmer move the code through invalid states, used less space than pure text, and had
superior ergonomics? Given the power of editors like vim and emacs, this may not be possible. And arguably it has already been achieved by IDEs like Eclipse.

Put differently, maybe people like to communicate with computers like we communicate with other people: in writing. Just as we would never diagram our sentences as an alternative to speaking
or writing them, maybe it's unrealistic to expect programmers to explicitly state the structure of their code.

__
meta::post('2012.0327.pure-functions-dont-exist', <<'__');
Pure functions don't exist.
State is evil. Such is what we are led to believe by functional programming devotees who justifiably value purity in code. And it continues: referential transparency is crucial, embrace pure
functions, use immutable data structures, etc.

I don't have much of a problem with the philosophical values that motivate this. However, I think there is a particular brand of idiocy that has sprung up from the dogma. It is delusional to
claim that a function has no side-effects, or that pure-functional programming languages as they are implemented today even allow you to write such functions. Here's an example in Haskell:

| -- Program 1: A pure function.
  -- Load this up in ghci and evaluate 'identity 5'.
  identity = id

| -- Program 2: A similarly pure function.
  big_identity 0 = id
  big_identity n = id . big_identity (n - 1)
  identity = big_identity 100000000000000

The first program will quickly return 5. The second program will use up 100% of your CPU for a few seconds, then start swapping to disk, then die after it exhausts all of the available memory.
(I had to reboot because I couldn't interrupt the process due to swapping.) On the face of it, this is patently ridiculous; any human will tell you that it doesn't matter how many times you
compose the identity function onto itself, it remains the identity function. It's also not exactly obvious what this code is even doing; the identity function is defined not to <em>do</em>
anything at all.

The real fallacy, I think, arises from the fact that time, memory usage, etc. are all side effects, and they can cause just as many bugs as excessive state-sharing in imperative code. At the
end of the day, the best way to eliminate undesirable side effects is probably to have a deep knowledge of what your compiler is doing. Abstraction, purity, and correctness don't absolve the
programmer from the responsibility of using a real CPU, real memory, and having real performance constraints.

Put differently, languages don't eliminate undesirable side effects. You can easily write pure-functional C if you want to. Programmers eliminate undesirable side effects by making high-level
decisions about things that compilers are light-years away from understanding. Purity is a property of design, not implementation.

__
meta::post('2012.0401.why-microbenchmarks-are-misleading', <<'__');
Why microbenchmarks are misleading.
The <a href='http://shootout.alioth.debian.org'>Great Programming Language Shootout</a> contains a fairly prominent disclaimer that microbenchmarks are not an accurate measure
of real-world performance. The first time I read this, I remember thinking: "Why not? What about these applications isn't 'real-world'?"

I think the problem isn't that microbenchmarks are somehow fake; they obviously solve very real problems. The real issue lies in the various processes used to write different kinds of
software. For example, suppose you're writing a gzip encoder. There's probably a known-optimal solution with a low instruction count and good cache locality, and which is known to maximize
performance across a wide range of architectures. And it's probably worth tuning the algorithm like this (maybe even per architecture) because gzip faces such a horizontal market.

On the other hand, consider something like Eclipse. It is written in one of the fastest languages in the world, yet it is one of the slowest pieces of software I have ever used. Nothing about
what Eclipse is doing should take nearly as long as it does, but my guess is that the codebase is large and complex enough that effective optimization isn't realistic. Once code gets to be
that large, complexity precludes good optimization. The language's runtime performance is made irrelevant by high-level problems like ineffective multithreading, <a
href='http://www.cs.virginia.edu/kim/publicity/pldi09tutorials/memory-efficient-java-tutorial.pdf'>heavy indirection, and swapping to disk</a>.

In other words, microbenchmarks are useful only when the language runtime is the limiting factor. Most real-world applications are limited by concerns like maintainability, good style,
sensible abstractions, short timelines, and developers who are not compiler experts. For these projects, the applicability of the language's paradigm to the problem will contribute more to
good performance than the vast majority of low-level runtime optimizations.

__
meta::post('2012.0403.zero-risk-consulting', <<'__');
Zero-risk consulting.
I'm going to try something new. I have no idea how it will turn out. It occurs to me that there's probably a lot of risk associated with hiring people in various capacities: Full-time
employees are a very high risk, descending to contractors from managed places like eLance. But with any of these mechanisms, there's enough overhead that you generally don't have a market for
micro-work; that is, stuff that might benefit from a specialist but that only takes a few minutes.

So my idea as it stands is to become a <a href='http://spencertipping.com/zeroconsulting'>zero-risk consultant</a>. <a href='mailto:spencer@spencertipping.com'>Let me know</a>
what you think.

__
meta::post('2012.0411.the-box-problem', <<'__');
The box problem.
<a href='http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=gpp&lang2=java'>It can be argued</a> that Java and C++ have roughly comparable performance for
CPU-bound tasks. Yet Java is justifiably considered to be a much slower language than C++. What gives?

Most programs aren't CPU-bound. <a href='http://www.bitc-lang.org/docs/papers/PLOS2006-shap.pdf'>They're IO-bound against memory.</a> An L2 cache miss is often estimated at 100
clock cycles. This <a href='http://agner.org/optimize/instruction_tables.pdf'>is comparable to two IDIV instructions on a fast 64-bit processor</a> (page 28). This delay is so
significant that processors can <a href='https://en.wikipedia.org/wiki/CPU_cache#CPU_stalls'>use HyperThreading to create virtual cores</a> just so that they have something to
do while waiting for data to load.

In Java, objects are passed by-reference and primitive values are passed by-value. However, there's an important exception to this rule: A generic class with a type parameter always uses a
reference type. That is, <code>List<Double></code> uses reference <code>double</code>s, also called "boxed" <code>double</code>s. Java avoids this representational overhead in certain cases by
providing primitive arrays, which store the values directly.

Boxed values are a problem for four reasons:
<ol>
<li>Accesses to boxed values require an additional pointer dereference, which may miss the cache.</li>
<li>Allocating boxed values takes up a lot of additional space and therefore requires the GC to run more often.</li>
<li>Boxed values are additional entities that must be garbage-collected, so having many of them makes it slower to find the live set every time the GC runs. (Also, the GC will incur its own
    cache misses traversing them.)</li>
<li>In Java, changing a boxed value often involves allocating a new one and garbage-collecting the old one; changing a primitive value can be done in a single instruction.</li>
</ol>

Compilers generally optimize imperative instruction sequences but not data representation. Boxed values are generally an artifact of language or VM limitations, primarily due to the weak type
erasure semantics that most likely became mainstream with the introduction of object-oriented programming (they had been present in dynamically-typed languages for some time, however). Until
compilers get better at optimizing the way data structures are implemented in memory, there will be a strong case for using low-level languages when performance matters.

__
meta::post('2012.0416.goto-isnt-evil', <<'__');
Goto isn't evil.
Constructs which are easy to misuse are branded as evil, despite the fact that using them is generally a conscious decision. <code>goto</code> is the canonical example of this. Mutability is
another, in FP circles. Neither of these is in itself evil, but they become harmful when misused by incompetent programmers. Similarly, OOP and immutability aren't univeral solutions. Either
of these can be misused by similarly incompetent programmers to form codebases that are unmaintainable or impractical.

By analogy, cars aren't evil despite the fact that careless misuse of them kills so many people. Nor are explosives, firearms, chainsaws, or any number of other things that end up hurting
people. They may be treacherous and dangerous, but such is the world we live in sometimes. (Programmers are no exception; look at Javascript.)

Incompetence is the thing that's evil. Capable programmers make informed, responsible choices about how they implement things.

__
meta::post('2012.0508.the-programming-language-quiz', <<'__');
The programming language quiz.
I've just written an impeccable measuring tool for useless knowledge. <a href='/pl-quiz.html'>The programming language quiz</a>.

__
meta::post('2012.0513.selection-bias-in-new-technologies', <<'__');
Selection bias in new technologies.
Each new thing that comes out seems to improve the state of technology. OOP "conquered complexity", FP "conquered buggy state", etc. Yet once enough people adopt a new paradigm, we start
seeing the same old problems pop up again; today's OOP is just as unmaintainable as yesterday's GOTO-laden spaghetti code.

I think there's a selection bias that makes new technologies look artificially effective. Who adopts the latest unproven technologies? Probably enthusiasts, for the most part. Programmers who
are inherently curious about things. And it should come as no surprise that, on the average, a curious programmer is probably more effective than a non-curious one.

The real test is whether the new technology holds up after it becomes mainstream.

__
meta::post('2012.0522.flat-mapping-function-arguments', <<'__');
Flat-mapping function arguments.
I've been getting back into concatenative programming recently. One of the coolest things about it is the fact that you can erase values completely. Here's what I mean by that. Suppose you
want to write a <code>comment</code> function that lets you treat a string (or list, or anything else) as a code comment. You can't do it in most languages. Each expression has a continuation,
and each continuation takes a value. But you can easily do it in a stack language:

| : comment drop ;              ( forth definition syntax )
  "This is a comment!" comment

This works for an interesting reason. <code>drop</code> takes a value without returning anything. This is very different from C, which gives you the illusion of doing the same thing:

| void comment(const char *x) {}
  printf(comment("This isn't gonna work!"),
         "hello world\n");

Nothing comes out of a <code>void</code> function, but the infix syntax assumes that each expression returns a value of some sort. If it didn't, differentiating between unary negation and
binary subtraction would require type information.

Intuitively, the difference seems like <code>map</code> vs <code>flatmap</code> over lists. The rule for <code>map</code> is that you need to transform each value; you can't just make one
disappear. <code>flatmap</code>, on the other hand, can be used to encode every other list operation including <code>map</code>, <code>filter</code>, etc. It also provides some nice
regularity. Here's the failure mode for applicative style:

| (define (uncons c)
    (call/cc (lambda (return)
      (return (car c) (cdr c)))))
  (cons (uncons (cons 3 4)))
  ;; error: too few arguments to [the outer] cons

However, this works just fine in concatenative style:

| : uncons dup cdr swap car ;
  3 4 cons uncons cons

__
meta::post('2012.0527.developer-machines-should-suck', <<'__');
Developer machines should suck.
I've been using an underpowered netbook for software development for the past four years, and it's one of the best things I've ever decided to do. The main reason is that any side-effects like
low performance or disk access become immediately visible. Google Chrome takes fifteen seconds to cold-start, for instance. I can run about eight tabs before the system begins swapping to
disk. Most web pages are CPU-bound (!) when rendering. (A significant part of this is the Intel Atom's lack of out-of-order execution and small L2 cache, I imagine.)

Why would I advocate reducing developers to such a miserable existence? Because they're the ones who are responsible for creating that existence. It's possible to write fast software, but
stuff that crawls on a netbook will appear fast on the latest 8-core Mac with 12GB of DDR3 memory and SSD storage. All of those side-effects, which will probably have a noticeable impact on
80% of the users of the software, become invisible.

__
meta::post('2012.0530.why-i-left-google', <<'__');
Why I left Google.
This post is getting a lot more attention than I expected or hoped. I wrote it mostly for family and friends who know me well and who might be curious about it. So I need to address some stuff
to avoid saying the wrong thing.

  Responses to Hacker News comments.
  <ul><li>Replies to DannyBee's comments
       <p>I think I've unintentionally misrepresented Google here. I'm not a lawyer or an expert, and I tried to play things safe and as much by the book as possible, since I didn't know what
          to expect. I did receive a reply about the project to the effect that it was in an area that Google was interested in, and it was a pleasant surprise when they allowed me to release
          the code and retain copyright. I'm not blaming anyone from the committee and I completely appreciate their efforts and reasonableness. The two-month complaint was a contrast from my
          previous job, where open-source software was easier to release. But I don't think Google was remotely unfair or unreasonable.</p></li>
      <li>"No mention seems to be made of how long Spencer was at Google"
       <p>I was there for a total of six months. A lot of people have said this is not enough time to get an accurate picture, and I think that's correct. A big part of why I left had to do
          with family events, and I was unsure about how well I would do considering my biases as a programmer.</p></li>
      <li>"[he basically said] 'if you don't adopt functional programming you are a loser'"
       <p>I'm biased about this. I don't think Google employs a bunch of losers. They're worth billions of dollars and I don't even own a house. My post isn't about what Google is or isn't,
          it's about the problems I faced based on my biases and perspective. I'm certainly not saying I'm right.</p></li>
      <li>"LinkedIn shows a series of jobs, each lasting less than one year"
       <p>My job history is choppy primarily because of choices I've made. I've been thinking about this a lot and haven't completely figured out why I've had so much trouble staying in one
          place. A lot of it comes down to perfectionism on my part, and the kind of impatient and relentless optimization that ultimately leads nowhere. For what it's worth, I've been in a
          professional career for three years since college, so I've got a lot to figure out. But that should also put this post into perspective; I'm not coming from a broadly informed
          viewpoint.</p></li>
      <li>"the Scala game of integrating every single academic PL research feature of the last 20 years"
       <p>I hate Scala with a passion, for what it's worth. I just wish there had been more advocacy for it.</p></li>
      <li>"directly counter to California law [about open source projects]"
       <p>Google isn't trying to be difficult here. The problem is that they do so much stuff that you're inevitably competing with something, or at least it's hard to rule that out. So to be
          safe, I ran every new project by the committee. They did a great job handling it, too. I just wish the latency had been a little lower. (First-world problems.)</p></li>
      <li>"Google's broken hiring process"
       <p>I think Google's hiring process is perhaps the most objective, well-considered, and effective I've ever seen. The stuff I'm complaining about is probably inevitable in a company this
          size, and like I stated a few times in the post itself, it really is an indictment of me, not them.</p></li>
      <li>"noobs are under the impression that HR somehow impacts employees"
       <p>Sorry, I should clarify. When I talk about HR, I'm talking about everything that wasn't related to coding. Vacation time and expense reimbursement, for example. The system was
          brilliant, easy to use, and efficient. I never felt like I was blocking on any kind of red tape.</p></li>
      <li>"Sounds like someone is a bit difficult to please."
       <p><strong>Yes!</strong> I don't even like a lot of the technology I write for myself, and I consider myself to be one of the most xenophobic and picky technologists I know. This is not
          Google's fault by any means.</p></li>
      <li>"Abstraction is discouraged" (I wrote this)
       <p>This is probably misleading. I'm talking about abstraction in the general sense; things like metaprogramming, etc. I'm not talking about anything like simple code duplication, which
          Google is very sensible about. Avoiding clever abstraction is why their engineers rarely kill each other. But I missed having a job where I could write code like this, so it acted as
          a Con in my decision process.</p></li></ul>

  Also, jrockway has provided an <a href='http://news.ycombinator.com/item?id=4051702'>excellent summary</a> from the other end. Seriously, read this if you want a thoughtful
  counterpoint.

  Original post.
  I resigned from Google about a month ago and have been meaning to write about it. It's always hard to sound grateful when describing why something didn't work out, but hopefully this comes
  across as more of an analysis of my own flaws than an indictment of Google. On the whole, they are an awesome company and I thoroughly enjoyed my time there.

  Also keep in mind that I only saw the part of the company I was working with. Google is a huge place and a lot of my observations probably don't generalize at all.

  From a highly subjective and local point of view, here are some of the key factors that influenced my decision. List items are in no particular order.

  Technological culture.
  This is by far the most important factor behind my decision about where to work, and it was ultimately the reason I ended up leaving. I think a lot of this has more to do with my biases than
  with any particular flaws in Google's technical process. Again, this is all from my point of view and isn't necessarily meant to be objective.

  Pros:
  <ol><li>Total openness. I could read and contribute to the source code for almost any project.</li>
      <li>Well-engineered solutions to hard problems.</li>
      <li>Rigorous unit testing and attention to low-level code quality.</li>
      <li>Good developers had more influence than bad ones (Google employs some of each).</li>
      <li>Very reliable and solid infrastructure to help developers get their job done.</li>
      <li>Bugs and features were generally well-prioritized within the context of our project.</li>
      <li>20% is a real thing, and there are lots of opportunities to pursue cool projects. Mine involved machine learning, for example.</li>
      <li>Basically unlimited computing resources if you needed them.</li>
      <li>Good technological choices were valued and encouraged.</li></ol>

  Cons:
  <ol><li>Pathological love for Java and anything resembling Java.</li>
      <li>Little inclination to solve fundamental problems; most engineering effort spent on superficial implementation.</li>
      <li>Most engineers were not comfortable with {functional, concatenative, combinatory, logic, meta} programming.</li>
      <li>Therefore, most code was stateful and object-oriented, and no alternative design was seriously considered. [1]</li>
      <li>Coding standards and reviews prevented bad low-level decisions, but not bad high-level ones.</li>
      <li>Reviews preferred local simplicity over global simplicity; abstraction was discouraged.</li>
      <li>Internally-developed languages like Go and Dart failed to solve any significant problems. [2]</li>
      <li>UI programming was incredibly tedious due to GWT and its enterprise Java influence, and I as an engineer felt like I couldn't do anything to improve the situation. [3]</li>
      <li>Java was viewed as being "good enough"; alternatives like Scala and Clojure were not considered. [4]</li>
      <li>Insufficient code ownership for engineers to have a reason to write excellent code.</li>
      <li>Out-of-the-box thinking was often not useful.</li>
      <li>Productivity was graded without much regard to the amount of technological debt accrued. (Though to be fair, this is a hard problem.)</li>
      <li>The overhead of getting things done was often dominated by a complex API. Many internal APIs were excessively complex, in my opinion.</li>
      <li>High turnaround time for my own open-source projects. [5]</li>
      <li>Gratuitous boilerplate and complexity were widely accepted.</li></ol>

  Notes:
  <ol><li>I didn't mind the fact that they had chosen OOP for nearly everything. There are good reasons to do this. What bothered me was that a lot of people making these decisions didn't seem
          to have enough knowledge of alternatives to make well-informed choices from a strictly technological point of view. This probably reflects the conservative nature of a large company,
          but things like this detract from Google actually feeling like a startup.</li>
      <li><p>This didn't impact me directly, but I felt like it was symptomatic of a larger problem within Google's technological power structure. It also felt like a compromise for the
          wrong reasons; Google was nominally willing to solve hard problems, but even with people like Guido van Rossum and Rob Pike, they ended up backing out of implementing
          well-established, if not mainstream, PL research.</p>
          <p><strong>Update (June 4)</strong>: There's been an interesting discussion going on in <a href='http://groups.google.com/group/golang-nuts/browse_thread/thread/e2685a311dfeb3cc'
         >the Go Google group</a>, and I should clarify what I meant here. I'm not saying that Go is a bad language to use, like it's all the others in every way, etc. What I'm
          saying is that it gets its roots in concurrency from Erlang, a language that, in my opinion, did a better job of addressing concerns like shared-nothing even if in a
          less-than-performant way. Erlang also was designed from the ground up to be highly concurrent; immutability and such are baked into the language at a low level to make this work. I
          don't know a lot about Go, but from what I've seen, it appears to be a version of Erlang that made it about halfway to C and didn't really decide to stick to a particular mode of
          thought (e.g. shared-nothing actor model, shared-memory multitasking).</p>
          <p>Incidentally, Michael Jones has brilliantly captured the idea I'm talking about. Google has the intellectual firepower to be going where no programmer has gone before, yet
          languages like Go remain solidly in well-understood and, for the most part, commonly-implemented territory. I have no doubt that this is a good strategic move on Google's part, and
          that Go solves a number of important problems that Google faces, but I was disappointed that Google hadn't taken a more experimental and research-focused approach.</p></li>
      <li>Not all teams have this problem; some write their frontends in Javascript directly, which I imagine makes things nicer. But even the Javascript coding standards are rigid enough to
          preclude a lot of interesting metaprogramming opportunities otherwise afforded by the language.</li>
      <li>This is a personal bias and point of arrogance on my part. Java is "good enough" if you are a MegaCorp who hires mostly inexperienced college graduates; but Java is, by many
          standards, not a powerful language and not something that makes sense as a mandate for solid, experienced developers. Scala and Clojure each have significant design flaws, in my
          opinion, and neither would have been a significantly better choice. My objection is not that Google didn't choose one of these, but rather that it's symptomatic of a technological
          inertia that prevents new ideas from being adopted.</li>
      <li>This deserves some explanation. Technically, Google owns everything you write while you work there, even if it's on your own time and with your own equipment. However, they have a
          committee that reviews things you write and assigns copyright to you provided that they don't conflict with something Google is working on. My experiences working with this committee
          were completely positive, but there was often a two-month lag before I got an official reply from them. This uncertainty bothered me a lot, since I wasn't sure whether my project
          could be legally released as open source.</li></ol>

  Corporate culture.
  This wasn't nearly as important to me as the technological culture, but it did still matter. This list is also subjective and may not accurately represent Google as a whole.

  Pros:
  <ol><li>Efficient, well-managed HR system with minimal bureaucracy and red tape.</li>
      <li>Excellent managers, tech leads, and delegation of responsibility.</li>
      <li>Excellent salary, benefits, corporate policies, etc. I cannot emphasize this enough.</li>
      <li>"Don't be evil" was taken seriously at all levels of the company.</li>
      <li>Engineers were given everything required to be happy and do their jobs well.</li>
      <li>Top of the line hardware, and easy access to other devices.</li>
      <li>Frequent tech talks by guest and internal speakers, and about interesting subjects.</li>
      <li>You could leave your desk without anyone assuming you were slacking off.</li>
      <li>Minimal corporate politics, at least from where I was standing.</li>
      <li>Google employees were generally cool people. I can't think of anyone I didn't like.</li>
      <li>Low-stress, low-pressure work environment.</li>
      <li>No negative feedback from management or my team lead. All criticism was constructive, and I really had to ask for it to get any. [1]</li>
      <li>Every week, upper management answers (sometimes critical) questions from employees.</li>
      <li>I felt at ease talking to my manager and team lead about anything that was bothering me.</li>
      <li>It was common practice to make snarky memes, often about Google, and send them to other employees. Management snarks back.</li>
      <li>Google as a company has a great sense of humor.</li>
      <li>Developers could set their own schedule, modulo meetings.</li>
      <li>Performance reviews, interviews, and other evaluations were very objective and fair. I never observed any bias of any sort.</li>
      <li>User experience was a high priority.</li></ol>

  Cons:
  <ol><li>Google+. [2]</li>
      <li>Ubiquitous political emphasis on Google+ that sometimes compromised other engineering efforts.</li>
      <li>Products were not engineered with low-powered devices in mind. [3]</li>
      <li>Features outweighed the bugs that came with them. [4]</li>
      <li>Performance feedback was infrequent and vague.</li>
      <li>A lot of the maintenance I was doing produced a worse user experience, in my opinion. [5]</li>
      <li>"More wood behind fewer arrows."</li>
      <li>Much more formal than a startup (could also be a pro, but for me it was less fun).</li></ol>

  Notes:
  <ol><li>This isn't my way of saying, "look how awesome I am." I totally made my share of screw-ups. I think Google management is legitimately very cool about this stuff across the
          board.</li>
      <li>I think Google+ is an effort that does not deserve the engineering minds at Google. This is mostly a personal bias. I see Google as solving legitimately difficult technological
          problems, not doing stupid things like cloning Facebook. Google, in my opinion, lost sight of what was important when they went down this rabbit hole.</li>
      <li>This is a natural by-product of the combination of (1) dogfooding, and (2) giving engineers top-notch hardware. I think both of these practices are fine, but the problem could
          be addressed by issuing each engineer an underpowered netbook in addition to the insanely powerful machines we were given.</li>
      <li>I'm referring to a number of things, but I feel like Google's tolerance for bugs has gone way up since the early days of GMail. They have implemented more features, but the
          overall software quality is lower now in my opinion.</li>
      <li>This was a major downer for me. I thought the original Google UIs were simple, clean, and fast; the new ones felt clunky and buggy, and I felt like the attention to detail that went
          into the originals was lacking in our redesigns. The decisions behind this were primarily corporate-driven, not engineer-driven.</li></ol>

  Update.
  Some people read this post and concluded that Google would be a bad choice for them. I think that's a definite possibility, but my advice would still be to apply and take a job if you're
  offered one. There are two reasons I think this makes sense.

  First, you could be wrong. You might really love it. And if you do, it's probably one of the top five jobs you'll ever have. Enough brilliant programmers love working at Google that I think
  it's naive to dismiss this possibility too quickly.

  Second, I doubt you'll come out having learned nothing. I learned a lot at Google and left mostly because I wanted to take the time to pursue stuff closer to my interests.

__
meta::post('2012.0601.an-open-source-life', <<'__');
An open-source life.
Wouldn't it be cool to be able to publish the "source code" of your life? From the outside, someone else's life choices are about as opaque as someone else's web server code. Nobody really
knows what kind of information goes in or out, or what the decision-making process looks like. All we see are the outputs of a black box.

The real challenge behind implementing something like this probably isn't the sharing component. Twitter is full of accurate autobiographical information. I think the real challenge is having
a meaningful semantic structure behind it. This would enable searching for answers to life situations, or posing hypotheticals and simulating based on people similar to you.

Life may be too chaotic for this to have any chance of being useful for prediction, but even if this is the case it would be interesting to see it fail.

__
meta::post('2012.0601.the-market-inefficiency-factor', <<'__');
The market inefficiency factor.
I was talking to a friend recently about the role of online advertising in market efficiency. On the one hand, it gives information to consumers and thus allows them to make more informed
decisions. But there's also a competition for consumer attention (a scarce resource), and a lot of ads aren't designed to help consumers make rational decisions.

I thought about it some more and ended up coming to this generalization:

|                     sales $
  inefficiency = -----------------
                 sales + product $

A completely inefficient market has no product at all; just sales. And a completely efficient market has no sales spending, just product development. We see occurrences of both. Currency
exchange markets are almost completely efficient; I don't think anybody runs ads that say things like, "The all-new 2012 Euro. Better and more luxurious than before." They don't need to
because the currency exchange market is largely automated, and money is so boring that emotional arguments for or against it are generally not useful.

On the other side, you have things like lottery tickets. This market is almost completely inefficient; a lottery ticket is a mathematically-expected financial loss for the bearer. But
lotteries are surrounded by misleading advertising that appeals to people at an emotional level, omitting the only useful piece of information about the product itself. Whoever has the most
emotionally compelling advertising, regardless of the odds of winning, will sell the most lottery tickets.

__
meta::post('2012.0610.the-user-is-a-thread', <<'__');
The user is a thread.
Any user-facing program is by its nature multithreaded. The semantics aren't the usual ones, however. Things that happen within 30ms or so are atomic, since that's below the user's reaction
time. Anything else has the potential to create a race condition.

If this line of reasoning is valid, it would mean that applications with inconsistent timing are buggy by default. (I would argue that this is the case.) UI code would be subject to the same
constraints as hard real-time code. Most applications certainly aren't written this way, and to some extent they can't be considering the presence of virtual memory, asynchronous garbage
collection, etc. But given the computational horsepower and otherwise compromised user experience of mobile devices, I think it's a promising area of focus.

__
meta::post('2012.0611.how-modus-works', <<'__');
How Modus works.
<a href='http://github.com/spencertipping/modus'>Modus</a> is a project I started a while ago and have largely left unmaintained. The idea was to let you use jQuery in
higher-order ways on lists or other structures of components. The canonical example is something like name/email:

| <div class='person' id='person1'>
    <input class='name'><input class='email'>
  </div>

Given the above HTML, you could use Modus like this:

| $('.person').modus('composite', {name: '.name', email: '.email'});
  $('#person1').val()   // -> {name:  $('#person1 .name').val(),
                               email: $('#person1 .email').val()}

This morning I received an email from someone who is using Modus in production, asking for a line-by-line explanation of the source code. This is actually a great opportunity to explain some
things about what Caterwaul is doing, so here goes:

First, Modus is written in Caterwaul, not Javascript. It ultimately gets compiled into Javascript, but <code>modus.waul.sdoc</code> is the human-readable source code and <code>modus.js</code>
is the unreadable Caterwaul output. <a href='http://github.com/spencertipping/sdoc'>SDoc</a> is a documentation format I wrote that basically auto-comments any paragraphs
beginning with an uppercase letter or pipe symbol. <code>waul</code>, the Caterwaul precompiler, understands SDoc syntax if the file ends in <code>.sdoc</code>.

OK, so with that out of the way, here's the code (also <a href='http://github.com/spencertipping/modus/blob/master/modus.waul.sdoc'>on Github</a>), snippet by snippet:

| caterwaul.module('modus', 'js_all', function ($) {

This defines a Caterwaul module transformed under the <code>js_all</code> set of macros. <code>js_all</code> includes all of the client/server-agnostic JS macros, but not
<code>jquery[]</code>. (We don't need <code>jquery</code> here because we don't create DOM nodes.)

There are two reasons we create a module. First, it's one of the forms that <code>waul</code> understands. Technically, <code>waul</code> is doing something that isn't possible: it's
predicting the outcome of executing a bunch of Javascript and doing some work beforehand. The only reason this works is that it recognizes a few different toplevel forms and treats them
specially. The result is that any precompilable Caterwaul module is generally defined in its own file and starts with something like the module definition above.

The second reason to define a module is that it will become a part of Caterwaul's replica if you end up calling <code>.replicate()</code>. Most people will never have a reason to do this.

| $ = jQuery;

Obvious enough; we don't need the <code>$</code> reference that Caterwaul gives us, so we replace it with <code>jQuery</code>. Notice that this also gives us the shorthand <code>$ =
jQuery</code>, which is not true by default if the user has called <code>noConflict</code>.

| var original_jquery_val = $.fn.val;
  $.fn.val(args = arguments) = ...;

We're replacing jQuery's <code>val</code> method, so we need to first store the original and then redefine it. The second line uses Caterwaul's function definition syntax, which lets us bind
local variables:

| f(x) = x + 1          // -> f = function (x) {return x + 1}
  f(x = 5) = x + 1      // -> f = function () {
                                    var x = 5;
                                    return x + 1;
                                  }

We need to store <code>arguments</code> because Caterwaul generates sub-functions for certain things, including the <code>-re</code> macro. If in doubt, always store the arguments. Here's the
actual function we're using to replace the original <code>val</code>:

| $.fn.val(args = arguments) =
    this.data('modus') -re [it
      ? args.length ? it.setter.apply(this, args)
                    : it.getter.call(this)
      : original_jquery_val.apply(this, args)];

We're checking to see whether the current DOM node defines a <code>modus</code> data attribute; if it does, we use the getter and setter from that instead of the regular jQuery
<code>val</code>. Otherwise we use the original jQuery <code>val</code> function that we stored earlier. The <code>args.length</code> stuff is similar to jQuery's logic to use <code>val</code>
as both a getter and a setter:

| myElement.val('foo')  // setter
  myElement.val()       // getter

Modus takes care of this for you as a matter of convenience. The next bit of code is a little strange:

| $.fn.modus(getter, setter) =
    getter.constructor === String
      ? use_named_combinator(this, arguments)
      : this.data('modus', {getter: getter, setter: setter}),
  where [use_named_combinator(receiver, args) =
           $.modus[args[0]].apply(receiver,
                                  Array.prototype.slice.call(args, 1))]

First I should point out that there are two <code>modus</code> objects. One is the method that is present on each jQuery collection; this is used to set up behavior for the elements in that
collection. The other <code>modus</code> is a global object on jQuery; this stores predefined behaviors that can be used later on (<code>list</code> and <code>composite</code> are two such
examples).

With that said, the <code>$.fn.modus</code> method checks to see whether you're specifying the getter/setter functions as functions or in some other format. If <code>getter</code> is a string,
then it assumes you want to use a predefined behavior; otherwise it assumes you want to set the element's getter and setter directly. Predefined behaviors are expected to be defined as
attributes on the global <code>$.modus</code>, which we'll see more of in a moment.

| $.modus = capture [
    util = {},

Here's where we set up the global <code>$.modus</code> object that ultimately will contain some useful element behaviors. <code>capture[]</code> is a macro that lets you use function
assignment syntax to initialize object key/value pairs:

| capture [foo() = bar]   // -> {foo: function () {return bar}}

I don't remember what I was using <code>util</code> for. There are three behaviors that come with Modus out of the box:

  Original val function.
  This is not a behavior; it's just a utility function.

  | val() = original_jquery_val.apply(this, arguments),

  This is kind of subtle. Suppose you're writing a field that lower-cases its input using Modus. Here's how you might go about it at first:

  | $('.lowercase').modus(getter, setter)
    -where [getter()  = this.val().toLowerCase(),
            setter(v) = this.val(v.toLowerCase())]

  The obvious problem here, however, is that you'll infinite-loop; <code>val</code> is a call to Modus, which will call your getter and setter functions all over again. What you want to do
  instead is use the original <code>val</code> from jQuery, which you can get to by asking Modus for it:

  | $('.lowercase').modus(getter, setter)
    -where [getter()  = this.modus('val').toLowerCase(),
            setter(v) = this.modus('val', v.toLowerCase())]

  Delegate behavior.
  This is where the behaviors start, and unfortunately with something of a hack.

  | delegate(getter, setter) = capture [
      first() = this,
      val()   = arguments.length
                  ? getter.apply(this, arguments) -then- this
                  : setter.apply(this, arguments)]

  This basically lets you assign one component's value to another one. You can imagine doing it for a single child:

  | <div class='person-container'>
      <div class='person'>
        ...
      </div>
    </div>

  Here, you'd hook up <code>.person-container</code> to use the <code>val</code> function for <code>.person</code>:

  | $('.person-container').each(function () {
      var person = $(this).first('.person').data('modus');
      $(this).modus(person.getter, person.setter);
    });

  I don't think I've ever used this behavior and can't remember why I wrote it in the first place.

  List behavior.
  This is the first combinator that is both useful and interesting. It constructs an array from the children of an element, and allows you to modify the children of an element by setting a new
  array of their values. The <code>new_element</code> constructor is used to convert from values to elements (more on this below).

  | list(new_element) = this.modus(
      "+this.children() *[$(x).val()] /seq".qf,
      "this.empty() -se- _ *![new_element(x).val(x) /!it.append] /seq".qf)

  This combinator is invoked when you write something like <code>element.modus('list', f)</code>. As you can see, it is setting up a getter and setter that close over the function you give it.
  In detail, here's what each one does.

  | "+this.children() *[$(x).val()] /seq".qf

  This is a closure that maps each child into its value. We start by grabbing the children of the Modus list, then using the prefix unary <code>+</code> to slice it into an <code>Array</code>
  instance (this is a <code>seq[]</code> macro feature). We then map (specified by <code>*</code>), and for every child element <code>x</code>, return <code>$(x).val()</code> -- thus
  retrieving the value. The result is bundled into an array that has the same ordering as the DOM nodes.

  | "this.empty() -se- _ *![new_element(x).val(x) /!it.append] /seq".qf

  This is the setter. First, we blow away all children in the node, since we're about to receive a new list. We then iterate through each new value (<code>*!</code>) and construct an element
  for it. There are a couple of things to notice here. First, <code>new_element</code> receives a copy of the value up-front. This helps you handle cases where there are several different
  value types that need different display elements (value polymorphism). Second, we then immediately set the value on the new component. This is more of a convenience than anything else; it
  just lets you omit a call to <code>.val()</code> on the new element if you want to simplify the <code>new_element</code> function.

  Note that the <code>.qf</code> modifier on strings just builds a function out of the string's contents:

  | "_ + 1".qf  // -> function (_) {return _ + 1}

  The other Caterwaul macro used here is <code>/!</code>, which is a way to wrap stuff into a function call while reducing the number of nested parentheses:

  | x /!f       // -> f(x)
    x /!o.f     // -> o.f(x)

  Composite behavior.
  This lets you map arbitrary descendants of elements to object keys. Unlike the list behavior, the composite behavior doesn't create or destroy elements; it just modifies the values of
  elements that are already in the DOM.

  | composite(paths) = this.modus(
      "paths %v* [find(this, x).first().val()] /seq".qf
      "paths %k*![find(this, paths[x]).first().val(_[x])] /seq /then.this".qf),
    where [find(container, path) =
             path.constructor === String
               ? container.filter(path) /~add/ container.find(path)
               : path.constructor === Function
                 ? path(container)
                 : raise [new Error('invalid modus path: #{path}')]]

  Here, <code>paths</code> is an object that describes the name and location of each piece of the value. For example, consider a DOM container that looks like this:

  | <div class='github-project'>
      <input class='name'>
      <input class='language'>
      <input class='branch'>
    </div>

  We want an object that looks like <code>{name, language, branch}</code>. To get this, we just tell Modus which component each key corresponds to:

  | $('.github-project').modus('composite',
      {name:     'input.name',
       language: 'input.language',
       branch:   'input.branch'});
    $('#my-project').val()      // -> {name:     ...,
                                       language: ...,
                                       branch:   ...}

  Here's how the getter works:

  | "paths %v* [find(this, x).first().val()] /seq".qf

  We're doing a value-only map (<code>%v*</code> in the caterwaul <code>seq[]</code> library) over the <code>paths</code> object. This means that the object keys will remain the same, but
  we'll transform the values based on a map function. In this case, the values start out being paths and we're converting them to element values, which we do by first finding the component and
  then invoking the <code>val()</code> function. Notice, by the way, that we're not using the original jQuery <code>val</code>; we're using the Modus <code>val</code> method. This allows you
  to nest Modus components.

  The setter is similar:

  | "paths %k*![find(this, paths[x]).first().val(_[x])] /seq /then.this".qf

  We're still going through the values in <code>paths</code>, but we need to hang onto the keys (using a for-each-key operation indicated by <code>%k*!</code>) so that we can grab the values
  of the value object we're setting, which is bound to the <code>_</code> variable by the <code>.qf</code> string modifier.

  The most interesting part of the composite behavior is the <code>find</code> sub-function:

  | find(container, path) =
      path.constructor === String
        ? container.filter(path) /~add/ container.find(path)
        : path.constructor === Function
          ? path(container)
          : raise [new Error(...)]

  The goal here is to resolve a jQuery selector with respect to a container, but this is not as simple as you might expect. First, the user could specify a function instead of a string; that
  function is then called to return the sub-component. For example:

  | {name: function (container) {
             return container.find('.name');
           },
     language: '.language',
     ...}

  Second, the container itself could be a member of a multi-element collection that contributes to the value. (The second case is pathological and I'm not sure why I thought it mattered, but I
  decided to add it anyway.) To deal with this, we combine the <code>filter</code> output with the <code>find</code> output to make sure that we've included the containers themselves.

  There are two new Caterwaul macros used in this section. One is <code>/~method/</code>, which works like this:

  | object /~method/ value      // -> object.method(value)

  The other is <code>raise[]</code> which throws an error. This is useful because the <code>throw</code> keyword is illegal within an expression.

  And that's it! Modus is just a combination of these few behaviors.

__
meta::post('2012.0620.text-mode-is-awesome', <<'__');
Text-mode is awesome.
I recently tweeted that (text : GUI) :: (FP : OOP), and that Vim was a WYSIWYG
version of Ed. I've been thinking a lot about how UIs are structured, more
computationally than visually, so I'm interested in analogies like these. This
post is a rambling collection of thoughts around the philosophical differences
between text and GUIs.

  The obligatory anecdote.
  I <a href='http://en.wikipedia.org/wiki/Wikipedia:Database_download'
 >downloaded Wikipedia</a> the other day. Now I've got 8GB of
  bzipped XML that I need to unpack and index into articles so I can pull them
  up in <code>less</code> or <code>vim</code>. I wanted to see how the XML was
  structured, so I did this:

  | $ bzcat wikipedia.xml.bz2 | less

  And magically, everything Just Worked (keep in mind that I'm using a
  two-year-old netbook with 1GB of memory). No swapping to disk. No significant
  delay at all. And, remarkably, no CPU usage until I scrolled or searched the
  document. I saw the first screenful of XML in well under a second.

  UNIX/Linux users, will, of course, not be at all surprised by this because the
  pipe has worked this way since the Middle Ages. But a large segment of the
  computing world doesn't have the ability to slice 8GB of data so elegantly.
  For example, suppose the Wikipedia data were stored in 34GB of HTML, similarly
  bzipped, and we wanted to view it in a browser. No problem, we'll just do
  this:

  | $ bunzip2 wikipedia.html.bz2 &      # Or worse, use WinZIP :)
    $ google-chrome ./wikipedia.html

  Aside from the obvious issue that Chrome is likely to load the file faster
  than bunzip2 can provide data, there's a bigger problem lurking here. Suppose
  you've loaded up the first screenful of HTML. Does Chrome wait before reading
  the rest of the document?

  Of course not. It can't, because HTML has no locality properties at all. You
  could easily put a script like this at the bottom:

  | <script>document.body.innerHTML = ''</script>

  The problem here is that the document has a mutable model with no spatial
  ordering of elements. The only way to accurately render the document is to
  load the whole thing into memory, run the scripts, and then render the subset
  of components that appear on the screen (which itself is no small task).

  Put differently, a function from time to state, for any element in the
  document, is both Turing-complete and requires a complete model of the entire
  document.

  FP and OOP.
  FP generally emphasizes data transformations that are extrinsic to the data
  itself, and elements of data are generally immutable and unencapsulated. OOP
  tends towards the opposite: transformations are intrinsic, data is generally
  mutable, and state is hidden.

  This difference is crucial to the function of shell pipes. Once
  <code>bunzip2</code> writes a byte to stdout, it has no way to change it or
  impact the state of that byte. All interpretation is left to the next process.

  The real power comes from the way ASCII is interpreted. Text streams have a
  spatial ordering that, aside from ANSI escape codes and backspace characters,
  maps directly onto the order of bytes in the input. This wouldn't be true if
  ASCII also defined a 'previous-line' character (I'll call it <code>\p</code>).
  For example:

  | foo\nbar -> foo
                bar

  | foo\nbar\pbif -> bif
                     bar

  The problem with <code>\p</code> is that it breaks the ordering. This forces
  interpreters like <code>less</code> to provide a mutable data model, which in
  turn requires them to load the entire input stream before displaying anything.

  IO.
  Since bytes have no intrinsic data transformations or hidden state, they have
  no identity; the byte <code>65</code> (capital A in ASCII) is the same
  regardless of whether it comes from a file, the network, or, importantly, the
  keyboard. This last point is where things get interesting.

  Suppose you're doing stuff on the command line and get tired of repeating
  yourself. Maybe you're sending a series of requests to a webserver:

  | $ curl http://server/request1
    $ curl http://server/request2
    ...

  It's insanely easy to store this process. You can just send your commands to a
  file rather than to a shell:

  | $ cat > commands
    curl http://server/request1
    curl http://server/request2
    ...
    ^D

  Then you can replay them using a redirection:

  | $ bash < commands

  Boring, right? We've seen all this already. Okay, so why can't we do the same
  thing with a web browser?

  The obvious answer is that we could, it would just involve replaying a series
  of browser-generated events. But with sites doing A/B testing and what-not,
  those events wouldn't necessarily mean the same thing. A click could go to the
  wrong place if the layout changed even by a few pixels.

  The real problem is that the events themselves contain implicit ties to the
  DOM state, which I've mentioned requires a Turing-complete simulation and is
  not fully initialized until all of the data has been read. Events are
  generated by an implementation-specific process, and because the model has
  hidden state it is unclear how much data will be required to emulate it.

  By the way, you can always get to a DOM-style model for text. All you have to
  do is start piping things into <code>ed</code>. At that point you'll have an
  in-memory representation of the document so that you can use random access,
  mutation, and other features that aren't normally supported by the streaming
  pattern. The advantage of this is that you can then export the result back to
  a stream and continue using the same old tools.

  Programming languages.
  Strangely enough, I think the philosophy behind FP is better represented by
  shell programming than it is by functional programming languages. FP languages
  still have a number of strange quirks, most notably that you can't generally
  serialize values even though technically every value is anonymous. The reasons
  for this tend to be arcane -- stuff like holding references to opaque
  structures within the language runtime -- but still relevant for real-world
  use.

  The UNIX command-line toolset is remarkably analogous to functional
  programming in any case. For example:

  | grep 'pattern' file         -> filter f xs
    head -n100 file             -> take 100 xs
    tail -n100 file     sort of -> drop n xs

  The similarity goes beyond commands; data structures are also modeled:

  | mkdir foo                   -> foo = {}
    echo bif > foo/bar          -> foo['bar'] = ['bif']
    echo baz >> foo/bar         -> foo['bar'].push('baz')

  Conveniently, newlines give us seamless Perl-style lists with associative
  consing. That is, a scalar (a one-line file) is just a one-element array (a
  many-line file). This means that files generalize a couple of different
  monads (<code>Maybe</code> and <code>List</code> are the ones that come to
  mind) and allow us to freely convert between them since the types are erased
  by the time we use the data.

  The image.
  Continuing the now off-topic tangent, I'd like to point out that an image of a
  hard disk is, as its name suggests, an image. And Bash is, as its name sort of
  suggests, a REPL, which is a kind of shell.

  Therefore, using a shell to modify a hard disk image when writing software is
  very similar to using a REPL to modify an image file, something you might do
  in Smalltalk or Lisp. A lot of developers are understandably leery of this
  paradigm because it's hard to see what has been defined, diffing is difficult,
  etc. In general I would argue that the UNIX image and REPL are much more
  powerful and functional than the REPLs offered by other languages -- that
  could be why we're willing to work with it but unwilling to use other
  image-based systems. But the analogy is still there, and the power of a
  self-modifying image is sufficient that nobody edits a disk image from the
  outside anymore.

  Complexity.
  Last sub-point. UNIX command-line tools are small and have very few bugs,
  graphical programs are large and have many more bugs. This echoes the claims
  made by FP advocates that functional code is simpler to write and maintain.
  The 200+ megabyte Haskell installation is not a great testament to this point,
  but the difference between Chrome (70MB) and <code>less</code> (151KB) could
  be, depending on how you interpret it.

__
meta::post('2012.0819.clojure-metadata', <<'__');
Clojure metadata.
I've finally gotten around to learning Clojure, and I have to say it's an
impressive and very usable piece of technology. At first I was worried that it
was a hack to get Common Lisp running on the JVM, but it's much more than that.
In general I've found it to be predictable and easy to learn, but one of the
counterintuitive parts of Clojure is the way it deals with metadata.

When I first saw the metadata mechanism, I thought, "oh cool, we can attach
arbitrary maps to things", so I popped open the repl and tried to do exactly
that. I used the <code>^meta value</code> shorthand, since the documentation
states that it is a reader macro that expands to <code>with-meta</code>.

| user> (meta (with-meta 'a {:doc "hi"}))
  {:doc "hi"}                   ; so far so good...
  user> (meta ^{:doc "hi"} 'a)
  nil                           ; huh?
  user>

Clearly my understanding of metadata is a little off, but even more perplexing
is this:

| user> (meta (with-meta [] {:doc "hi"}))
  {:doc "hi"}                   ; as expected...
  user> (meta ^{:doc "hi"} [])
  {:doc "hi"}                   ; wtf!
  user>

So we can attach metadata to a vector but not a symbol?

Here's the missing piece. <code>^meta value</code> is a reader macro, whereas
<code>with-meta</code> is a regular function call. This is important. You'll
notice that you can use metadata annotations inside of quoted values:

| user> '(a ^:b c)
  (a c)
  user>

This is different from something like the <code>@x</code> reader macro (and, in
fact, nearly every other reader macro supported by Clojure):

| user> '(a @b c)
  (a (clojure.core/deref b) c)
  user>

The difference is that in the case of quotation, dereferencing, unquoting, etc,
the reader generates a function call. In the case of metadata, the function call
happens inside the reader! This explains why we started losing metadata on
quoted symbols; here's what happened there:

| ;; the repl reads the input:
  '(meta ^{:doc "hi"} 'a)               <- initial list to be read
  `(meta ~(with-meta 'a {:doc "hi"}))   <- ^ reader macro
  `(meta (quote a))                     <- metadata is on the (quote a) list
  ;; the repl has read the list; it evaluates the result:
  (eval '(meta (quote a)))              <- metadata is still on (quote a)
  ((resolve meta) (eval (quote a)))     <- eval rule for function calls
  (<meta> a)                            <- evaluate the argument

The metadata is lost when we evaluate <code>(quote a)</code>, which is a list
that contains metadata, into <code>a</code>, which is a symbol. This makes
sense; metadata shouldn't persist across evaluation.

What about vectors? Here's the difference:

| ;; read:
  '(meta ^{:doc "hi"} [])               <- initial value to be read
  `(meta ~(with-meta [] {:doc "hi"}))   <- ^ reader macro
  `(meta [])                            <- metadata is on the [] vector
  ;; evaluate:
  (eval '(meta []))                     <- metadata is still on []
  ((resolve meta) (eval []))            <- eval rule
  (<meta> [])                           <- [] evaluates to itself!

We don't lose the metadata here because the empty vector evaluates to itself and
therefore keeps whatever metadata it had at read-time. There is some strangeness
that comes about because of this:

| user> ^{:doc "hi"} [1 2 3]
  [1 2 3]
  user> (meta *1)
  {:doc "hi"}
  user> [1 2 3]
  [1 2 3]
  user> (meta ^{:doc "hi"} *1)
  nil
  user>

It's the same problem we had with the quoted symbol from before. The reader
hands us a symbol <code>*1</code> with metadata already on it, but
<code>eval</code> converts that metadata-laden symbol to the un-metadata-laden
vector <code>[1 2 3]</code> before <code>meta</code> can see it.

The result of all of this behavior is that you are likely to see
<code>with-meta</code> in evaluative contexts; that is, within functions and
other normal expressions that will be processed by <code>eval</code>. Read-time
metadata makes more sense in any quoted context, including in macro arguments
(which themselves are quoted by Clojure when it sees that you're calling a
macro).

This also means that the strange behavior of the reader macro is actually a
strong <em>feature</em>: it allows metadata to be value-transparent even before
the evaluation process. This results in nice properties like:

| user> (= '(a b c) '(a ^{:doc "hi"} b c))
  true
  user>

__
meta::post('2012.1129.an-apology', <<'__');
An apology.
About six months ago I wrote a <a
href='/posts/2012.0530.why-i-left-google.html'>now-infamous
post</a> about why I left Google. I still stand behind most of what I wrote,
but after thinking about it I need to address one point in particular: "Go
failed to solve any significant problems."

I'm sorry I wrote this and I think it shows a significant lack of perspective.
First, I don't know Go as a language, and I didn't then when I bashed it. When
I wrote the post I was still frustrated with the unimaginativeness of Dart, and
Go, from what I had seen, looked like another Java-ification of an otherwise
interesting language (Erlang).

Let's suppose for a moment that I was right about that much. Even in that case,
I don't think my point had much merit because Erlang has a number of problems
that make it difficult to use in practice. The two that I've heard about most
commonly are obscure syntax and suboptimal performance. If Google managed to
solve just these problems with Go, then they've changed the landscape of
programming languages enough to make writing concurrent programs much more
approachable to normal people (i.e. people who don't get excited about phrases
like "process calculus").

Anyway, I shouldn't have written this about Go. Google has started a number of
interesting compiler/language projects and the only one I actually know enough
about to criticize is Dart (which I still think is a disaster, but that's
another rant). All of the others I've looked at have been meritorious in some
significant way, whether as a matter of design or, more commonly, of
exceptionally thoughtful implementation.

__
meta::post('2012.1201.selling-go', <<'__');
Selling Go.
A couple of days ago Tibor on the <a
href='https://groups.google.com/forum/?fromgroups=#!topic/golang-nuts/4mhaMR3-s8w'
>Go user group thread</a> posted a question that I thought was
really interesting. Quoting directly from his message:
<blockquote>
Many people just flip through the pages and code samples and say "alright I get
it" and then either forget about it or start trolling right away. I am
personally having a hard time having certain people try Go for real. I might do
something wrong or maybe it just depends on the people.
</blockquote>

Being a PL enthusiast, I started thinking about what about Go as a language
might contribute to or prevent its adoption. Here's part of my reply:
<blockquote><p>
Regarding motivating people to use Go, it occurs to me that Google might not be
very good at selling languages. I could be overgeneralizing on that point, but
as a Javascript developer the Dart synonym page looked fairly uninspiring:
http://synonym.dartlang.org/ (and in some cases the page is incomplete or
misleading; e.g. "const" in newer versions of Javascript). The reason it's
uninspiring to me is that, coming at it from the perspective of Javascript, I
see the introduction of a type system (which I'm not really a fan of, being a
JS developer), some kind of worrying browser compatibility stuff, and a bunch
of other stuff that in many cases can be solved with libraries. I also have to
learn a whole new set of semantics and idioms; for instance, suppose I'm
interfacing with JS code that gives me undefined ... how do I check for that
case? I do get some nice features for it, like string interpolation, but I can
get rid of most of the negative adoption costs by going with a thinner
abstraction layer like CoffeeScript instead.</p>
<p>Another point is that Java has been the status quo for some time; people who
enjoy adopting new languages have had lots of time to explore alternatives, and
many of those alternatives aren't very Java-like (Ruby, Scala, Clojure,
Haskell, etc). So using C/Java-style syntax in the Go language might work
against its adoption, since early adopters who are used to non-Java stuff may
assume that the syntactic similarity implies a conceptual similarity, or they
may just not like C-style syntax. (Both apply in my case, and that's part of
the reason it took me so long to see why Go might be useful. The other part is
that I was just being closed-minded.)</p></blockquote>

Later, in response to my implicit comparison of Clojure and Go:
<blockquote><p>
Clojure gives me a number of things that I really like, among which are syntax
macros, dynamic typing, immutable data structures and excellent destructuring
binds, transparent JVM interop, REPL-oriented development, non-OO multimethods,
and a nice hybrid of familiar semantics from Lisp and Java. Now it also comes
with some disadvantages, but since I already knew Java and Lisp the adoption
cost was very low for me and Clojure is decisively better than either one for
what I'm doing.</p>
<p>My honest question is, from my point of view (i.e. relative to Clojure) what
does Go bring to the table? If I were writing a large application and
collaborating with other developers, it would bring API stability (due to
types), performance, and a unified way of doing inter-process communication.
And if I were coming from Java only, it would be a clear win, since it makes a
lot of things easier than they are in Java. But you're already assuming that
I'm willing to adopt Go over Java, which would mean I'm a member of the
demographic that is willing to learn a new language to solve a problem. Once
that's the case, Go isn't competing with Java anymore; it's competing with
Java, Ruby, Lisp, Scheme, OCaml, Haskell, Scala, Clojure, F#, D, CoffeeScript,
Factor, Erlang, etc. Go has a natural advantage in that because it was
developed by Google it probably has a lot of internal consistency and is likely
to be well-engineered, but since it's a new language without a well-known
killer library (e.g. Rails for Ruby, jQuery for Javascript, Cascalog for
Clojure), people could be justifiably hesitant to absorb the cost of learning
it.</p></blockquote>

Knowing just enough about programming language adoption trends to be dangerous,
here are my thoughts about some of the factors governing Go's adoption
(elaborating on my reply above). I'll start off with the parts of Go that I
think are particularly cool:
<ol>
<li>Multiple return values from functions. This is a great feature for
    functional programming because it means that you can compose and invert
    non-unary functions, and Go's standard library contains several function
    that use this feature eloquently.</li>
<li>Anonymous functions and closure support.</li>
<li>Goroutines, and the fact that they look just like function calls.</li>
<li>No de-facto OOP.</li>
<li>Channels. I don't know all of the details about how these work, but judging
    by the success of the actor model in Erlang and Scala, and in particular
    the idea of unshared memory and message passing, I think channels give Go a
    compelling edge when writing imperative multithreaded code.</li>
<li>A sane static type system. Nothing over the top like Scala.</li>
</ol>

As an aside, throughout this post I talk as though Go has very few users.
<strong>This is not the case.</strong> <a
href='http://redmonk.com/sogrady/2012/09/12/language-rankings-9-12/'
>This article</a> puts Go in the same ballpark as Scheme,
Erlang, Prolog, Clojure, D, OCaml, Groovy, and R. I think the reason I see Go
as being less widely used is that it feels like a general-purpose language,
whereas the others don't -- and it's reasonable to assume that a
general-purpose language will have a wider audience than a specialized one. So
I do think it's valid to speculate a little about why Go hasn't seen more
widespread adoption.

Here's how the language looks to me from the point of view of some stuff I've
done.

  Writing a low-level interpreted language.
  Whether I should or not, I really value C's ability to get right down to the
  metal. For instance, if I write code like this:

  | some_struct_type **stuff = ...;
    stuff[i] = get_a_struct_pointer();

  I can be really confident that somewhere in my machine code there's going to
  be a couple of register loads followed by an 8-scaled move to memory. And in
  particular, nothing else is going to happen; C doesn't insert write barriers,
  bounds checks, or anything else unless I tell it to.

  What does Go do with this? I'm not entirely sure. Go is garbage-collected,
  which means it might put in a write barrier. It might also insert bounds
  checks, even though I might be absolutely certain that it doesn't need to.

  More significantly, am I going to be able to JIT stuff from Go? In C I can
  <code>mmap</code> some memory, <code>mprotect</code> it to be executable,
  write some machine code, and run it. That generated code can interact with my
  <code>struct</code> values because I know where all the bits are.

  C also gives me a preprocessor that I can use to abstract away a lot of
  repetition. For example, I have some bytecodes that do vectorized math on
  64-bit value cells. I could write each operation by hand, but instead I wrote
  a preprocessor macro and instantiated it four times, once for each integer
  size:

  | #define defbinop(name, name_prefix, type_prefix, op) \
      defbytecode(name_prefix##8##name) \
        type_prefix##8_t v1[8], v2[8]; \
        dpop(v1); dpop(v2); \
        if (exit_code) return exit_code; \
        v1[0] = v2[0] op v1[0]; v1[1] = v2[1] op v1[1]; \
        v1[2] = v2[2] op v1[2]; v1[3] = v2[3] op v1[3]; \
        v1[4] = v2[4] op v1[4]; v1[5] = v2[5] op v1[5]; \
        v1[6] = v2[6] op v1[6]; v1[7] = v2[7] op v1[7]; \
        dpush(v1); \
      end \
      defbytecode(name_prefix##16##name) \
        type_prefix##16_t v1[4], v2[4]; \
        dpop(v1); dpop(v2); \
        if (exit_code) return exit_code; \
        v1[0] = v2[0] op v1[0]; v1[1] = v2[1] op v1[1]; \
        v1[2] = v2[2] op v1[2]; v1[3] = v2[3] op v1[3]; \
        dpush(v1); \
      end \
      defbytecode(name_prefix##32##name) \
        type_prefix##32_t v1[2], v2[2]; \
        dpop(v1); dpop(v2); \
        if (exit_code) return exit_code; \
        v1[0] = v2[0] op v1[0]; v1[1] = v2[1] op v1[1]; \
        dpush(v1); \
      end \
      defbytecode(name_prefix##64##name) \
        type_prefix##64_t v1, v2; \
        dpop(&v1); dpop(&v2); \
        v1 = v2 op v1; \
        dpush(v1); \
      end

  | #define defubinop(name, op) defbinop(name, u, uint, op)
    #define defsbinop(name, op) defbinop(name, i, int, op)

  | defubinop(add, +)
    defubinop(sub, -)
    defubinop(eq, ==)

  | defubinop(lt, <)  defsbinop(lt, <)
    defubinop(le, <=) defsbinop(le, <=)
    defubinop(mul, *) defsbinop(mul, *)

  | #undef defbinop

  More superficially, I have a soft spot for C's anachronistic syntax oddities.
  Go feels a little undecided about whether to keep them or to go with
  something smoother like Ruby syntax.

  Finally, Go carries with it a new set of default assumptions that need to be
  learned. What is the relative precedence of <code>==</code> and
  <code>&</code>? How are strings encoded? Can I construct a slice over
  varargs? (And if I can, what happens if I return that slice?) Do standard
  library functions return slices that might make large arrays ineligible for
  GC? If I write an anonymous function that doesn't close over anything, does
  it still allocate memory?

  So those are my biggest areas of concern about Go as a language for an
  interpreter. From where I'm standing, it could provide some nice benefits
  like memory safety and GC, but only at the huge cost of significantly
  increasing the underlying complexity compared to something like C or C++.

  Writing a web app.
  For a problem like this, low-level systems programming is (hopefully) out of
  the picture and you can just focus on the domain-specific code. At that point
  Go's managed runtime looks a lot more attractive, and its concurrency
  primitives seem perfectly suited to horizontal scaling. (Not to mention its
  integration with AppEngine.)

  It might seem like Go has an advantage here, but there are a lot of
  competitive options. Java and Ruby each offer great framework support and the
  ability to quickly scale up an experienced development team. For corporate
  development, I don't see Go winning as an app development language until it
  gets a killer library that gives it an edge over Rails. (Actually, this isn't
  quite true. It can win for anything where maintainability matters, but at
  that point people will probably gravitate towards Java.)

  What about solo developers pursuing hobby projects? In this case there
  probably isn't a budget and you can afford to take a risk to learn a new
  language.

  Here's the problem with this situation, though. If you're even looking at
  changing languages (as opposed to libraries, for instance), then you're
  probably looking for something that gives you a lot of leverage. Learning a
  new language is a lot of work, and you probably want to get significant
  returns for your effort. In a case like this, you're more likely to end up
  with Ruby, Python, Perl, Smalltalk, IO, Clojure, Scala, Javascript (for
  Node), Erlang, etc.

  Getting down to brass tacks, though, Go is competitive with all of the above
  languages in that it gives you lots of mechanisms to write functional
  programs. And furthermore, it's faster than all but Scala if you take the
  <a href='http://shootout.alioth.debian.org'>Shootout</a>
  results at face value. I think Go has more technological merit than Ruby,
  Python, IO, and, I reluctantly admit, Javascript.

  However, this technological merit and suitability for FP tasks is obscured
  somewhat by the presentation on the <a href='http://golang.org'
 >Go language website</a>. The very first example you see is
  something that is structurally similar to "hello world" in C. A lot of the
  other examples on the site use Go's functional constructs in minor ways but
  have relatively low awesomeness per byte of source.

  Compare this to CoffeeScript, whose <a href='http://coffeescript.org'
 >website</a> kicks off with some concise and compelling use
  cases that are appealing to Javascript programmers. Although a tiny fraction
  of the engineering achievement of Go, CoffeeScript's website makes its case
  much more clearly than Go's.

  Incidentally, after a few hours of reading stuff on the Go website I found
  this webserver program (I've changed the formatting slightly):

  | package main
    import (
      "fmt"
      "net/http"
    )
    func handler(w http.ResponseWriter, r *http.Request) {
      fmt.Fprintf(w, "Hi there, I love %s!", r.URL.Path[1:])
    }
    func main() {
      http.HandleFunc("/", handler)
      http.ListenAndServe(":8080", nil)
    }

  This is beautiful: simple and to the point. If this were on the front page, I
  imagine Go would have a lot more traction within the web development
  community. (An example very much like this sold me on node.js when it first
  came out -- mostly because there was no config-related boilerplate, a welcome
  change from JVM-based frameworks.)

  Making enemies.
  I'm going to speculate wildly and suggest that Go needs to make some enemies.
  For example, here are some controversial statements I think are made by other
  non-mainstream languages, often on their websites:
  <ul>
  <li>Erlang: "if you want to distribute, don't share data"</li>
  <li>Haskell: "we don't need no stinking side-effects"</li>
  <li>Ruby: "we don't need no stinking <code>main</code> method"</li>
  <li>CoffeeScript: "Javascript should be more like Ruby"</li>
  <li>IO: "prototype OO and Lisp metaprogramming are good ideas, but
           S-expressions are kinda lame"</li>
  <li>Scala: "you won't fall into the gaping chasm we've left between FP and
              OO, we promise" (disclaimer: I don't like Scala)</li>
  <li>Clojure: "Lisp needs immutability and the JVM to write good concurrent
                software"</li>
  <li>Caterwaul: "readability is overrated"</li>
  <li>J: "we win at code golf, every. single. time."</li>
  </ul>

  I think if Go made a similarly strong statement, it would catch the attention
  of like-minded programmers, albeit at the cost of alienating others.

  And that's the end of my rant. Let me know if I've made any factual errors,
  and as always, I'm not an expert and am speculating wildly. I'll be
  interested to see what happens with Go. It wouldn't surprise me if it became
  the next big thing in big data processing, for example. I think it's a
  language that is just waiting for the right killer library.

__
meta::post('2013.0327.why-caterwaul-sucks', <<'__');
Why Caterwaul sucks.
In case you haven't heard of <a href='http://caterwauljs.org'>Caterwaul</a>
(you probably haven't), it's an experimental programming language I wrote that
does some very awesome stuff. I've used it productively for over three years to
write all kinds of different apps in a fraction of the time it would have
taken in vanilla JS. Over these three years I've also written about two dozen
extension modules for it, doing everything from the <a
href='http://github.com/spencertipping/caterwaul-parser'>useful</a> to the <a
href='http://github.com/spencertipping/caterwaul-ext4'>laughably misguided</a>.
This post is about the changes in mindset I've gone through since starting the
project.

Caterwaul, like <a
href='http://github.com/spencertipping/perl-objects'>many</a> <a
href='http://github.com/spencertipping/canard'>other</a> <a
href='http://github.com/spencertipping/divergence'>bad</a> <a
href='http://github.com/spencertipping/gnarly'>ideas</a>, began as an
opportunistic hack. What made Caterwaul different and interesting was that it
was actually useful: it worked for my honeymoon-stage Lisp Enlightenment and
gave me a way to write tools to enable better web UI development, which at the
time I wanted to start a business around. It was wonderful, really. I built
libraries like <a href='http://github.com/spencertipping/modus'>Modus</a> that
made working with the DOM as simple as getting and setting a jQuery
<code>val</code>, and generating HTML as simple as writing quasi-HAML inside
Javascript and returning the results from functions.

This was pre-Google, so I hadn't really worked with large-scale software
before. In particular, I was used to the economies of startups, where
reliability was a luxury that cost too much to be taken that seriously. Armed
with that mentality and a dangerous amount of hubris, I set out to write things
like Caterwaul with two goals. First, it must be awesome. Like, "that shouldn't
be possible" awesome, stuff like introspective, self-replicating compilers that
can drop live references from the compiling environment into the code. And
defer parsing for certain chunks of stuff. Caterwaul is full of things like
this, not because it was useful but because it seemed just barely possible.

Second, it must be useful to me. I didn't really care whether it was useful to
anyone else because I was, at that point, waging a personal war against the
widespread blub influence, compatibility with the unwashed masses be damned.
There is some merit to this mode of thinking, but it isn't self-justifying like
I thought it was. (More on this later.)

So that's where Caterwaul came from, and that's why it looks weird, emits only
one error message that you will probably never encounter, fails through for
dozens that you probably will, and is written in 192-column-wrapped Javascript
squeezed onto as few lines as humanly possible. It's also why Caterwaul uses a
horrendously hacked operator precedence parser to parse the entirety of the
Javascript language. (To this day I'm still proud that I managed to get that
code to work.)

That, from my perspective, is the somewhat obscure technological foundation
from which Caterwaul arose. More interesting, I think, is the non-technical
perspective of anyone faced with using Caterwaul in real life.

I've tried to come up with an analogy that conveys what I consider to be
Caterwaul's main problem, and here's the best one I can think of so far. A
product-eng meeting is about to start when one of the engineers arrives wearing
no clothes. Suppose we look at the state of mind in the fraction of a second
before anything is said.

Most of the people in the room are thinking variations of "tasteless,"
"offensive," "lawsuit," and "let's hope this doesn't make it to the press." The
engineer is thinking, "I've never understood why the human form is so
offensive. It's a precise, powerful machine whose engineering is second to
none. And these people have forgotten what true engineering is. Besides,
clothing impedes performance."

The modes of failure in this scenario aren't factual in nature. Nobody needs to
be incorrect for everyone to be offended. And I personally think that from a
rationalist perspective my fictional engineer makes a reasonable point, but
what's really relevant is how it fits into the surrounding context.

Put differently, being iconoclastic isn't a crime or a sign of immaturity. But
being reflexively iconoclastic certainly is.

My mistake wasn't writing Caterwaul. The reason Caterwaul sucks so much is that
I thought it was something other people could use. It's a great piece of wall
art, an ambitious venture into uncharted territory, and maybe a good read, but
ultimately unfit for production.

I write software differently now. About a week ago I started <a
href='http://github.com/spencertipping/infuse-js'>Infuse</a>, a library that
takes the best ideas from Caterwaul and reframes them in Javascript idioms.
This doesn't mean I'm giving up quixotic crusades towards impossible goals (you
can take my self-modifying Perl when you pry it out of my cold dead hands).
It's the opposite: some of the most real problems programmers face have to do
with human, not computer, communication. <em>Those</em> are the problems that
demand the most interesting and creative solutions, and that's what I've
resolved to start focusing on.

That, and wearing clothes to meetings. Gotta start doing that.

__
meta::post('2013.0713.compressing-the-requirements', <<'__');
Compressing the requirements.
It's taken a while, but I've finally come up with a counterargument (by
technological analogy) to my previously-held belief that a more powerful
language would make me a more productive programmer. This is a hard kind of
mindset to get out of, because the equation seems so obvious: productivity =
(features delivered) / (development time). And if you can use a better language
to decrease the development time for the same features, then you're more
productive. Obviously.

So, with that said, here's a hand-wavy, ostensibly mathematical (but not
really), don't-try-this-at-home analysis of software development economics.

Obviously the above equation is true, but it's capturing only the "coder"
element of the software development supply chain. The full equation from the
client's perspective would look more like this:

|         problems solved       features
  value = --------------- x ----------------
             features       development time

This new term, (problems solved) / (features), is really important. It makes
the "features" term disappear altogether in the final analysis, but more
importantly it adds a factor that can be optimized.

Here's the reason this matters so much. Most of the time, for most applications
that people will pay you to write, <em>a signifcant fraction of the features
make little or no sense</em>. For example, the password-reset mechanism on
every website you sign in to. Here's the technological absurdity of it:
<blockquote>
  <p><strong>Technological purist:</strong> Ok, so I'm making a website, and
  the user needs a password to prove their identity. Got it.</p>
  <p><strong>Real world representative:</strong> Yep, but sometimes the user
  forgets their password.</p>
  <p><strong>T:</strong> Forgets?</p>
  <p><strong>R:</strong> Yep, all the time, in fact. So we need a way for them
  to recover it, or at least to create a new one.</p>
  <p><strong>T:</strong> Ok wait, but they don't also forget their identity,
  right? They just forget their password.</p>
  <p><strong>R:</strong> Exactly, so we need to have another secondary way for
  them to prove their identity.</p>
  <p><strong>T:</strong> Like a second password, since statistically, the odds
  that they'll forget two passwords are lower than the odds that they'll forget
  just one.</p>
  <p><strong>R:</strong> No, that's too much work. Let's ask them something
  about their history instead.</p>
  <p><strong>T:</strong> Aha, so it's a new password, but the user didn't have
  to make it up!</p>
  <p><strong>R:</strong> Um, sure, whatever. But let's call it a "security
  question" instead, since it's not a password (<strong>T:</strong> Yes it
  is.), and the user will need to use it only when they forget their
  password.</p>
  <p><strong>T:</strong> Ok, wait. If the user has this magic "security
  question" that they'll never forget, and they can get or create a password by
  using it, then why not just use that instead of a password in the first
  place?</p>
  <p><strong>R:</strong> Because someone else might know it.</p>
  <p><strong>T:</strong> So anyone who knows their "security question", which I
  still claim is a password (<strong>R:</strong> No it isn't.), can assert that
  they're the user, and we know up-front that this "security question" is
  insecure enough that we can't use it for account access in the first place.
  <p><strong>R:</strong> Yes.</p>
  <p><strong>T:</strong> Explain to me how this is anything other than a
  horrible idea.</p>
  <p><strong>R:</strong> Amazon does it* and is worth billions. Q.E.D.</p>
  <p><strong>T:</strong> Well played.</p>
</blockquote>
<p>
<strong>*</strong> This is not true (or at least not anymore), though I
remember having to enter security questions for a number of websites in the
past.
</p>

Now, you might argue (as I used to) that with a powerful language like Lisp,
you can just write macros and such, and compress these complicated-seeming
real world problems into compact implementations. In some cases this works, but
in my experience the closer you are to the user, the less reliably you can
factor your code by reusing logic. I want to justify this point by analogy.

Suppose you're tasked with compressing a bunch of photos. They're all different
angles and moments in time of The Fonz jumping the shark, so there's some
opportunity to reuse information across multiple images. What's the best
strategy?

Let's approach the problem top-down first. You've got these images that may
have shared structure, but you'll get a lot of mileage out of something obvious
like JPEG. It's lossy, but most users won't care much. From there, you might be
able to try stacking the images up and encoding it as a movie, or maybe gluing
them all together and encoding it as a large JPEG. Worst-case, maybe you encode
them separately, then bundle it up as a .tar.xz to get some small compression.

So that's the top-down approach: probably effective, not very technologically
inspiring. Luckily the bottom-up approach is a lot more fun. We know the images
are different camera angles of the same event, so from a 3D point of view we
have a lot of shared structure. Sounds like a photorealistic rendering problem.
So let's write a raytracer and describe the physical shapes in the scene,
setting the camera angle and position as the primary variant. We can then make
minor model adjustments and encode the inevitable small differences from the
actual pixels, resulting in a space-efficient lossless encoding.

Aside from not being able to encode any images in under a decade, I'm not
actually that convinced that the bottom-up solution would result in much better
compression. And if you found this was the case and wanted to improve the
compression ratio, it would be more difficult than it is for a straightforward
strategy like JPEG. The compression artifacts would probably be more visible
because the model has more degrees of freedom and because it maps nonlinearly
onto the screen.

JPEG and the raytracer encoding differ philosophically in a significant way.
The whole idea behind JPEG is that these images are being viewed by humans; and
because of what we know about human perception, some features are more
important than others. Notice where JPEG optimizes: <em>it removes detail</em>,
which is analogous to a software developer realizing that some feature doesn't
even need to be written.

Contrast this with the raytracer strategy, which is about feature encoding
efficiency. The focus isn't on removing stuff, but on studying the features
that do exist and finding a way to share information between them. The user's
perception is an afterthought; we're encoding what exists, not the way in which
the user will see it.

Here's what I think is so interesting about this difference. JPEG is clever in
that it carefully encodes the degrees of freedom created by optical perception,
allowing it to use a simple cosine-transform and still get great compression
ratios. The real optimization was in the design, not the implementation.

JPEG happens to encode each image independently using cosines, but you could
imagine a scenario where the encoder could refer to pieces of other images like
a kind of codebook. If it worked this way, its compression efficiency would be
largely dependent on the availability of applicable codebook entries, which in
turn would depend on how much it could change the original image (and this,
again, is a matter of optimizing the (problems solved) / (features) term).

By analogy, the same is mostly true of languages and libraries. A language
doesn't exist to compress every problem to its ideal structural truth, it
exists as a medium for people to build a large common codebook in the form of
shared libraries. The real world is just too noisy to be reliably compressible,
at least where end-users are concerned. And even when it is structurally
compressible, understandably few people are going to be interested in betting
their success on that proposition.

__
meta::post('2013.0814.bash-is-irrecoverably-broken', <<'__');
Bash is irrecoverably broken.
Everybody knows that bash is a little weird. The quoting shenanigans with
<code>$@</code> and <code>$*</code>, the horked local scoping rules, the
required whitespace around <code>[[</code> and <code>]]</code>, and a
handful of other oddities that make shell scripting feel like an adventure. And
these were things I was happy to put up with in exchange for its convenient
ubiquity and highly usable default settings.

That all changed this morning.

I was up early to work on <a
href='http://github.com/spencertipping/bake'>bake</a>, a build tool that
integrates with the shell environment. Bake maintains a table of variable
bindings and uses these repeatedly when solving the dependency graph, so I
wrote up some quick benchmarks to test various strategies for storing and
accessing it.

No problem, right? Bash has sparse arrays, global variables, and bash 4
introduces associative arrays. One way or another, we've got this covered. Ok,
so let's do a quick check to make sure the sparse-array support doesn't do
anything too crazy with access times:

| # setup xs to have 65536 elements, each one character long
  benchmarking local x=${xs[1024]}...
  user    0m0.234s
  user    0m0.237s
  user    0m0.234s
  user    0m0.241s
  benchmarking local x=${xs[16384]}...
  user    0m0.233s
  user    0m0.240s
  user    0m0.242s
  user    0m0.240s

Looks good! It doesn't seem to matter what the index is. So however bash is
doing arrays, it isn't doing anything crazy like a linear scan when we retrieve
stuff. Right?

  Arrays are linked lists.
  Wrong. Sparse arrays are implemented as linked lists in bash. To optimize the
  sequential access case, the array structure contains a stateful pointer to
  the last element accessed. We can see this behavior in a benchmark by
  requesting element 0 after element N:

  | benchmarking local x=${xs[1024]} y=${xs[0]}...
    user  0m0.347s
    user  0m0.353s
    user  0m0.349s
    user  0m0.350s
    benchmarking local x=${xs[16384]} y=${xs[0]}...
    user  0m1.175s
    user  0m1.183s
    user  0m1.189s
    user  0m1.182s

  A tragic lack of forethought on the part of the array implementer. But no
  matter; bash gives us at least two ways to access hash tables, so we can work
  around the problem that way.

  Hash tables are linked lists.
  Bash does not use hashtables as of version 4.2, and you should not use a
  hashtable written by anyone who tells you otherwise.

  Yes, you read that correctly. Every variable lookup, every associative array
  lookup, alias lookup, etc -- these are all linear-time scans through a linked
  list.

  In the bash source, there's a set of functions called
  <code>hash_create</code>, <code>hash_insert</code>, etc, that are
  unsurprisingly called whenever bash maintains a mapping from strings to other
  stuff like functions, variables, aliases, and such. And also unsurprisingly,
  there's a function that hashes strings by multiplying each character by a big
  prime number. So one might reasonably conclude that all this talk of hashes
  is about setting up a hash table for averaged constant-time access.

  That was probably the idea, anyway. But if you benchmark variable lookups,
  you'll observe a noticeable decline in performance as more of them are
  defined:

  | setting up 64 vars...
    real  0m0.004s
    user  0m0.004s
    sys   0m0.000s
    benchmarking local x=${xs_0} y=${xs_0}...
    user  0m0.260s
    user  0m0.259s
    user  0m0.258s
    user  0m0.259s

  | setting up 65536 vars...
    real  0m7.484s
    user  0m7.415s
    sys   0m0.071s
    benchmarking local x=${xs_0} y=${xs_0}...
    user  0m2.905s
    user  0m2.914s
    user  0m2.927s
    user  0m2.909s

  Let's give bash the benefit of the doubt here and say that maybe some of the
  later variables created some hash collisions (despite all being named
  <code>xs_i</code> for densely-distributed integers <code>i</code>). It isn't
  quite fair to compare a nearly-empty hashtable with a full one.

  | setting up 524288 vars...
    real  12m4.956s
    user  12m2.650s
    sys   0m2.090s
    benchmarking local x=${xs_0} y=${xs_0}...
    user  1m20.455s
    user  1m19.054s
    user  1m17.574s
    user  1m12.624s

  ZOMGWTF. Eight times as many variables, and a whopping 100x as long to set
  them up. 10x as long to access. And we're not swapping to disk or anything;
  this is all happening well within memory.

  Clearly this is no ordinary hashtable implementation. And indeed, here is the
  <code>hash_insert</code> function from the source (reformatted for brevity):

  | BUCKET_CONTENTS *
    hash_insert (string, table, flags)
         char *string;
         HASH_TABLE *table;
         int flags;
    {
      BUCKET_CONTENTS *item;
      int bucket;
      unsigned int hv;
      if (table == 0) table = hash_create (0);
      item = (flags & HASH_NOSRCH) ? (BUCKET_CONTENTS *)NULL
                   : hash_search (string, table, 0);
      if (item == 0)
        {
          bucket = HASH_BUCKET (string, table, hv);
          item = (BUCKET_CONTENTS *)xmalloc (sizeof (BUCKET_CONTENTS));
          item->next = table->bucket_array[bucket];
          table->bucket_array[bucket] = item;
          item->data = NULL;
          item->key = string;
          item->khash = hv;
          item->times_found = 0;
          table->nentries++;
        }
      return (item);
    }

  This all looks quite innocuous at first glance, but if you've ever written a
  hashtable you will quickly realize that something crucial is missing: <em>the
  bucket array is never resized</em>. Bash does us the service of maintaining
  an exact count of the number of items stored in the table, but at no point
  does it resize the array to maintain an average chain depth.

  Which, of course, is something of a problem as we start to add more entries.
  What it really means is that bash isn't using a proper hashtable at all;
  instead, it's just a fixed number of linked lists over which it will
  ultimately do linear scans. This explains why creating n variables takes
  n<sup>2</sup> time.

  Why this matters.
  You might be thinking, "look, it's a shell, who cares." I was tempted to
  think this too, and for most people it probably really doesn't matter. But
  the shell isn't just this thing you type commands into. It's your window into
  the system. It's a programming language that you're using to tell the
  computer what to do. And being able to extend your navigational context is
  enormously helpful. Bash, through its sloppy implementation, reduces the
  shell to just a command prompt and not much more.

  It's possible to overcome most kinds of limitations in one way or another.
  And I'm generally willing to go to some <a
  href='http://github.com/spencertipping/bash-lambda'>absurd lengths</a> to get
  something to work if it's sufficiently interesting. There are two kinds of
  problems, however, that force a hard stop. One is when you don't have enough
  computational expressiveness to do something, like trying to write Lisp in
  the C preprocessor. (You <a
  href='http://github.com/spencertipping/cpp-template-lisp'>can do it</a> with
  C++ template metaprogramming, but the C preprocessor isn't Turing-complete.)

  The other is when you hit a performance barrier with no workaround. If you
  can allocate memory and get to it in constant time, you can probably come up
  with some creative solution to a performance problem; but this all stops when
  your language has no constant-time data access.

  I guess it's time to switch to zsh:

  | if (++ht->ct >= ht->hsize * 2 && !ht->scan)
        expandhashtable(ht);

  Or maybe this will be enough motivation to write a shell. But either way,
  today is my last day using bash.

__
meta::post('2014.0804.why-i-left-factual', <<'__');
Why I left Factual.
<strong>Just kidding.</strong> I'm totally not leaving yet, and going strong
two years after starting here (this is a new record for duration of continuous
employment for me, by the way). If you're looking for a fun, mathy job in
Clojure, I highly recommend working here. Feel free to email me if you're
interested.

__
meta::retriever('bunzip2', <<'__');
# Allows you to transparently decompress stuff.
return undef unless exists $data{"bzip2::$_[0]"};
uncompress_data($data{"bzip2::$_[0]"});

__
meta::retriever('bzip2', <<'__');
# Allows you to put a bzip2:: prefix on something to specify that it should be compressed.
# This is useful when you want to retrieve plain stuff but assign into a packed attribute.

return undef unless $_[0] =~ /^bzip2::(.*)$/;
compress_data(retrieve($1));

__
meta::retriever('code-sdoc', <<'__');
# Lets you specify the SDoc extension manually. For instance:
# code.js::sdoc::foo causes sdoc::foo to be SDoc-rendered using Javascript comments.
my ($name) = @_;
return undef unless $name =~ s/^code\.(\w+)::// and defined retrieve($name);
sdoc($name, $1);

__
meta::retriever('file', '-f $_[0] ? file::read($_[0]) : undef;');
meta::retriever('global', <<'__');
# Returns the global data stashed at the end of this perl object
$_[0] eq 'self' ? $global_data : undef;

__
meta::retriever('html-sdoc', <<'__');
my ($attribute) = @_;
return undef unless $attribute =~ s/^html::/sdoc::/ and defined retrieve($attribute) || $attribute =~ s/^sdoc::// && defined retrieve($attribute);
sdoc_html($attribute);

__
meta::retriever('id', '$_[0] =~ /^id::/ ? substr($_[0], 4) : undef;');
meta::retriever('markdown-sdoc', <<'__');
my ($attribute) = @_;
return undef unless $attribute =~ s/^markdown::/sdoc::/ and defined retrieve($attribute) || $attribute =~ s/^sdoc::// && defined retrieve($attribute);
sdoc_markdown($attribute);

__
meta::retriever('object', <<'__');
# Fetch a property from another Perl object. This uses the 'cat' function.
return undef unless $_[0] =~ /^object::(.*?)::(.*)$/ && -x $1 && qx|$1 is '$2'|;
join '', qx|$1 cat '$2'|;

__
meta::retriever('perl', <<'__');
# Lets you use the result of evaluating some Perl expression
return undef unless $_[0] =~ /^perl::(.*)$/;
eval $1;

__
meta::retriever('pp', <<'__');
return undef unless namespace($_[0]) eq 'pp';
my $attr = retrieve(attribute($_[0]));
defined $attr ? preprocess($attr) : undef;
__
meta::retriever('sdoc', 'exists $data{"sdoc::$_[0]"} ? sdoc("sdoc::$_[0]") : undef;');
meta::retriever('sdocp', <<'__');
my $attribute = attribute($_[0]);
exists $data{"sdoc::$attribute"} ? sdocp("sdoc::$attribute") : undef;
__
meta::sdoc('header.html', <<'__');
<div><a href='http://twitter.com/spencertipping' aria-label='Twitter handle'>@spencertipping</a></div>
<div><a href='http://github.com/spencertipping' aria-label='Github profile'>github.com/spencertipping</a></div>
<div><a href='http://github.com/spencertipping/plain-blog'>Blog source</a></div>
<div><a href='http://spencertipping.com/zeroconsulting'>Zero-risk consulting</a></div>
<div><a href='http://spencertipping.com/feed.atom'>Atom feed</a></div>

<h3><label for='family'>Family</label></h3>
<ul id='family'>
<li><a href='http://joycetipping.com'>Joyce (my wife)</a></li>
<li><a href='http://adamtipping.com'>Adam (our son)</a></li>
</ul>

<h3><label for='projects'>Projects</label></h3>
<ul id='projects'>
<li><a href='http://github.com/spencertipping/cd'>cd</a></li>
<li><a href='http://github.com/spencertipping/perl-objects'>Self-modifying Perl</a></li>
<li><a href='http://github.com/spencertipping/flotsam'>Flotsam</a></li>
<li><a href='http://github.com/spencertipping/js-instabench'>Javascript Instabench</a></li>
<li><a href='http://spencertipping.com/cheloniidae'>Cheloniidae</a></li>
<li><a href='http://github.com/spencertipping/sdoc'>SDoc</a></li>
<li><a href='http://github.com/spencertipping/bash-prompt'>Bash prompt</a></li>
<li><a href='http://github.com/spencertipping/rather-insane-serialization'>Rather Insane Serialization</a></li>
<li><a href='http://github.com/spencertipping/infuse'>Infuse JS</a></li>
<li><a href='http://github.com/spencertipping/browserpower'>Browserpower</a></li>
<li><a href='http://github.com/spencertipping/perlquery'>Perlquery</a></li>
<li><a href='http://github.com/spencertipping/cheloniidae-live'>Cheloniidae Live</a></li>
</ul>

<h3><label for='moreprojects'>Misguided but fun</label></h3>
<ul id='moreprojects'>
<li><a href='http://github.com/spencertipping/canard'>Canard</a></li>
<li><a href='http://github.com/spencertipping/caterwaul'>Caterwaul JS</a></li>
<li><a href='http://github.com/spencertipping/bash-lambda'>Bash-lambda</a></li>
<li><a href='http://github.com/spencertipping/catastrophe'>Catastrophe</a></li>
<li><a href='http://github.com/spencertipping/mulholland'>Mulholland</a></li>
</ul>

<h3><label for='quizzes'>Web quizzes</label></h3>
<ul id='quizzes'>
<li><a href='http://spencertipping.com/pl-quiz.html'>Programming language quiz</a></li>
<li><a href='http://spencertipping.com/js-quiz.html'>Javascript quiz</a></li>
</ul>

<h3><label for='pdfs'>PDFs</label></h3>
<ul id='pdfs'>
<li><a href='http://github.com/spencertipping/js-in-ten-minutes'>Javascript in Ten Minutes</a></li>
<li><a href='http://github.com/spencertipping/writing-self-modifying-perl'>Writing Self-Modifying Perl</a></li>
<li><a href='http://github.com/spencertipping/git-in-ten-minutes'>Git in Ten Minutes</a></li>
<li><a href='http://caterwauljs.org/doc/caterwaul-by-example.pdf'>Caterwaul by Example</a></li>
<li><a href='http://caterwauljs.org/doc/caterwaul-reference-manual.pdf'>Caterwaul Reference Manual</a></li>
<li><a href='http://spencertipping.com/cheloniidae/cheloniidae.pdf'>Cheloniidae literate source</a></li>
<li><a href='http://spencertipping.com/mathbio2008/model.pdf'>MathBio model literate source</a></li>
</ul>

<h3><label for='jquery-modules'>jQuery modules</label></h3>
<ul id='jquery-modules'>
<li><a href='http://github.com/spencertipping/modus'>Modus (uses Caterwaul)</a></li>
<li><a href='http://github.com/spencertipping/jquery.instavalidate'>Instavalidate</a></li>
<li><a href='http://github.com/spencertipping/jquery.gaussian'>Gaussian blur</a></li>
<li><a href='http://github.com/spencertipping/jquery.fix.clone'>clone() patch</a></li>
</ul>

<h3><label for='caterwaul-modules'>Caterwaul modules</label></h3>
<ul id='caterwaul-modules'>
<li><a href='http://github.com/spencertipping/caterwaul-bloom'>Bloom filters</a></li>
<li><a href='http://github.com/spencertipping/caterwaul-struct'>C struct binary I/O</a></li>
<li><a href='http://github.com/spencertipping/caterwaul-heap'>Heap</a></li>
<li><a href='http://github.com/spencertipping/caterwaul-numeric'>Vector math</a></li>
<li><a href='http://github.com/spencertipping/caterwaul-serialization'>Reference-safe serialization</a></li>
<li><a href='http://github.com/spencertipping/caterwaul-regexp'>Regular expression parser</a></li>
<li><a href='http://github.com/spencertipping/caterwaul-parser'>Nonlinear parser combinators</a></li>
<li><a href='http://github.com/spencertipping/caterwaul-invariant'>Invariant state propagation</a></li>
<li><a href='http://github.com/spencertipping/caterwaul-futures'>Future monad</a></li>
<li><a href='http://github.com/spencertipping/caterwaul-factory'>Value production combinators</a></li>
<li><a href='http://github.com/spencertipping/caterwaul-jquery-node'>Headless jQuery renderer</a></li>
</ul>

<h3><label for='college-projects'>College projects</label></h3>
<ul id='college-projects'>
<li><a href='http://github.com/spencertipping/mathbio2008'>MathBio summer research (2008)</a></li>
<li><a href='http://github.com/spencertipping/mcm2007'>MAA Mathematical contest in modeling (2007)</a></li>
</ul>

<h3><label for='questionable-ideas'>Questionable Ideas</label></h3>
<ul id='questionable-ideas'>
<li><a href='http://github.com/spencertipping/cpp-template-lisp'>Lisp in C++ templates</a></li>
<li><a href='http://github.com/spencertipping/caterwaul-ext4'>Caterwaul ext4 filesystem driver</a></li>
<li><a href='http://github.com/spencertipping/caterwaul-ruby'>Caterwaul Ruby syntax module</a></li>
<li><a href='http://github.com/spencertipping/caterwaul-terminal'>Caterwaul ANSI terminal module</a></li>
<li><a href='http://github.com/spencertipping/caterwaul-reflection'>Caterwaul deep reflection module</a></li>
<li><a href='http://github.com/spencertipping/caterwaul.hlasm'>Caterwaul 0.x high-level assembler</a></li>
<li><a href='http://github.com/spencertipping/caterwaul.llasm'>Caterwaul 0.x low-level assembler</a></li>
<li><a href='http://github.com/spencertipping/rift'>Rift Ruby VM</a></li>
<li><a href='http://github.com/spencertipping/delimited-continuations-in-scheme'>Delimited continuations in Scheme</a></li>
<li><a href='http://github.com/spencertipping/instaserver'>Instaserver</a></li>
<li><a href='http://github.com/spencertipping/havoc'>Havoc programming language</a></li>
<li><a href='http://github.com/spencertipping/node-runabuf'>node.js run-a-buf</a></li>
<li><a href='http://github.com/spencertipping/js-typeclasses'>Javascript dynamic typeclasses</a></li>
</ul>

<h3><label for='epic-failures'>Epic Failures</label></h3>
<ul id='epic-failures'>
<li><a href='http://github.com/spencertipping/caterwaul-hijack'>Caterwaul parser hijack module</a></li>
<li><a href='http://github.com/spencertipping/caterwaul-c'>Caterwaul C syntax module</a></li>
<li><a href='http://github.com/spencertipping/divergence'>Divergence</a></li>
<li><a href='http://github.com/spencertipping/divergence.rebase'>Divergence Rebase</a></li>
<li><a href='http://github.com/spencertipping/gnarly'>Gnarly programming language</a></li>
<li><a href='http://github.com/spencertipping/figment'>Figment programming language</a></li>
<li><a href='http://github.com/spencertipping/montenegro'>Montenegro</a></li>
</ul>

__
meta::sdoc('page.html', <<'__');
<!doctype html>
<html>
<head>
<meta charset='utf-8'/>
<style>
- include style.css
</style>
<link rel='alternate' href='feed.atom' type='application/atom+xml' title='Atom feed'/>
</head>
<body>
<div id='header' role='banner'>
- include pp::header.html
</div>

<div id='contents' role='main'>
Page contents go here
</div>
</body>
</html>

__
meta::sdoc('posts.html', <<'__');
- include-post 2014.0804 why-i-left-factual
- include-post 2013.0814 bash-is-irrecoverably-broken
- include-post 2013.0713 compressing-the-requirements
- include-post 2013.0327 why-caterwaul-sucks
- include-post 2012.1201 selling-go
- include-post 2012.1129 an-apology
- include-post 2012.0819 clojure-metadata
- include-post 2012.0620 text-mode-is-awesome
- include-post 2012.0611 how-modus-works
- include-post 2012.0610 the-user-is-a-thread
- include-post 2012.0601 an-open-source-life
- include-post 2012.0601 the-market-inefficiency-factor
- include-post 2012.0530 why-i-left-google
- include-post 2012.0527 developer-machines-should-suck
- include-post 2012.0522 flat-mapping-function-arguments
- include-post 2012.0513 selection-bias-in-new-technologies
- include-post 2012.0508 the-programming-language-quiz
- include-post 2012.0416 goto-isnt-evil
- include-post 2012.0411 the-box-problem
- include-post 2012.0403 zero-risk-consulting
- include-post 2012.0401 why-microbenchmarks-are-misleading
- include-post 2012.0327 pure-functions-dont-exist
- include-post 2012.0323 solving-the-wrong-problem
- include-post 2012.0319 the-value-of-heuristics
- include-post 2012.0315 too-little-structure
- include-post 2012.0312 type-theory-considered-distracting
- include-post 2012.0310 becoming-a-dad
- include-post 2012.0307 developing-without-unit-tests
- include-post 2012.0302 a-caterwaul-bug
- include-post 2012.0229 performance-as-a-side-effect
- include-post 2012.0226 indirect-jumps-in-gnu-assembler
- include-post 2012.0222 the-wrong-tool
- include-post 2012.0222 perfection-is-irrecoverable
- include-post 2012.0217 syntax-as-a-constraint
- include-post 2012.0215 software-reliability
- include-post 2012.0209 not-invented-here
- include-post 2012.0207 occams-razor
- include-post 2012.0205 great-abstractions

__
meta::sdoc('quiz-readme', <<'__');
WARNING! HERE THERE BE SPOILERS.
This directory contains the original source code for the quiz pages, in case you're curious about how they're put together or how the answers are structured. These files are waul-compiled
together with the stuff in ../deps/, and the result is dropped into a giant Javascript block in the generated webpages.

Don't read the files in this directory unless you want to know the answers to the quizzes!

__
meta::sdoc('style.css', <<'__');
Blog stylesheet | Spencer Tipping
Licensed under the terms of the MIT source code license

body {font-family: 'Sans', sans-serif; font-size: 9pt; line-height: 1.44em; margin: 0 auto; max-width: 80ex}

a {color: #35a; text-decoration: none}
a:hover {text-decoration: underline}
a:visited {color: #89a}

#header {position: absolute; right: 0; top: 0; padding: 10px; text-align: right; font-size: 8pt}
#header h3 {font-size: 8pt; font-weight: normal}
#header ul {list-style-type: none}

#contents {padding: 10px 0}
#contents h1, #contents h2, #contents h3, #contents h4 {font-weight: normal; font-size: 14pt; text-transform: lowercase; margin: 0; padding: 10px 0}
#contents h2 {font-size: 10pt; color: #000; text-transform: uppercase}
#contents h3 {font-size: 10pt; color: #444; text-transform: uppercase} #contents h3:before {content: '> '; color: #888}
#contents h4 {font-size: 10pt; color: #888; text-transform: uppercase} #contents h4:before {content: '> '; color: #ccc}

#contents em {color: #444}

#contents .date      {color: #888; font-size: 10pt; font-family: 'Droid Sans Mono', 'Monospace', 'Liberation Mono', monospace; float: right; margin-top: 1em}
#contents .permalink {font-size: 10pt; float: right; margin-top: 1em}
#contents .permalink a {color: #888}
#contents .permalink a:after {color: #ccc; content: '|'}

td, th {text-align: right; border-right: solid 1px #ccc}

__
meta::spage('zeroconsulting', <<'__');
Zero-risk consulting.
It's hard to figure out whether someone is well-suited to a given project. As a result, committing to an employee, contractor, or consultant is often an expensive and risky venture. This is
why I'm trying a new kind of consulting. The idea is to make it easy for you to hire me without assuming most of the usual risks.

  How it works.
  You <a href='mailto:spencer@spencertipping.com'>email me</a> with a problem you'd like me to solve. (Be sure to put "zero" in the subject so that my email filter catches it.) This could be
  anything: a debugging project, advice about something, a library you need, end-user code, etc. Anything you send me is confidential. I'll then follow up with you with any additional
  information I need and any initial impressions I have.

  I will then try to implement a solution <strong>and will never send you a bill</strong>. I may or may not be able to implement something, depending on a variety of factors including my skill
  set. If I'm successful, I'll send you what I come up with. You may, at your option, pay me whatever you think my solution is worth. It's fine if this is nothing at all; that's useful
  information for me (I won't nag you about it, for instance).

  Too good/strange to be true?.
  Give it a try! I'm interested to see how this works out. Worst case, I won't have a clue about what you're talking about and will be no help at all. But it doesn't cost you anything apart
  from the time required to send me an email.

  Why?.
  My goal in doing things this way is to find out what I'm best at. I want to discover which problems people are trying to solve and broaden my horizons, as well as build contacts and possibly
  long-term involvement with certain projects.

  Caveats.
  Because of the nature of this consulting service, this isn't something you'd want to use for projects with tight deadlines. I also may decline to solve a problem that for some reason doesn't
  fit well with my skill set or interests, or if I'm too busy to accept new projects. (I apologize in advance if this happens; as I learn more I'll put up information about which projects I'm
  most likely to succeed at.)

  I do my best to keep your information strictly confidential, but sometimes machines get hacked or stolen. It's probably best if you don't send me any trade secrets or other sensitive
  information, just in case.

__
meta::template('comment', '\'\';     # A mechanism for line or block comments.');
meta::template('eval', <<'__');
my $result = eval $_[0];
terminal::warning("Error during template evaluation: $@") if $@;
$result;
__
meta::template('failing_conditional', <<'__');
my ($commands)    = @_;
my $should_return = $commands =~ / if (.*)$/ && ! eval $1;
terminal::warning("eval of template condition failed: $@") if $@;
$should_return;
__
meta::template('include', <<'__');
my ($commands) = @_;
return '' if template::failing_conditional($commands);
join "\n", map retrieve($_), split /\s+/, $commands;
__
meta::template('include-post', <<'__');
my ($post_name) = @_;
my ($date, $name) = split /\s+/, $post_name;

my $contents = sdoc_html("post::$date.$name");

<<end;
<div id='post-$date-$name'>
  <span class='date'>$date</span>
  <span class='permalink'><a href='/posts/$date.$name.html'>permalink</a></span>
  $contents
</div>
end

__
meta::template('pinclude', <<'__');
# Just like the regular include, but makes sure to insert paragraph boundaries
# (this is required for SDoc to function properly).

my ($commands) = @_;
return '' if template::failing_conditional($commands);
my $text = join "\n\n", map retrieve($_), split /\s+/, $commands;
"\n\n$text\n\n";
__
meta::template('script-include', <<'__');
my ($name) = @_;
my $s      = 'script';
my $script = retrieve($name);
"<$s>\n$script\n</$s>";

__
meta::template('style-include', <<'__');
my ($name) = @_;
my $s      = 'style';
my $style  = retrieve($name);
"<$s>\n$style\n</$s>";

__
internal::main();

__DATA__
