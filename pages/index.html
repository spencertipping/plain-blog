<!doctype html>
<html>
<head>
<style>
/* Blog stylesheet | Spencer Tipping*/
/* Licensed under the terms of the MIT source code license*/

body {font-family: 'Sans', sans-serif; font-size: 9pt; line-height: 1.44em; margin: 0 auto; max-width: 70ex}

a {color: #35a; text-decoration: none}
a:hover {text-decoration: underline}
a:visited {color: #89a}

#header {position: absolute; right: 0; top: 0; padding: 10px; text-align: right; font-size: 8pt}
#header h3 {font-size: 8pt; font-weight: normal}
#header ul {list-style-type: none}

#contents {padding: 10px 0}
#contents h1, #contents h2, #contents h3, #contents h4 {font-weight: normal; font-size: 14pt; text-transform: lowercase; margin: 0; padding: 10px 0}
#contents h2 {font-size: 10pt; color: #000; text-transform: uppercase}
#contents h3 {font-size: 10pt; color: #444; text-transform: uppercase} #contents h3:before {content: '> '; color: #888}
#contents h4 {font-size: 10pt; color: #888; text-transform: uppercase} #contents h4:before {content: '> '; color: #ccc}

#contents em {color: #444}

#contents .date      {color: #888; font-size: 10pt; font-family: 'Droid Sans Mono', 'Monospace', 'Liberation Mono', monospace; float: right; margin-top: 1em}
#contents .permalink {font-size: 10pt; float: right; margin-top: 1em}
#contents .permalink a {color: #888}
#contents .permalink a:after {color: #ccc; content: '|'}

/* Generated by SDoc */

</style>
<link rel='alternate' href='feed.atom' type='application/atom+xml' title='Atom feed'/>
</head>
<body>
<div id='header' role='banner'>
<div><a target='_blank' href='http://twitter.com/spencertipping' aria-label='Twitter handle'>@spencertipping</a></div>
<div><a target='_blank' href='http://github.com/spencertipping' aria-label='Github profile'>github.com/spencertipping</a></div>
<div><a target='_blank' href='http://github.com/spencertipping/plain-blog'>Blog source</a></div>
<div><a target='_blank' href='http://spencertipping.com/zeroconsulting'>Zero-risk consulting</a></div>
<div><a href='http://spencertipping.com/feed.atom'>Atom feed</a></div>

<h3><label for='family'>Family</label></h3>
<ul id='family'>
<li><a target='_blank' href='http://joycetipping.com'>Joyce (my wife)</a></li>
<li><a target='_blank' href='http://adamtipping.com'>Adam (our son)</a></li>
</ul>

<h3><label for='projects'>Projects (descending by awesomeness)</label></h3>
<ul id='projects'>
<li><a target='_blank' href='http://github.com/spencertipping/caterwaul'>Caterwaul JS</a></li>
<li><a target='_blank' href='http://spencertipping.com/cheloniidae'>Cheloniidae</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/mulholland'>Mulholland</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/perl-objects'>Self-modifying Perl</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/catastrophe'>Catastrophe</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/sdoc'>SDoc</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/js-instabench'>Javascript Instabench</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/browserpower'>Browserpower</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/bash-prompt'>Bash prompt</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/perlquery'>Perlquery</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/rather-insane-serialization'>Rather Insane Serialization</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/cheloniidae-live'>Cheloniidae Live</a></li>
</ul>

<h3><label for='quizzes'>Web quizzes</label></h3>
<ul id='quizzes'>
<li><a target='_blank' href='http://spencertipping.com/pl-quiz.html'>Programming language quiz</a></li>
<li><a target='_blank' href='http://spencertipping.com/js-quiz.html'>Javascript quiz</a></li>
</ul>

<h3><label for='pdfs'>PDFs</label></h3>
<ul id='pdfs'>
<li><a target='_blank' href='http://github.com/spencertipping/js-in-ten-minutes'>Javascript in Ten Minutes</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/writing-self-modifying-perl'>Writing Self-Modifying Perl</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/git-in-ten-minutes'>Git in Ten Minutes</a></li>
<li><a target='_blank' href='http://caterwauljs.org/doc/caterwaul-by-example.pdf'>Caterwaul by Example</a></li>
<li><a target='_blank' href='http://caterwauljs.org/doc/caterwaul-reference-manual.pdf'>Caterwaul Reference Manual</a></li>
<li><a target='_blank' href='http://spencertipping.com/cheloniidae/cheloniidae.pdf'>Cheloniidae literate source</a></li>
<li><a target='_blank' href='http://spencertipping.com/mathbio2008/model.pdf'>MathBio model literate source</a></li>
</ul>

<h3><label for='jquery-modules'>jQuery modules</label></h3>
<ul id='jquery-modules'>
<li><a target='_blank' href='http://github.com/spencertipping/modus'>Modus (uses Caterwaul)</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/jquery.instavalidate'>Instavalidate</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/jquery.gaussian'>Gaussian blur</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/jquery.fix.clone'>clone() patch</a></li>
</ul>

<h3><label for='caterwaul-modules'>Caterwaul modules</label></h3>
<ul id='caterwaul-modules'>
<li><a target='_blank' href='http://github.com/spencertipping/caterwaul-bloom'>Bloom filters</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/caterwaul-struct'>C struct binary I/O</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/caterwaul-heap'>Heap</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/caterwaul-numeric'>Vector math</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/caterwaul-serialization'>Reference-safe serialization</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/caterwaul-regexp'>Regular expression parser</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/caterwaul-parser'>Nonlinear parser combinators</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/caterwaul-invariant'>Invariant state propagation</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/caterwaul-futures'>Future monad</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/caterwaul-factory'>Value production combinators</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/caterwaul-jquery-node'>Headless jQuery renderer</a></li>
</ul>

<h3><label for='shell-programs'>Shell programs</label></h3>
<ul id='shell-programs'>
<li><a target='_blank' href='http://github.com/spencertipping/lock'>Mutex</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/on'>Remote execution</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/fsh'>Functional shell scripts</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/git-puller'>Git puller</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/diskbench'>Disk benchmark</a></li>
</ul>

<h3><label for='college-projects'>College projects</label></h3>
<ul id='college-projects'>
<li><a target='_blank' href='http://github.com/spencertipping/mathbio2008'>MathBio summer research (2008)</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/mcm2007'>MAA Mathematical contest in modeling (2007)</a></li>
</ul>

<h3><label for='questionable-ideas'>Questionable Ideas</label></h3>
<ul id='questionable-ideas'>
<li><a target='_blank' href='http://github.com/spencertipping/caterwaul-ext4'>Caterwaul ext4 filesystem driver</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/caterwaul-ruby'>Caterwaul Ruby syntax module</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/caterwaul-terminal'>Caterwaul ANSI terminal module</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/caterwaul-reflection'>Caterwaul deep reflection module</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/caterwaul.hlasm'>Caterwaul 0.x high-level assembler</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/caterwaul.llasm'>Caterwaul 0.x low-level assembler</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/rift'>Rift Ruby VM</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/delimited-continuations-in-scheme'>Delimited continuations in Scheme</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/instaserver'>Instaserver</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/havoc'>Havoc programming language</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/node-runabuf'>node.js run-a-buf</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/js-typeclasses'>Javascript dynamic typeclasses</a></li>
</ul>

<h3><label for='epic-failures'>Epic Failures</label></h3>
<ul id='epic-failures'>
<li><a target='_blank' href='http://github.com/spencertipping/caterwaul-hijack'>Caterwaul parser hijack module</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/caterwaul-c'>Caterwaul C syntax module</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/divergence'>Divergence</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/divergence.rebase'>Divergence Rebase</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/gnarly'>Gnarly programming language</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/figment'>Figment programming language</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/montenegro'>Montenegro</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/cpp-template-lisp'>Lisp in C++ templates</a></li>
</ul>

<h3><label for='unmaintained'>Unmaintained</label></h3>
<ul id='unmaintained'>
<li><a target='_blank' href='http://github.com/spencertipping/kevlar'>Kevlar</a></li>
<li><a target='_blank' href='http://github.com/spencertipping/uml-machine'>User mode linux manager</a></li>
</ul>

<!-- Generated by SDoc -->

</div>

<div id='contents' role='main'>
<div id='post-2012.0620-text-mode-is-awesome'>
  <span class='date'>2012.0620</span>
  <span class='permalink'><a href='posts/2012.0620.text-mode-is-awesome.html'>permalink</a></span>
  <div class='section level1'>
  <h1>Text-mode is awesome</h1>
  <p>I recently tweeted that (text : GUI) :: (FP : OOP), and that Vim was a WYSIWYG
version of Ed. I've been thinking a lot about how UIs are structured, more
computationally than visually, so I'm interested in analogies like these. This
post is a rambling collection of thoughts around the philosophical differences
between text and GUIs.</p>
  <div class='section level2'>
    <h2>The obligatory anecdote</h2>
    <p>  I <a href='http://en.wikipedia.org/wiki/Wikipedia:Database_download'
  target='_blank'>downloaded Wikipedia</a> the other day. Now I've got 8GB of
  bzipped XML that I need to unpack and index into articles so I can pull them
  up in <code>less</code> or <code>vim</code>. I wanted to see how the XML was
  structured, so I did this:</p>
    <pre class='quoted'>$ bzcat wikipedia.xml.bz2 | less</pre>
    <p>  And magically, everything Just Worked (keep in mind that I'm using a
  two-year-old netbook with 1GB of memory). No swapping to disk. No significant
  delay at all. And, remarkably, no CPU usage until I scrolled or searched the
  document. I saw the first screenful of XML in well under a second.</p>
    <p>  UNIX/Linux users, will, of course, not be at all surprised by this because the
  pipe has worked this way since the Middle Ages. But a large segment of the
  computing world doesn't have the ability to slice 8GB of data so elegantly.
  For example, suppose the Wikipedia data were stored in 34GB of HTML, similarly
  bzipped, and we wanted to view it in a browser. No problem, we'll just do
  this:</p>
    <pre class='quoted'>$ bunzip2 wikipedia.html.bz2 &amp;      # Or worse, use WinZIP :)
$ google-chrome ./wikipedia.html</pre>
    <p>  Aside from the obvious issue that Chrome is likely to load the file faster
  than bunzip2 can provide data, there's a bigger problem lurking here. Suppose
  you've loaded up the first screenful of HTML. Does Chrome wait before reading
  the rest of the document?</p>
    <p>  Of course not. It can't, because HTML has no locality properties at all. You
  could easily put a script like this at the bottom:</p>
    <pre class='quoted'>&lt;script&gt;document.body.innerHTML = ''&lt;/script&gt;</pre>
    <p>  The problem here is that the document has a mutable model with no spatial
  ordering of elements. The only way to accurately render the document is to
  load the whole thing into memory, run the scripts, and then render the subset
  of components that appear on the screen (which itself is no small task).</p>
    <p>  Put differently, a function from time to state, for any element in the
  document, is both Turing-complete and requires a complete model of the entire
  document.</p>
  </div>
  <div class='section level2'>
    <h2>FP and OOP</h2>
    <p>  FP generally emphasizes data transformations that are extrinsic to the data
  itself, and elements of data are generally immutable and unencapsulated. OOP
  tends towards the opposite: transformations are intrinsic, data is generally
  mutable, and state is hidden.</p>
    <p>  This difference is crucial to the function of shell pipes. Once
  <code>bunzip2</code> writes a byte to stdout, it has no way to change it or
  impact the state of that byte. All interpretation is left to the next process.</p>
    <p>  The real power comes from the way ASCII is interpreted. Text streams have a
  spatial ordering that, aside from ANSI escape codes and backspace characters,
  maps directly onto the order of bytes in the input. This wouldn't be true if
  ASCII also defined a 'previous-line' character (I'll call it <code>\p</code>).
  For example:</p>
    <pre class='quoted'>foo\nbar -&gt; foo
            bar</pre>
    <pre class='quoted'>foo\nbar\pbif -&gt; bif
                 bar</pre>
    <p>  The problem with <code>\p</code> is that it breaks the ordering. This forces
  interpreters like <code>less</code> to provide a mutable data model, which in
  turn requires them to load the entire input stream before displaying anything.</p>
  </div>
  <div class='section level2'>
    <h2>IO</h2>
    <p>  Since bytes have no intrinsic data transformations or hidden state, they have
  no identity; the byte <code>65</code> (capital A in ASCII) is the same
  regardless of whether it comes from a file, the network, or, importantly, the
  keyboard. This last point is where things get interesting.</p>
    <p>  Suppose you're doing stuff on the command line and get tired of repeating
  yourself. Maybe you're sending a series of requests to a webserver:</p>
    <pre class='quoted'>$ curl http://server/request1
$ curl http://server/request2
...</pre>
    <p>  It's insanely easy to store this process. You can just send your commands to a
  file rather than to a shell:</p>
    <pre class='quoted'>$ cat &gt; commands
curl http://server/request1
curl http://server/request2
...
^D</pre>
    <p>  Then you can replay them using a redirection:</p>
    <pre class='quoted'>$ bash &lt; commands</pre>
    <p>  Boring, right? We've seen all this already. Okay, so why can't we do the same
  thing with a web browser?</p>
    <p>  The obvious answer is that we could, it would just involve replaying a series
  of browser-generated events. But with sites doing A/B testing and what-not,
  those events wouldn't necessarily mean the same thing. A click could go to the
  wrong place if the layout changed even by a few pixels.</p>
    <p>  The real problem is that the events themselves contain implicit ties to the
  DOM state, which I've mentioned requires a Turing-complete simulation and is
  not fully initialized until all of the data has been read. Events are
  generated by an implementation-specific process, and because the model has
  hidden state it is unclear how much data will be required to emulate it.</p>
    <p>  By the way, you can always get to a DOM-style model for text. All you have to
  do is start piping things into <code>ed</code>. At that point you'll have an
  in-memory representation of the document so that you can use random access,
  mutation, and other features that aren't normally supported by the streaming
  pattern. The advantage of this is that you can then export the result back to
  a stream and continue using the same old tools.</p>
  </div>
  <div class='section level2'>
    <h2>Programming languages</h2>
    <p>  Strangely enough, I think the philosophy behind FP is better represented by
  shell programming than it is by functional programming languages. FP languages
  still have a number of strange quirks, most notably that you can't generally
  serialize values even though technically every value is anonymous. The reasons
  for this tend to be arcane -- stuff like holding references to opaque
  structures within the language runtime -- but still relevant for real-world
  use.</p>
    <p>  The UNIX command-line toolset is remarkably analogous to functional
  programming in any case. For example:</p>
    <pre class='quoted'>grep 'pattern' file         -&gt; filter f xs
head -n100 file             -&gt; take 100 xs
tail -n100 file     sort of -&gt; drop n xs</pre>
    <p>  The similarity goes beyond commands; data structures are also modeled:</p>
    <pre class='quoted'>mkdir foo                   -&gt; foo = {}
echo bif &gt; foo/bar          -&gt; foo['bar'] = ['bif']
echo baz &gt;&gt; foo/bar         -&gt; foo['bar'].push('baz')</pre>
    <p>  Conveniently, newlines give us seamless Perl-style lists with associative
  consing. That is, a scalar (a one-line file) is just a one-element array (a
  many-line file). This means that files generalize a couple of different
  monads (<code>Maybe</code> and <code>List</code> are the ones that come to
  mind) and allow us to freely convert between them since the types are erased
  by the time we use the data.</p>
  </div>
  <div class='section level2'>
    <h2>The image</h2>
    <p>  Continuing the now off-topic tangent, I'd like to point out that an image of a
  hard disk is, as its name suggests, an image. And Bash is, as its name sort of
  suggests, a REPL, which is a kind of shell.</p>
    <p>  Therefore, using a shell to modify a hard disk image when writing software is
  very similar to using a REPL to modify an image file, something you might do
  in Smalltalk or Lisp. A lot of developers are understandably leery of this
  paradigm because it's hard to see what has been defined, diffing is difficult,
  etc. In general I would argue that the UNIX image and REPL are much more
  powerful and functional than the REPLs offered by other languages -- that
  could be why we're willing to work with it but unwilling to use other
  image-based systems. But the analogy is still there, and the power of a
  self-modifying image is sufficient that nobody edits a disk image from the
  outside anymore.</p>
  </div>
  <div class='section level2'>
    <h2>Complexity</h2>
    <p>  Last sub-point. UNIX command-line tools are small and have very few bugs,
  graphical programs are large and have many more bugs. This echoes the claims
  made by FP advocates that functional code is simpler to write and maintain.
  The 200+ megabyte Haskell installation is not a great testament to this point,
  but the difference between Chrome (70MB) and <code>less</code> (151KB) could
  be, depending on how you interpret it.
</p>
  </div>
</div>
</div>

<div id='post-2012.0611-how-modus-works'>
  <span class='date'>2012.0611</span>
  <span class='permalink'><a href='posts/2012.0611.how-modus-works.html'>permalink</a></span>
  <div class='section level1'>
  <h1>How Modus works</h1>
  <p><a href='http://github.com/spencertipping/modus' target='_blank'>Modus</a> is a project I started a while ago and have largely left unmaintained. The idea was to let you use jQuery in
higher-order ways on lists or other structures of components. The canonical example is something like name/email:</p>
  <pre class='quoted'>&lt;div class='person' id='person1'&gt;
  &lt;input class='name'&gt;&lt;input class='email'&gt;
&lt;/div&gt;</pre>
  <p>Given the above HTML, you could use Modus like this:</p>
  <pre class='quoted'>$('.person').modus('composite', {name: '.name', email: '.email'});
$('#person1').val()   // -&gt; {name:  $('#person1 .name').val(),
                             email: $('#person1 .email').val()}</pre>
  <p>This morning I received an email from someone who is using Modus in production, asking for a line-by-line explanation of the source code. This is actually a great opportunity to explain some
things about what Caterwaul is doing, so here goes:</p>
  <p>First, Modus is written in Caterwaul, not Javascript. It ultimately gets compiled into Javascript, but <code>modus.waul.sdoc</code> is the human-readable source code and <code>modus.js</code>
is the unreadable Caterwaul output. <a href='http://github.com/spencertipping/sdoc' target='_blank'>SDoc</a> is a documentation format I wrote that basically auto-comments any paragraphs
beginning with an uppercase letter or pipe symbol. <code>waul</code>, the Caterwaul precompiler, understands SDoc syntax if the file ends in <code>.sdoc</code>.</p>
  <p>OK, so with that out of the way, here's the code (also <a href='http://github.com/spencertipping/modus/blob/master/modus.waul.sdoc' target='_blank'>on Github</a>), snippet by snippet:</p>
  <pre class='quoted'>caterwaul.module('modus', 'js_all', function ($) {</pre>
  <p>This defines a Caterwaul module transformed under the <code>js_all</code> set of macros. <code>js_all</code> includes all of the client/server-agnostic JS macros, but not
<code>jquery[]</code>. (We don't need <code>jquery</code> here because we don't create DOM nodes.)</p>
  <p>There are two reasons we create a module. First, it's one of the forms that <code>waul</code> understands. Technically, <code>waul</code> is doing something that isn't possible: it's
predicting the outcome of executing a bunch of Javascript and doing some work beforehand. The only reason this works is that it recognizes a few different toplevel forms and treats them
specially. The result is that any precompilable Caterwaul module is generally defined in its own file and starts with something like the module definition above.</p>
  <p>The second reason to define a module is that it will become a part of Caterwaul's replica if you end up calling <code>.replicate()</code>. Most people will never have a reason to do this.</p>
  <pre class='quoted'>$ = jQuery;</pre>
  <p>Obvious enough; we don't need the <code>$</code> reference that Caterwaul gives us, so we replace it with <code>jQuery</code>. Notice that this also gives us the shorthand <code>$ =
jQuery</code>, which is not true by default if the user has called <code>noConflict</code>.</p>
  <pre class='quoted'>var original_jquery_val = $.fn.val;
$.fn.val(args = arguments) = ...;</pre>
  <p>We're replacing jQuery's <code>val</code> method, so we need to first store the original and then redefine it. The second line uses Caterwaul's function definition syntax, which lets us bind
local variables:</p>
  <pre class='quoted'>f(x) = x + 1          // -&gt; f = function (x) {return x + 1}
f(x = 5) = x + 1      // -&gt; f = function () {
                                  var x = 5;
                                  return x + 1;
                                }</pre>
  <p>We need to store <code>arguments</code> because Caterwaul generates sub-functions for certain things, including the <code>-re</code> macro. If in doubt, always store the arguments. Here's the
actual function we're using to replace the original <code>val</code>:</p>
  <pre class='quoted'>$.fn.val(args = arguments) =
  this.data('modus') -re [it
    ? args.length ? it.setter.apply(this, args)
                  : it.getter.call(this)
    : original_jquery_val.apply(this, args)];</pre>
  <p>We're checking to see whether the current DOM node defines a <code>modus</code> data attribute; if it does, we use the getter and setter from that instead of the regular jQuery
<code>val</code>. Otherwise we use the original jQuery <code>val</code> function that we stored earlier. The <code>args.length</code> stuff is similar to jQuery's logic to use <code>val</code>
as both a getter and a setter:</p>
  <pre class='quoted'>myElement.val('foo')  // setter
myElement.val()       // getter</pre>
  <p>Modus takes care of this for you as a matter of convenience. The next bit of code is a little strange:</p>
  <pre class='quoted'>$.fn.modus(getter, setter) =
  getter.constructor === String
    ? use_named_combinator(this, arguments)
    : this.data('modus', {getter: getter, setter: setter}),
where [use_named_combinator(receiver, args) =
         $.modus[args[0]].apply(receiver,
                                Array.prototype.slice.call(args, 1))]</pre>
  <p>First I should point out that there are two <code>modus</code> objects. One is the method that is present on each jQuery collection; this is used to set up behavior for the elements in that
collection. The other <code>modus</code> is a global object on jQuery; this stores predefined behaviors that can be used later on (<code>list</code> and <code>composite</code> are two such
examples).</p>
  <p>With that said, the <code>$.fn.modus</code> method checks to see whether you're specifying the getter/setter functions as functions or in some other format. If <code>getter</code> is a string,
then it assumes you want to use a predefined behavior; otherwise it assumes you want to set the element's getter and setter directly. Predefined behaviors are expected to be defined as
attributes on the global <code>$.modus</code>, which we'll see more of in a moment.</p>
  <pre class='quoted'>$.modus = capture [
  util = {},</pre>
  <p>Here's where we set up the global <code>$.modus</code> object that ultimately will contain some useful element behaviors. <code>capture[]</code> is a macro that lets you use function
assignment syntax to initialize object key/value pairs:</p>
  <pre class='quoted'>capture [foo() = bar]   // -&gt; {foo: function () {return bar}}</pre>
  <p>I don't remember what I was using <code>util</code> for. There are three behaviors that come with Modus out of the box:</p>
  <div class='section level2'>
    <h2>Original val function</h2>
    <p>  This is not a behavior; it's just a utility function.</p>
    <pre class='quoted'>val() = original_jquery_val.apply(this, arguments),</pre>
    <p>  This is kind of subtle. Suppose you're writing a field that lower-cases its input using Modus. Here's how you might go about it at first:</p>
    <pre class='quoted'>$('.lowercase').modus(getter, setter)
-where [getter()  = this.val().toLowerCase(),
        setter(v) = this.val(v.toLowerCase())]</pre>
    <p>  The obvious problem here, however, is that you'll infinite-loop; <code>val</code> is a call to Modus, which will call your getter and setter functions all over again. What you want to do
  instead is use the original <code>val</code> from jQuery, which you can get to by asking Modus for it:</p>
    <pre class='quoted'>$('.lowercase').modus(getter, setter)
-where [getter()  = this.modus('val').toLowerCase(),
        setter(v) = this.modus('val', v.toLowerCase())]</pre>
  </div>
  <div class='section level2'>
    <h2>Delegate behavior</h2>
    <p>  This is where the behaviors start, and unfortunately with something of a hack.</p>
    <pre class='quoted'>delegate(getter, setter) = capture [
  first() = this,
  val()   = arguments.length
              ? getter.apply(this, arguments) -then- this
              : setter.apply(this, arguments)]</pre>
    <p>  This basically lets you assign one component's value to another one. You can imagine doing it for a single child:</p>
    <pre class='quoted'>&lt;div class='person-container'&gt;
  &lt;div class='person'&gt;
    ...
  &lt;/div&gt;
&lt;/div&gt;</pre>
    <p>  Here, you'd hook up <code>.person-container</code> to use the <code>val</code> function for <code>.person</code>:</p>
    <pre class='quoted'>$('.person-container').each(function () {
  var person = $(this).first('.person').data('modus');
  $(this).modus(person.getter, person.setter);
});</pre>
    <p>  I don't think I've ever used this behavior and can't remember why I wrote it in the first place.</p>
  </div>
  <div class='section level2'>
    <h2>List behavior</h2>
    <p>  This is the first combinator that is both useful and interesting. It constructs an array from the children of an element, and allows you to modify the children of an element by setting a new
  array of their values. The <code>new_element</code> constructor is used to convert from values to elements (more on this below).</p>
    <pre class='quoted'>list(new_element) = this.modus(
  "+this.children() *[$(x).val()] /seq".qf,
  "this.empty() -se- _ *![new_element(x).val(x) /!it.append] /seq".qf)</pre>
    <p>  This combinator is invoked when you write something like <code>element.modus('list', f)</code>. As you can see, it is setting up a getter and setter that close over the function you give it.
  In detail, here's what each one does.</p>
    <pre class='quoted'>"+this.children() *[$(x).val()] /seq".qf</pre>
    <p>  This is a closure that maps each child into its value. We start by grabbing the children of the Modus list, then using the prefix unary <code>+</code> to slice it into an <code>Array</code>
  instance (this is a <code>seq[]</code> macro feature). We then map (specified by <code>*</code>), and for every child element <code>x</code>, return <code>$(x).val()</code> -- thus
  retrieving the value. The result is bundled into an array that has the same ordering as the DOM nodes.</p>
    <pre class='quoted'>"this.empty() -se- _ *![new_element(x).val(x) /!it.append] /seq".qf</pre>
    <p>  This is the setter. First, we blow away all children in the node, since we're about to receive a new list. We then iterate through each new value (<code>*!</code>) and construct an element
  for it. There are a couple of things to notice here. First, <code>new_element</code> receives a copy of the value up-front. This helps you handle cases where there are several different
  value types that need different display elements (value polymorphism). Second, we then immediately set the value on the new component. This is more of a convenience than anything else; it
  just lets you omit a call to <code>.val()</code> on the new element if you want to simplify the <code>new_element</code> function.</p>
    <p>  Note that the <code>.qf</code> modifier on strings just builds a function out of the string's contents:</p>
    <pre class='quoted'>"_ + 1".qf  // -&gt; function (_) {return _ + 1}</pre>
    <p>  The other Caterwaul macro used here is <code>/!</code>, which is a way to wrap stuff into a function call while reducing the number of nested parentheses:</p>
    <pre class='quoted'>x /!f       // -&gt; f(x)
x /!o.f     // -&gt; o.f(x)</pre>
  </div>
  <div class='section level2'>
    <h2>Composite behavior</h2>
    <p>  This lets you map arbitrary descendants of elements to object keys. Unlike the list behavior, the composite behavior doesn't create or destroy elements; it just modifies the values of
  elements that are already in the DOM.</p>
    <pre class='quoted'>composite(paths) = this.modus(
  "paths %v* [find(this, x).first().val()] /seq".qf
  "paths %k*![find(this, paths[x]).first().val(_[x])] /seq /then.this".qf),
where [find(container, path) =
         path.constructor === String
           ? container.filter(path) /~add/ container.find(path)
           : path.constructor === Function
             ? path(container)
             : raise [new Error('invalid modus path: #{path}')]]</pre>
    <p>  Here, <code>paths</code> is an object that describes the name and location of each piece of the value. For example, consider a DOM container that looks like this:</p>
    <pre class='quoted'>&lt;div class='github-project'&gt;
  &lt;input class='name'&gt;
  &lt;input class='language'&gt;
  &lt;input class='branch'&gt;
&lt;/div&gt;</pre>
    <p>  We want an object that looks like <code>{name, language, branch}</code>. To get this, we just tell Modus which component each key corresponds to:</p>
    <pre class='quoted'>$('.github-project').modus('composite',
  {name:     'input.name',
   language: 'input.language',
   branch:   'input.branch'});
$('#my-project').val()      // -&gt; {name:     ...,
                                   language: ...,
                                   branch:   ...}</pre>
    <p>  Here's how the getter works:</p>
    <pre class='quoted'>"paths %v* [find(this, x).first().val()] /seq".qf</pre>
    <p>  We're doing a value-only map (<code>%v*</code> in the caterwaul <code>seq[]</code> library) over the <code>paths</code> object. This means that the object keys will remain the same, but
  we'll transform the values based on a map function. In this case, the values start out being paths and we're converting them to element values, which we do by first finding the component and
  then invoking the <code>val()</code> function. Notice, by the way, that we're not using the original jQuery <code>val</code>; we're using the Modus <code>val</code> method. This allows you
  to nest Modus components.</p>
    <p>  The setter is similar:</p>
    <pre class='quoted'>"paths %k*![find(this, paths[x]).first().val(_[x])] /seq /then.this".qf</pre>
    <p>  We're still going through the values in <code>paths</code>, but we need to hang onto the keys (using a for-each-key operation indicated by <code>%k*!</code>) so that we can grab the values
  of the value object we're setting, which is bound to the <code>_</code> variable by the <code>.qf</code> string modifier.</p>
    <p>  The most interesting part of the composite behavior is the <code>find</code> sub-function:</p>
    <pre class='quoted'>find(container, path) =
  path.constructor === String
    ? container.filter(path) /~add/ container.find(path)
    : path.constructor === Function
      ? path(container)
      : raise [new Error(...)]</pre>
    <p>  The goal here is to resolve a jQuery selector with respect to a container, but this is not as simple as you might expect. First, the user could specify a function instead of a string; that
  function is then called to return the sub-component. For example:</p>
    <pre class='quoted'>{name: function (container) {
         return container.find('.name');
       },
 language: '.language',
 ...}</pre>
    <p>  Second, the container itself could be a member of a multi-element collection that contributes to the value. (The second case is pathological and I'm not sure why I thought it mattered, but I
  decided to add it anyway.) To deal with this, we combine the <code>filter</code> output with the <code>find</code> output to make sure that we've included the containers themselves.</p>
    <p>  There are two new Caterwaul macros used in this section. One is <code>/~method/</code>, which works like this:</p>
    <pre class='quoted'>object /~method/ value      // -&gt; object.method(value)</pre>
    <p>  The other is <code>raise[]</code> which throws an error. This is useful because the <code>throw</code> keyword is illegal within an expression.</p>
    <p>  And that's it! Modus is just a combination of these few behaviors.
</p>
  </div>
</div>
</div>

<div id='post-2012.0610-the-user-is-a-thread'>
  <span class='date'>2012.0610</span>
  <span class='permalink'><a href='posts/2012.0610.the-user-is-a-thread.html'>permalink</a></span>
  <div class='section level1'>
  <h1>The user is a thread</h1>
  <p>Any user-facing program is by its nature multithreaded. The semantics aren't the usual ones, however. Things that happen within 30ms or so are atomic, since that's below the user's reaction
time. Anything else has the potential to create a race condition.</p>
  <p>If this line of reasoning is valid, it would mean that applications with inconsistent timing are buggy by default. (I would argue that this is the case.) UI code would be subject to the same
constraints as hard real-time code. Most applications certainly aren't written this way, and to some extent they can't be considering the presence of virtual memory, asynchronous garbage
collection, etc. But given the computational horsepower and otherwise compromised user experience of mobile devices, I think it's a promising area of focus.
</p>
</div>
</div>

<div id='post-2012.0601-an-open-source-life'>
  <span class='date'>2012.0601</span>
  <span class='permalink'><a href='posts/2012.0601.an-open-source-life.html'>permalink</a></span>
  <div class='section level1'>
  <h1>An open-source life</h1>
  <p>Wouldn't it be cool to be able to publish the "source code" of your life? From the outside, someone else's life choices are about as opaque as someone else's web server code. Nobody really
knows what kind of information goes in or out, or what the decision-making process looks like. All we see are the outputs of a black box.</p>
  <p>The real challenge behind implementing something like this probably isn't the sharing component. Twitter is full of accurate autobiographical information. I think the real challenge is having
a meaningful semantic structure behind it. This would enable searching for answers to life situations, or posing hypotheticals and simulating based on people similar to you.</p>
  <p>Life may be too chaotic for this to have any chance of being useful for prediction, but even if this is the case it would be interesting to see it fail.
</p>
</div>
</div>

<div id='post-2012.0601-the-market-inefficiency-factor'>
  <span class='date'>2012.0601</span>
  <span class='permalink'><a href='posts/2012.0601.the-market-inefficiency-factor.html'>permalink</a></span>
  <div class='section level1'>
  <h1>The market inefficiency factor</h1>
  <p>I was talking to a friend recently about the role of online advertising in market efficiency. On the one hand, it gives information to consumers and thus allows them to make more informed
decisions. But there's also a competition for consumer attention (a scarce resource), and a lot of ads aren't designed to help consumers make rational decisions.</p>
  <p>I thought about it some more and ended up coming to this generalization:</p>
  <pre class='quoted'>                    sales $
inefficiency = -----------------
               sales + product $</pre>
  <p>A completely inefficient market has no product at all; just sales. And a completely efficient market has no sales spending, just product development. We see occurrences of both. Currency
exchange markets are almost completely efficient; I don't think anybody runs ads that say things like, "The all-new 2012 Euro. Better and more luxurious than before." They don't need to
because the currency exchange market is largely automated, and money is so boring that emotional arguments for or against it are generally not useful.</p>
  <p>On the other side, you have things like lottery tickets. This market is almost completely inefficient; a lottery ticket is a mathematically-expected financial loss for the bearer. But
lotteries are surrounded by misleading advertising that appeals to people at an emotional level, omitting the only useful piece of information about the product itself. Whoever has the most
emotionally compelling advertising, regardless of the odds of winning, will sell the most lottery tickets.
</p>
</div>
</div>

<div id='post-2012.0530-why-i-left-google'>
  <span class='date'>2012.0530</span>
  <span class='permalink'><a href='posts/2012.0530.why-i-left-google.html'>permalink</a></span>
  <div class='section level1'>
  <h1>Why I left Google</h1>
  <p>This post is getting a lot more attention than I expected or hoped. I wrote it mostly for family and friends who know me well and who might be curious about it. So I need to address some stuff
to avoid saying the wrong thing.</p>
  <div class='section level2'>
    <h2>Responses to Hacker News comments</h2>
    <p>  <ul><li>Replies to DannyBee's comments
       <p>I think I've unintentionally misrepresented Google here. I'm not a lawyer or an expert, and I tried to play things safe and as much by the book as possible, since I didn't know what
          to expect. I did receive a reply about the project to the effect that it was in an area that Google was interested in, and it was a pleasant surprise when they allowed me to release
          the code and retain copyright. I'm not blaming anyone from the committee and I completely appreciate their efforts and reasonableness. The two-month complaint was a contrast from my
          previous job, where open-source software was easier to release. But I don't think Google was remotely unfair or unreasonable.</p></li>
      <li>"No mention seems to be made of how long Spencer was at Google"
       <p>I was there for a total of six months. A lot of people have said this is not enough time to get an accurate picture, and I think that's correct. A big part of why I left had to do
          with family events, and I was unsure about how well I would do considering my biases as a programmer.</p></li>
      <li>"[he basically said] 'if you don't adopt functional programming you are a loser'"
       <p>I'm biased about this. I don't think Google employs a bunch of losers. They're worth billions of dollars and I don't even own a house. My post isn't about what Google is or isn't,
          it's about the problems I faced based on my biases and perspective. I'm certainly not saying I'm right.</p></li>
      <li>"LinkedIn shows a series of jobs, each lasting less than one year"
       <p>My job history is choppy primarily because of choices I've made. I've been thinking about this a lot and haven't completely figured out why I've had so much trouble staying in one
          place. A lot of it comes down to perfectionism on my part, and the kind of impatient and relentless optimization that ultimately leads nowhere. For what it's worth, I've been in a
          professional career for three years since college, so I've got a lot to figure out. But that should also put this post into perspective; I'm not coming from a broadly informed
          viewpoint.</p></li>
      <li>"the Scala game of integrating every single academic PL research feature of the last 20 years"
       <p>I hate Scala with a passion, for what it's worth. I just wish there had been more advocacy for it.</p></li>
      <li>"directly counter to California law [about open source projects]"
       <p>Google isn't trying to be difficult here. The problem is that they do so much stuff that you're inevitably competing with something, or at least it's hard to rule that out. So to be
          safe, I ran every new project by the committee. They did a great job handling it, too. I just wish the latency had been a little lower. (First-world problems.)</p></li>
      <li>"Google's broken hiring process"
       <p>I think Google's hiring process is perhaps the most objective, well-considered, and effective I've ever seen. The stuff I'm complaining about is probably inevitable in a company this
          size, and like I stated a few times in the post itself, it really is an indictment of me, not them.</p></li>
      <li>"noobs are under the impression that HR somehow impacts employees"
       <p>Sorry, I should clarify. When I talk about HR, I'm talking about everything that wasn't related to coding. Vacation time and expense reimbursement, for example. The system was
          brilliant, easy to use, and efficient. I never felt like I was blocking on any kind of red tape.</p></li>
      <li>"Sounds like someone is a bit difficult to please."
       <p><strong>Yes!</strong> I don't even like a lot of the technology I write for myself, and I consider myself to be one of the most xenophobic and picky technologists I know. This is not
          Google's fault by any means.</p></li>
      <li>"Abstraction is discouraged" (I wrote this)
       <p>This is probably misleading. I'm talking about abstraction in the general sense; things like metaprogramming, etc. I'm not talking about anything like simple code duplication, which
          Google is very sensible about. Avoiding clever abstraction is why their engineers rarely kill each other. But I missed having a job where I could write code like this, so it acted as
          a Con in my decision process.</p></li></ul></p>
    <p>  Also, jrockway has provided an <a href='http://news.ycombinator.com/item?id=4051702' target='_blank'>excellent summary</a> from the other end. Seriously, read this if you want a thoughtful
  counterpoint.</p>
  </div>
  <div class='section level2'>
    <h2>Original post</h2>
    <p>  I resigned from Google about a month ago and have been meaning to write about it. It's always hard to sound grateful when describing why something didn't work out, but hopefully this comes
  across as more of an analysis of my own flaws than an indictment of Google. On the whole, they are an awesome company and I thoroughly enjoyed my time there.</p>
    <p>  Also keep in mind that I only saw the part of the company I was working with. Google is a huge place and a lot of my observations probably don't generalize at all.</p>
    <p>  From a highly subjective and local point of view, here are some of the key factors that influenced my decision. List items are in no particular order.</p>
  </div>
  <div class='section level2'>
    <h2>Technological culture</h2>
    <p>  This is by far the most important factor behind my decision about where to work, and it was ultimately the reason I ended up leaving. I think a lot of this has more to do with my biases than
  with any particular flaws in Google's technical process. Again, this is all from my point of view and isn't necessarily meant to be objective.</p>
    <p>  Pros:
  <ol><li>Total openness. I could read and contribute to the source code for almost any project.</li>
      <li>Well-engineered solutions to hard problems.</li>
      <li>Rigorous unit testing and attention to low-level code quality.</li>
      <li>Good developers had more influence than bad ones (Google employs some of each).</li>
      <li>Very reliable and solid infrastructure to help developers get their job done.</li>
      <li>Bugs and features were generally well-prioritized within the context of our project.</li>
      <li>20% is a real thing, and there are lots of opportunities to pursue cool projects. Mine involved machine learning, for example.</li>
      <li>Basically unlimited computing resources if you needed them.</li>
      <li>Good technological choices were valued and encouraged.</li></ol></p>
    <p>  Cons:
  <ol><li>Pathological love for Java and anything resembling Java.</li>
      <li>Little inclination to solve fundamental problems; most engineering effort spent on superficial implementation.</li>
      <li>Most engineers were not comfortable with {functional, concatenative, combinatory, logic, meta} programming.</li>
      <li>Therefore, most code was stateful and object-oriented, and no alternative design was seriously considered. [1]</li>
      <li>Coding standards and reviews prevented bad low-level decisions, but not bad high-level ones.</li>
      <li>Reviews preferred local simplicity over global simplicity; abstraction was discouraged.</li>
      <li>Internally-developed languages like Go and Dart failed to solve any significant problems. [2]</li>
      <li>UI programming was incredibly tedious due to GWT and its enterprise Java influence, and I as an engineer felt like I couldn't do anything to improve the situation. [3]</li>
      <li>Java was viewed as being "good enough"; alternatives like Scala and Clojure were not considered. [4]</li>
      <li>Insufficient code ownership for engineers to have a reason to write excellent code.</li>
      <li>Out-of-the-box thinking was often not useful.</li>
      <li>Productivity was graded without much regard to the amount of technological debt accrued. (Though to be fair, this is a hard problem.)</li>
      <li>The overhead of getting things done was often dominated by a complex API. Many internal APIs were excessively complex, in my opinion.</li>
      <li>High turnaround time for my own open-source projects. [5]</li>
      <li>Gratuitous boilerplate and complexity were widely accepted.</li></ol></p>
    <p>  Notes:
  <ol><li>I didn't mind the fact that they had chosen OOP for nearly everything. There are good reasons to do this. What bothered me was that a lot of people making these decisions didn't seem
          to have enough knowledge of alternatives to make well-informed choices from a strictly technological point of view. This probably reflects the conservative nature of a large company,
          but things like this detract from Google actually feeling like a startup.</li>
      <li><p>This didn't impact me directly, but I felt like it was symptomatic of a larger problem within Google's technological power structure. It also felt like a compromise for the
          wrong reasons; Google was nominally willing to solve hard problems, but even with people like Guido van Rossum and Rob Pike, they ended up backing out of implementing
          well-established, if not mainstream, PL research.</p>
          <p><strong>Update (June 4)</strong>: There's been an interesting discussion going on in <a href='http://groups.google.com/group/golang-nuts/browse_thread/thread/e2685a311dfeb3cc'
          target='_blank'>the Go Google group</a>, and I should clarify what I meant here. I'm not saying that Go is a bad language to use, like it's all the others in every way, etc. What I'm
          saying is that it gets its roots in concurrency from Erlang, a language that, in my opinion, did a better job of addressing concerns like shared-nothing even if in a
          less-than-performant way. Erlang also was designed from the ground up to be highly concurrent; immutability and such are baked into the language at a low level to make this work. I
          don't know a lot about Go, but from what I've seen, it appears to be a version of Erlang that made it about halfway to C and didn't really decide to stick to a particular mode of
          thought (e.g. shared-nothing actor model, shared-memory multitasking).</p>
          <p>Incidentally, Michael Jones has brilliantly captured the idea I'm talking about. Google has the intellectual firepower to be going where no programmer has gone before, yet
          languages like Go remain solidly in well-understood and, for the most part, commonly-implemented territory. I have no doubt that this is a good strategic move on Google's part, and
          that Go solves a number of important problems that Google faces, but I was disappointed that Google hadn't taken a more experimental and research-focused approach.</p></li>
      <li>Not all teams have this problem; some write their frontends in Javascript directly, which I imagine makes things nicer. But even the Javascript coding standards are rigid enough to
          preclude a lot of interesting metaprogramming opportunities otherwise afforded by the language.</li>
      <li>This is a personal bias and point of arrogance on my part. Java is "good enough" if you are a MegaCorp who hires mostly inexperienced college graduates; but Java is, by many
          standards, not a powerful language and not something that makes sense as a mandate for solid, experienced developers. Scala and Clojure each have significant design flaws, in my
          opinion, and neither would have been a significantly better choice. My objection is not that Google didn't choose one of these, but rather that it's symptomatic of a technological
          inertia that prevents new ideas from being adopted.</li>
      <li>This deserves some explanation. Technically, Google owns everything you write while you work there, even if it's on your own time and with your own equipment. However, they have a
          committee that reviews things you write and assigns copyright to you provided that they don't conflict with something Google is working on. My experiences working with this committee
          were completely positive, but there was often a two-month lag before I got an official reply from them. This uncertainty bothered me a lot, since I wasn't sure whether my project
          could be legally released as open source.</li></ol></p>
  </div>
  <div class='section level2'>
    <h2>Corporate culture</h2>
    <p>  This wasn't nearly as important to me as the technological culture, but it did still matter. This list is also subjective and may not accurately represent Google as a whole.</p>
    <p>  Pros:
  <ol><li>Efficient, well-managed HR system with minimal bureaucracy and red tape.</li>
      <li>Excellent managers, tech leads, and delegation of responsibility.</li>
      <li>Excellent salary, benefits, corporate policies, etc. I cannot emphasize this enough.</li>
      <li>"Don't be evil" was taken seriously at all levels of the company.</li>
      <li>Engineers were given everything required to be happy and do their jobs well.</li>
      <li>Top of the line hardware, and easy access to other devices.</li>
      <li>Frequent tech talks by guest and internal speakers, and about interesting subjects.</li>
      <li>You could leave your desk without anyone assuming you were slacking off.</li>
      <li>Minimal corporate politics, at least from where I was standing.</li>
      <li>Google employees were generally cool people. I can't think of anyone I didn't like.</li>
      <li>Low-stress, low-pressure work environment.</li>
      <li>No negative feedback from management or my team lead. All criticism was constructive, and I really had to ask for it to get any. [1]</li>
      <li>Every week, upper management answers (sometimes critical) questions from employees.</li>
      <li>I felt at ease talking to my manager and team lead about anything that was bothering me.</li>
      <li>It was common practice to make snarky memes, often about Google, and send them to other employees. Management snarks back.</li>
      <li>Google as a company has a great sense of humor.</li>
      <li>Developers could set their own schedule, modulo meetings.</li>
      <li>Performance reviews, interviews, and other evaluations were very objective and fair. I never observed any bias of any sort.</li>
      <li>User experience was a high priority.</li></ol></p>
    <p>  Cons:
  <ol><li>Google+. [2]</li>
      <li>Ubiquitous political emphasis on Google+ that sometimes compromised other engineering efforts.</li>
      <li>Products were not engineered with low-powered devices in mind. [3]</li>
      <li>Features outweighed the bugs that came with them. [4]</li>
      <li>Performance feedback was infrequent and vague.</li>
      <li>A lot of the maintenance I was doing produced a worse user experience, in my opinion. [5]</li>
      <li>"More wood behind fewer arrows."</li>
      <li>Much more formal than a startup (could also be a pro, but for me it was less fun).</li></ol></p>
    <p>  Notes:
  <ol><li>This isn't my way of saying, "look how awesome I am." I totally made my share of screw-ups. I think Google management is legitimately very cool about this stuff across the
          board.</li>
      <li>I think Google+ is an effort that does not deserve the engineering minds at Google. This is mostly a personal bias. I see Google as solving legitimately difficult technological
          problems, not doing stupid things like cloning Facebook. Google, in my opinion, lost sight of what was important when they went down this rabbit hole.</li>
      <li>This is a natural by-product of the combination of (1) dogfooding, and (2) giving engineers top-notch hardware. I think both of these practices are fine, but the problem could
          be addressed by issuing each engineer an underpowered netbook in addition to the insanely powerful machines we were given.</li>
      <li>I'm referring to a number of things, but I feel like Google's tolerance for bugs has gone way up since the early days of GMail. They have implemented more features, but the
          overall software quality is lower now in my opinion.</li>
      <li>This was a major downer for me. I thought the original Google UIs were simple, clean, and fast; the new ones felt clunky and buggy, and I felt like the attention to detail that went
          into the originals was lacking in our redesigns. The decisions behind this were primarily corporate-driven, not engineer-driven.</li></ol></p>
  </div>
  <div class='section level2'>
    <h2>Update</h2>
    <p>  Some people read this post and concluded that Google would be a bad choice for them. I think that's a definite possibility, but my advice would still be to apply and take a job if you're
  offered one. There are two reasons I think this makes sense.</p>
    <p>  First, you could be wrong. You might really love it. And if you do, it's probably one of the top five jobs you'll ever have. Enough brilliant programmers love working at Google that I think
  it's naive to dismiss this possibility too quickly.</p>
    <p>  Second, I doubt you'll come out having learned nothing. I learned a lot at Google and left mostly because I wanted to take the time to pursue stuff closer to my interests.
</p>
  </div>
</div>
</div>

<div id='post-2012.0527-developer-machines-should-suck'>
  <span class='date'>2012.0527</span>
  <span class='permalink'><a href='posts/2012.0527.developer-machines-should-suck.html'>permalink</a></span>
  <div class='section level1'>
  <h1>Developer machines should suck</h1>
  <p>I've been using an underpowered netbook for software development for the past four years, and it's one of the best things I've ever decided to do. The main reason is that any side-effects like
low performance or disk access become immediately visible. Google Chrome takes fifteen seconds to cold-start, for instance. I can run about eight tabs before the system begins swapping to
disk. Most web pages are CPU-bound (!) when rendering. (A significant part of this is the Intel Atom's lack of out-of-order execution and small L2 cache, I imagine.)</p>
  <p>Why would I advocate reducing developers to such a miserable existence? Because they're the ones who are responsible for creating that existence. It's possible to write fast software, but
stuff that crawls on a netbook will appear fast on the latest 8-core Mac with 12GB of DDR3 memory and SSD storage. All of those side-effects, which will probably have a noticeable impact on
80% of the users of the software, become invisible.
</p>
</div>
</div>

<div id='post-2012.0522-flat-mapping-function-arguments'>
  <span class='date'>2012.0522</span>
  <span class='permalink'><a href='posts/2012.0522.flat-mapping-function-arguments.html'>permalink</a></span>
  <div class='section level1'>
  <h1>Flat-mapping function arguments</h1>
  <p>I've been getting back into concatenative programming recently. One of the coolest things about it is the fact that you can erase values completely. Here's what I mean by that. Suppose you
want to write a <code>comment</code> function that lets you treat a string (or list, or anything else) as a code comment. You can't do it in most languages. Each expression has a continuation,
and each continuation takes a value. But you can easily do it in a stack language:</p>
  <pre class='quoted'>: comment drop ;              ( forth definition syntax )
"This is a comment!" comment</pre>
  <p>This works for an interesting reason. <code>drop</code> takes a value without returning anything. This is very different from C, which gives you the illusion of doing the same thing:</p>
  <pre class='quoted'>void comment(const char *x) {}
printf(comment("This isn't gonna work!"),
       "hello world\n");</pre>
  <p>Nothing comes out of a <code>void</code> function, but the infix syntax assumes that each expression returns a value of some sort. If it didn't, differentiating between unary negation and
binary subtraction would require type information.</p>
  <p>Intuitively, the difference seems like <code>map</code> vs <code>flatmap</code> over lists. The rule for <code>map</code> is that you need to transform each value; you can't just make one
disappear. <code>flatmap</code>, on the other hand, can be used to encode every other list operation including <code>map</code>, <code>filter</code>, etc. It also provides some nice
regularity. Here's the failure mode for applicative style:</p>
  <pre class='quoted'>(define (uncons c)
  (call/cc (lambda (return)
    (return (car c) (cdr c)))))
(cons (uncons (cons 3 4)))
;; error: too few arguments to [the outer] cons</pre>
  <p>However, this works just fine in concatenative style:</p>
  <pre class='quoted'>: uncons dup cdr swap car ;
3 4 cons uncons cons
</pre>
</div>
</div>

<div id='post-2012.0513-selection-bias-in-new-technologies'>
  <span class='date'>2012.0513</span>
  <span class='permalink'><a href='posts/2012.0513.selection-bias-in-new-technologies.html'>permalink</a></span>
  <div class='section level1'>
  <h1>Selection bias in new technologies</h1>
  <p>Each new thing that comes out seems to improve the state of technology. OOP "conquered complexity", FP "conquered buggy state", etc. Yet once enough people adopt a new paradigm, we start
seeing the same old problems pop up again; today's OOP is just as unmaintainable as yesterday's GOTO-laden spaghetti code.</p>
  <p>I think there's a selection bias that makes new technologies look artificially effective. Who adopts the latest unproven technologies? Probably enthusiasts, for the most part. Programmers who
are inherently curious about things. And it should come as no surprise that, on the average, a curious programmer is probably more effective than a non-curious one.</p>
  <p>The real test is whether the new technology holds up after it becomes mainstream.
</p>
</div>
</div>

<div id='post-2012.0508-the-programming-language-quiz'>
  <span class='date'>2012.0508</span>
  <span class='permalink'><a href='posts/2012.0508.the-programming-language-quiz.html'>permalink</a></span>
  <div class='section level1'>
  <h1>The programming language quiz</h1>
  <p>I've just written an impeccable measuring tool for useless knowledge. <a href='/pl-quiz.html' target='_blank'>The programming language quiz</a>.
</p>
</div>
</div>

<div id='post-2012.0416-goto-isnt-evil'>
  <span class='date'>2012.0416</span>
  <span class='permalink'><a href='posts/2012.0416.goto-isnt-evil.html'>permalink</a></span>
  <div class='section level1'>
  <h1>Goto isn't evil</h1>
  <p>Constructs which are easy to misuse are branded as evil, despite the fact that using them is generally a conscious decision. <code>goto</code> is the canonical example of this. Mutability is
another, in FP circles. Neither of these is in itself evil, but they become harmful when misused by incompetent programmers. Similarly, OOP and immutability aren't univeral solutions. Either
of these can be misused by similarly incompetent programmers to form codebases that are unmaintainable or impractical.</p>
  <p>By analogy, cars aren't evil despite the fact that careless misuse of them kills so many people. Nor are explosives, firearms, chainsaws, or any number of other things that end up hurting
people. They may be treacherous and dangerous, but such is the world we live in sometimes. (Programmers are no exception; look at Javascript.)</p>
  <p>Incompetence is the thing that's evil. Capable programmers make informed, responsible choices about how they implement things.
</p>
</div>
</div>

<div id='post-2012.0411-the-box-problem'>
  <span class='date'>2012.0411</span>
  <span class='permalink'><a href='posts/2012.0411.the-box-problem.html'>permalink</a></span>
  <div class='section level1'>
  <h1>The box problem</h1>
  <p><a href='http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&amp;lang=gpp&amp;lang2=java' target='_blank'>It can be argued</a> that Java and C++ have roughly comparable performance for
CPU-bound tasks. Yet Java is justifiably considered to be a much slower language than C++. What gives?</p>
  <p>Most programs aren't CPU-bound. <a href='http://www.bitc-lang.org/docs/papers/PLOS2006-shap.pdf' target='_blank'>They're IO-bound against memory.</a> An L2 cache miss is often estimated at 100
clock cycles. This <a target='_blank' href='http://agner.org/optimize/instruction_tables.pdf'>is comparable to two IDIV instructions on a fast 64-bit processor</a> (page 28). This delay is so
significant that processors can <a href='https://en.wikipedia.org/wiki/CPU_cache#CPU_stalls' target='_blank'>use HyperThreading to create virtual cores</a> just so that they have something to
do while waiting for data to load.</p>
  <p>In Java, objects are passed by-reference and primitive values are passed by-value. However, there's an important exception to this rule: A generic class with a type parameter always uses a
reference type. That is, <code>List&lt;Double></code> uses reference <code>double</code>s, also called "boxed" <code>double</code>s. Java avoids this representational overhead in certain cases by
providing primitive arrays, which store the values directly.</p>
  <p>Boxed values are a problem for four reasons:
<ol>
<li>Accesses to boxed values require an additional pointer dereference, which may miss the cache.</li>
<li>Allocating boxed values takes up a lot of additional space and therefore requires the GC to run more often.</li>
<li>Boxed values are additional entities that must be garbage-collected, so having many of them makes it slower to find the live set every time the GC runs. (Also, the GC will incur its own
    cache misses traversing them.)</li>
<li>In Java, changing a boxed value often involves allocating a new one and garbage-collecting the old one; changing a primitive value can be done in a single instruction.</li>
</ol></p>
  <p>Compilers generally optimize imperative instruction sequences but not data representation. Boxed values are generally an artifact of language or VM limitations, primarily due to the weak type
erasure semantics that most likely became mainstream with the introduction of object-oriented programming (they had been present in dynamically-typed languages for some time, however). Until
compilers get better at optimizing the way data structures are implemented in memory, there will be a strong case for using low-level languages when performance matters.
</p>
</div>
</div>

<div id='post-2012.0403-zero-risk-consulting'>
  <span class='date'>2012.0403</span>
  <span class='permalink'><a href='posts/2012.0403.zero-risk-consulting.html'>permalink</a></span>
  <div class='section level1'>
  <h1>Zero-risk consulting</h1>
  <p>I'm going to try something new. I have no idea how it will turn out. It occurs to me that there's probably a lot of risk associated with hiring people in various capacities: Full-time
employees are a very high risk, descending to contractors from managed places like eLance. But with any of these mechanisms, there's enough overhead that you generally don't have a market for
micro-work; that is, stuff that might benefit from a specialist but that only takes a few minutes.</p>
  <p>So my idea as it stands is to become a <a href='http://spencertipping.com/zeroconsulting' target='_blank'>zero-risk consultant</a>. <a href='mailto:spencer@spencertipping.com'>Let me know</a>
what you think.
</p>
</div>
</div>

<div id='post-2012.0401-why-microbenchmarks-are-misleading'>
  <span class='date'>2012.0401</span>
  <span class='permalink'><a href='posts/2012.0401.why-microbenchmarks-are-misleading.html'>permalink</a></span>
  <div class='section level1'>
  <h1>Why microbenchmarks are misleading</h1>
  <p>The <a href='http://shootout.alioth.debian.org' target='_blank'>Great Programming Language Shootout</a> contains a fairly prominent disclaimer that microbenchmarks are not an accurate measure
of real-world performance. The first time I read this, I remember thinking: "Why not? What about these applications isn't 'real-world'?"</p>
  <p>I think the problem isn't that microbenchmarks are somehow fake; they obviously solve very real problems. The real issue lies in the various processes used to write different kinds of
software. For example, suppose you're writing a gzip encoder. There's probably a known-optimal solution with a low instruction count and good cache locality, and which is known to maximize
performance across a wide range of architectures. And it's probably worth tuning the algorithm like this (maybe even per architecture) because gzip faces such a horizontal market.</p>
  <p>On the other hand, consider something like Eclipse. It is written in one of the fastest languages in the world, yet it is one of the slowest pieces of software I have ever used. Nothing about
what Eclipse is doing should take nearly as long as it does, but my guess is that the codebase is large and complex enough that effective optimization isn't realistic. Once code gets to be
that large, complexity precludes good optimization. The language's runtime performance is made irrelevant by high-level problems like ineffective multithreading, <a
href='http://www.cs.virginia.edu/kim/publicity/pldi09tutorials/memory-efficient-java-tutorial.pdf' target='_blank'>heavy indirection, and swapping to disk</a>.</p>
  <p>In other words, microbenchmarks are useful only when the language runtime is the limiting factor. Most real-world applications are limited by concerns like maintainability, good style,
sensible abstractions, short timelines, and developers who are not compiler experts. For these projects, the applicability of the language's paradigm to the problem will contribute more to
good performance than the vast majority of low-level runtime optimizations.
</p>
</div>
</div>

<div id='post-2012.0327-pure-functions-dont-exist'>
  <span class='date'>2012.0327</span>
  <span class='permalink'><a href='posts/2012.0327.pure-functions-dont-exist.html'>permalink</a></span>
  <div class='section level1'>
  <h1>Pure functions don't exist</h1>
  <p>State is evil. Such is what we are led to believe by functional programming devotees who justifiably value purity in code. And it continues: referential transparency is crucial, embrace pure
functions, use immutable data structures, etc.</p>
  <p>I don't have much of a problem with the philosophical values that motivate this. However, I think there is a particular brand of idiocy that has sprung up from the dogma. It is delusional to
claim that a function has no side-effects, or that pure-functional programming languages as they are implemented today even allow you to write such functions. Here's an example in Haskell:</p>
  <pre class='quoted'>-- Program 1: A pure function.
-- Load this up in ghci and evaluate 'identity 5'.
identity = id</pre>
  <pre class='quoted'>-- Program 2: A similarly pure function.
big_identity 0 = id
big_identity n = id . big_identity (n - 1)
identity = big_identity 100000000000000</pre>
  <p>The first program will quickly return 5. The second program will use up 100% of your CPU for a few seconds, then start swapping to disk, then die after it exhausts all of the available memory.
(I had to reboot because I couldn't interrupt the process due to swapping.) On the face of it, this is patently ridiculous; any human will tell you that it doesn't matter how many times you
compose the identity function onto itself, it remains the identity function. It's also not exactly obvious what this code is even doing; the identity function is defined not to <em>do</em>
anything at all.</p>
  <p>The real fallacy, I think, arises from the fact that time, memory usage, etc. are all side effects, and they can cause just as many bugs as excessive state-sharing in imperative code. At the
end of the day, the best way to eliminate undesirable side effects is probably to have a deep knowledge of what your compiler is doing. Abstraction, purity, and correctness don't absolve the
programmer from the responsibility of using a real CPU, real memory, and having real performance constraints.</p>
  <p>Put differently, languages don't eliminate undesirable side effects. You can easily write pure-functional C if you want to. Programmers eliminate undesirable side effects by making high-level
decisions about things that compilers are light-years away from understanding. Purity is a property of design, not implementation.
</p>
</div>
</div>

<div id='post-2012.0323-solving-the-wrong-problem'>
  <span class='date'>2012.0323</span>
  <span class='permalink'><a href='posts/2012.0323.solving-the-wrong-problem.html'>permalink</a></span>
  <div class='section level1'>
  <h1>Solving the wrong problem?</h1>
  <p>Source code is represented as text. On the face of it, this is a strange format to use; it requires complex parsing algorithms, makes it easy to write nonsensical statements, and introduces a
large layer of indirection when debugging. Yet I am unaware of any remotely palatable non-text programming environment.</p>
  <p>This, of course, bugs me. I would love to see text be replaced by something closer to a program's true representation. Yet more than fifty years after the development of the first programming
languages, we are still using text exclusively. Why?</p>
  <p>My guess is that the proposed solutions don't get at the real problem with using text to represent code. For example, structural solutions that I've seen (and I'm no expert, so I may be
overgeneralizing) have worse ergonomics than text, generally take up far more space to represent the same amount of information, and don't provide any particularly compelling advantage other
than constraining the programmer to known-valid constructs.</p>
  <p>What about a structural representation that did things differently? How about one which let the programmer move the code through invalid states, used less space than pure text, and had
superior ergonomics? Given the power of editors like vim and emacs, this may not be possible. And arguably it has already been achieved by IDEs like Eclipse.</p>
  <p>Put differently, maybe people like to communicate with computers like we communicate with other people: in writing. Just as we would never diagram our sentences as an alternative to speaking
or writing them, maybe it's unrealistic to expect programmers to explicitly state the structure of their code.
</p>
</div>
</div>

<div id='post-2012.0319-the-value-of-heuristics'>
  <span class='date'>2012.0319</span>
  <span class='permalink'><a href='posts/2012.0319.the-value-of-heuristics.html'>permalink</a></span>
  <div class='section level1'>
  <h1>The value of heuristics</h1>
  <p>Some problems don't have clean, elegant solutions. One example of this is object traversal in Javascript. I was working on a serialization library that crawled through a series of Javascript
objects, serializing each one and encoding the object graph as a series of references that could later be reconstructed. In order to do this, you need to be able to reliably mark each object
and be able to reverse-map objects to their IDs. And the catch is that Javascript only lets you use strings as object keys.</p>
  <p>The hard but correct way to do this is to keep an array of <code>[ID, object]</code> pairs that you could then search each time you encountered an object. But this is time-consuming; O(n^2)
overall. Better is to find some way to store the ID directly on each object. This can be done if you choose an extremely improbable name, like
<code>extremely_improbable_name_for_serialization_library</code>. But this approach breaks down once you want to serialize the source tree of your serializer (if you ever did want to do such a
thing), since the name is present verbatim.</p>
  <p>I ended up generating a pseudorandom name using at least 128 bits of entropy. This isn't too hard; Javascript identifier characters (A-Z, a-z, 0-9, $, _) encode 6 bits each, so 22 characters
contains 132 bits of information. I chose 128 because for a long time this was considered cryptographically secure; if you could guess someone's 128-bit key then you could see everything they
were saying to each other. Pseudorandom data isn't cryptographically secure, but it is difficult enough to predict that it seemed like a reasonable choice.</p>
  <p>The beauty of this solution is that it isn't correct, but it always works. If you can put an upper bound on the degree of pathology of your problem domain, then you don't have to implement
something that is universally functional; you just need to handle the most pathological case that comes your way.
</p>
</div>
</div>

<div id='post-2012.0315-too-little-structure'>
  <span class='date'>2012.0315</span>
  <span class='permalink'><a href='posts/2012.0315.too-little-structure.html'>permalink</a></span>
  <div class='section level1'>
  <h1>Too little structure</h1>
  <p>Caterwaul's parser and syntax trees are much looser than the Javascript language specification. I did this mostly out of laziness; it seemed simpler to write an ad-hoc parser and stick to
operator-precedence parsing as much as possible. It turns out that my laziness enabled a whole range of very cool stuff to be done. For example, caterwaul can parse expressions like this:</p>
  <pre class='quoted'>S[for (var L[i] = R[10]; R[i &lt; 10]) S[{_body}]]</pre>
  <p>This means that you can annotate arbitrary subtrees, including ones in statement mode (!), with markers and then pattern-match against those markers and their contents. Caterwaul has used this
for some time; the <code>seq</code> library uses it to descend through subtrees and parse out the sequence operators. And because the caterwaul parser handles all of the cases uniformly,
markers can be seamlessly integrated into <code>qs</code> and <code>qse</code> forms.</p>
  <p>The interesting thing about this is that I wouldn't have even thought of the marker approach had I been using a highly-structured parser and AST representation, and I would have worked harder
to write the parser and AST in the first place. So I've got a new approach: Write APIs with too little structure and fix it later.
</p>
</div>
</div>

<div id='post-2012.0312-type-theory-considered-distracting'>
  <span class='date'>2012.0312</span>
  <span class='permalink'><a href='posts/2012.0312.type-theory-considered-distracting.html'>permalink</a></span>
  <div class='section level1'>
  <h1>Type theory considered distracting</h1>
  <p>Assembly language is untyped. By the time you're writing assembly programs, all types have been erased into instruction patterns that happen to reflect the semantics of what you're doing. If
you're in a higher-level language, those semantics could even vary depending on runtime variants; the fixity of in-memory representation is, from what I can tell, primarily a historical nod to
low-level type erased languages that depend on it being a compile-time invariant. (And compacting garbage collectors loosen this restriction somewhat by making pointers opaque, so we're slowly
losing aspects of this codependency even in situations where it seems like it should be difficult.)</p>
  <p>C inherits its type system from the constraints of assembly language: Types were not particularly used to guarantee correctness or to prove complex compile-time invariants; rather, they
dictated the memory layout in a consistent way. And C has a desirable property because of this. All of its types can be erased at compile-time; there is no runtime type information. This isn't
always the fastest way to do things because of the overhead associated with x86 calling conventions and indirect jumps, but the type system arguably leaves off where it makes sense -- before
the program is run.</p>
  <p>Fast forward to the development of the JVM Hotspot compiler, which includes an impressive array of optimizations including <a href='http://en.wikipedia.org/wiki/Inline_caching'
target='_blank'>inline caching</a> that deal specifically with compile-time unknowns whose runtime impact is generally mitigated by heuristic observation. There isn't anything wrong with
heuristic optimization; generational GC, for instance, makes a tremendous amount of sense. But it's worth thinking a bit about the kinds of optimizations that <em>didn't</em> happen even when
they would be relatively trivial to implement.</p>
  <p>For example, loop invariant-analyzing compilers do not, to the best of my knowledge, hoist invariants across function boundaries, even when the function is provably monomorphic. This matters
in languages like Javascript; for example:</p>
  <pre class='quoted'>var process = function (data, x) {
  return (data instanceof Array ? f1 : f2)(data, x);
};
for (var i = 0; i &lt; xs.length; ++i)
  process(constant_array, xs[i]);</pre>
  <p>Here, <code>process</code> and <code>constant_array</code> are loop invariants, but even sophisticated compilers like V8 are unlikely to include an optimization step that inlines the loop body
into the single expression <code>f1(constant_array, xs[i])</code> even after executing it many times. However, if the dispatch were made implicit by using prototype methods, the inline cache
would kick in and provide a significant benefit.
</p>
</div>
</div>

<div id='post-2012.0310-becoming-a-dad'>
  <span class='date'>2012.0310</span>
  <span class='permalink'><a href='posts/2012.0310.becoming-a-dad.html'>permalink</a></span>
  <div class='section level1'>
  <h1>Becoming a dad</h1>
  <p><a href='http://adamtipping.com' target='_blank'>Adam Tipping</a> was born two days ago at about 8 in the morning. He's our first, so <a href='http://joycetipping.com'>Joyce</a> and I went
from a low-maintenance child-free existence to something totally different. I haven't thought much about technology since Adam was born, so for the next little while I'll post <a
href='http://adamtipping.com/sleeping.jpg' target='_blank'>cute baby pics</a> instead.
</p>
</div>
</div>

<div id='post-2012.0307-developing-without-unit-tests'>
  <span class='date'>2012.0307</span>
  <span class='permalink'><a href='posts/2012.0307.developing-without-unit-tests.html'>permalink</a></span>
  <div class='section level1'>
  <h1>Developing without unit tests</h1>
  <p>About a year ago I removed caterwaul's unit tests. Now it has only a large functional test: can it bootstrap-compile itself? I think the change has been really good for the project, all things
considered.</p>
  <p>Tests are a time investment. You hope that the effort you spend maintaining tests is less than the amount of effort you would spend debugging/fixing regressions that would have occurred
without them. Whether or not this is true depends on a few factors, a significant one of which is how quickly the project requirements change. Caterwaul's API doesn't change very often, but
its internals change more often.</p>
  <p>Unit tests are also protection against other developers. I deliberately wrote caterwaul to be difficult for other developers to modify so I wouldn't need to worry about this (and because
writing software this way is just more fun IMO). I'm convinced that team development has some significant game theory problems, and unit tests mitigate these problems to some extent.</p>
  <p>Finally, caterwaul has had some interesting philosophical changes since I removed unit tests. It has gotten simpler because I needed to keep it manageable. If I tried to write some
ill-defined, complex library, something would break somewhere and it would take a lot of time to fix. The result is that the code is roughly uniform in its distribution of fragility *
modification frequency.
</p>
</div>
</div>

<div id='post-2012.0302-a-caterwaul-bug'>
  <span class='date'>2012.0302</span>
  <span class='permalink'><a href='posts/2012.0302.a-caterwaul-bug.html'>permalink</a></span>
  <div class='section level1'>
  <h1>A Caterwaul bug</h1>
  <p>Not all bugs are created equal. They range from the stupidly obvious mistakes of late-night coding to the intriguingly subtle nonlocal consequences of reasonable design decisions. In my
experience, most bugs tend towards the obvious side of this scale. But sometimes I run into a legendary bit of pathology that is so convoluted or mysterious that it qualifies as a work of art.
Yesterday I was fortunate enough to encounter one of these in Caterwaul.</p>
  <p>I was a little worried about it because I had seen it happen at least once before and had no idea why. The symptom was that, for some input programs that made heavy use of syntax quotation,
<code>waul</code> would die with output similar to the following:</p>
  <pre class='quoted'>node.js:201
      throw e; // process.nextTick error, or 'error' event on first tick
            ^
TypeError: Object , has no method 'reach'
    at eval at &lt;anonymous&gt; (waul-1.2:140:119)
    at [object Object].each (eval at &lt;anonymous&gt; (waul-1.2:140:119))
    at [object Object].reach (eval at &lt;anonymous&gt; (waul-1.2:140:119))
    at eval at &lt;anonymous&gt; (waul-1.2:140:119)
    at [object Object].each (eval at &lt;anonymous&gt; (waul-1.2:140:119))
    at [object Object].reach (eval at &lt;anonymous&gt; (waul-1.2:140:119))
    at eval at &lt;anonymous&gt; (waul-1.2:140:119)
    at [object Object].each (eval at &lt;anonymous&gt; (waul-1.2:140:119))
    at [object Object].reach (eval at &lt;anonymous&gt; (waul-1.2:140:119))
    at eval at &lt;anonymous&gt; (waul-1.2:140:119)</pre>
  <p>One of the problems with writing your own programming language is that you also have to write your own debugger. Right now Caterwaul has no debugger, so figuring out why this was happening was
a real challenge. Fortunately, I had a hunch: I suspected that I was building a syntax tree with a string child instead of a syntax tree child. Caterwaul lets you use either as a convenience,
but the <code>push()</code> method of syntax trees doesn't do that conversion. So I refactored <code>push()</code> to use the same logic as the constructor and figured that would take care of
it.</p>
  <p>It didn't.</p>
  <p>Instead, I saw this in the generated output:</p>
  <pre class='quoted'>... .call(this, ..., , , , , , , , );</pre>
  <p>Node was understandably unhappy. Also strange was that my <code>.qse</code> literal expression refs had been replaced by variables called <code>e1</code>, <code>e2</code>, etc (normally they'd
be called <code>qse1</code>, <code>qse2</code>, ...). At first I thought I had some macro that was re-expanding something and generating anonymous expression refs, so I poked around. To my
surprise, no macro like this existed in the Caterwaul standard library. This meant that the bug was in the Caterwaul core itself.</p>
  <p>I copied the failing program and started trimming it down until the problem went away. I found out that constructs like <code>'g[_x]'.qse /-f/ y</code> would cause an <code>e</code> variable
to be created. As soon as I got rid of the <code>/-f/ y</code>, the <code>qse</code> would behave normally. I then tried it out on the REPL and found the same strange behavior:</p>
  <pre class='quoted'>$ waul -c js_all
waul&gt; '"foo".qse /-f/ bar'.qse.toString()
'f(qse_h_azCSgoP86KF16yaWYRruza)'             &lt;- notice: no 'bar'!
waul&gt; '"foo".qse / z /-f/ bar'.qse.toString()
'f(qse_j_azCSgoP86KF16yaWYRruza,z,bar)'       &lt;- now it's there</pre>
  <p>At this point it was clear that it was some strange case of the infix function syntax. After some more poking around and random guesses, I found that calling <code>flatten()</code> on
expression refs didn't work correctly. It turns out that tree coercion had a subtle bug in this function (it's written on one line in the Caterwaul source):</p>
  <pre class='quoted'>as: function (d) {
  return this.data === d
    ? this
    : new this.constructor(d).push(this);
}</pre>
  <p>This appeared to be doing the right thing: Either return the node or wrap it in a new <code>d</code> node and return that. It would be appropriately generic, too: <code>new
this.constructor</code> would be closed over the node type.</p>
  <p>And that's when everything made sense. Expression refs aren't instantiated like regular nodes. Most syntax trees take the "data", or their name, as the first argument. So if you said <code>new
caterwaul.syntax('foo')</code>, you'd have a syntax tree representing the identifier <code>foo</code>. But the expression ref and closure ref constructors are front-loaded to take the value
before the name. The name is entirely optional; normally Caterwaul will just use a gensym.</p>
  <p>The result of this was that when <code>flatten</code> was called on an expression ref, the expression ref was parenting itself with another expression ref, not a regular syntax node.
Expression refs don't have children, so this caused the original expression ref to be hidden and replaced by a nullary comma node. Expression refs serialize to their data, so the nullary comma
would be serialized as just ',', hence the syntactically incorrect output.</p>
  <p>Long story short, it turns out that <code>as</code> is an anomaly among tree transform methods in that it shouldn't respect type closure. The fix was to write it this way:</p>
  <pre class='quoted'>as: function (d) {
  return this.data === d
    ? this
    : new caterwaul_global.syntax(d).push(this);
}</pre>
  <p>If only all bugs could be this cool.
</p>
</div>
</div>

<div id='post-2012.0229-performance-as-a-side-effect'>
  <span class='date'>2012.0229</span>
  <span class='permalink'><a href='posts/2012.0229.performance-as-a-side-effect.html'>permalink</a></span>
  <div class='section level1'>
  <h1>Performance as a side effect</h1>
  <p>Someone on Twitter posed a good question recently: "What is state?" (that is, statefulness vs statelessness in code). I thought about that for a while. It's a difficult thing to pin down
because you could argue that any stored data is really state. My answer was that state is an implicit dependency on time.</p>
  <p>If it's true, this answer has some strange ramifications. For example, performance is another variable that involves time. And I would argue that something with unpredictable performance is,
in production scenarios, as dangerous as something that randomly emits side-effects. On the aggregate, it wouldn't surprise me if Java and C++ were actually the two languages with the highest
level of abstraction for the generally low total time dependency.
</p>
</div>
</div>

<div id='post-2012.0226-indirect-jumps-in-gnu-assembler'>
  <span class='date'>2012.0226</span>
  <span class='permalink'><a href='posts/2012.0226.indirect-jumps-in-gnu-assembler.html'>permalink</a></span>
  <div class='section level1'>
  <h1>Indirect jumps in GNU assembler</h1>
  <p>I'm not great at assembly-level programming, but I've been getting into it recently to implement a new programming language that I'll probably never finish. While working on it, I decided to
use some <a href='http://en.wikipedia.org/wiki/Continuation_passing_style' target='_blank'>continuation-passing style</a> patterns to minimize the amount of stack manipulation that would need
to happen. So I started out with some code like this:</p>
  <pre class='quoted'>movq continuation, %r12
jmp f
...
f:
...
jmp *%r12
...
continuation:</pre>
  <p>If you're familiar with AT&amp;T assembler syntax, you probably won't be surprised to hear that this segfaulted and <code>gdb</code> showed <code>%r12</code> as having a value way outside of the
program's code space. After a lot of reading online, it turns out that you need to do it this way:</p>
  <pre class='quoted'>movq $continuation, %r12</pre>
  <p>Linguistically, this makes sense: you're <code>jmp</code>ing to the code itself (which is similar to a dereference), but you're talking about the code's address when you put the value into a
register.
</p>
</div>
</div>

<div id='post-2012.0222-the-wrong-tool'>
  <span class='date'>2012.0222</span>
  <span class='permalink'><a href='posts/2012.0222.the-wrong-tool.html'>permalink</a></span>
  <div class='section level1'>
  <h1>The wrong tool</h1>
  <p>As a programmer who likes functional paradigms, I have a hard time accepting the fact that Java is so popular. But it is, and so much so that it's noteworthy. Great software is built in Java,
C++, C, and other very non-functional languages with tons of mutable state and edge-triggering. (For example, my OS, window manager, editor, terminal emulator, and browser are all written in
one of these languages.)</p>
  <p>I think there are some interesting dynamics behind Java's popularity and empirical success (and Haskell's empirical non-success, despite being signficantly more academically meritorious). What
is it that Java has that Haskell doesn't? My best guess is that Haskell gives you the ability to create tools easily; this is the default way of developing. So in order to make progress, you
are continuously defining abstractions. Put differently, you have the freedom, and the burden, of choosing your tools.</p>
  <p>Java is simple. It gives you one mediocre abstraction that leads to slow, complex, bug-ridden software. Its model of objects is, in my opinion, the wrong tool for any job. However, and this is
the genius of it, you don't have to think about your toolset. You just write stuff using the wrong tool, and slowly but surely you make progress without solving unnecessary problems.</p>
  <p>Another way to look at it is that this is a reflection of the software process as a whole: Most failures occur in the requirements phase, not design or implementation. By making programmers
think about their own requirements during the development phase, languages like Haskell create another point of failure. What interests me particularly is that this point of failure is
evidently so large that the average corporate programmer (even at Google!) is better off using the wrong tools than they are taking a shot at inventing their own. Maybe the true measure of a
programmer's usefulness is not their ability to write software, but their ability to know what needs to be written.
</p>
</div>
</div>

<div id='post-2012.0222-perfection-is-irrecoverable'>
  <span class='date'>2012.0222</span>
  <span class='permalink'><a href='posts/2012.0222.perfection-is-irrecoverable.html'>permalink</a></span>
  <div class='section level1'>
  <h1>Perfection is irrecoverable</h1>
  <p>Haskell emulates something close to perfection on an imperfect platform. Rather than embracing the platform's idiosyncrasies and imperfections, it attempts to create a world where they don't
exist. C, on the other hand, doesn't hide the fact that the platform is imperfect. It simply refines the world into a less imperfect one if you're writing normal assembly code.</p>
  <p>In general, I don't think it's possible to cover up significant amounts of imperfection. It's possible to use the Church encoding for numbers, for instance, but we don't do it because the cost
of introducing this abstraction is far too expensive. I would argue, too, that it's unnecessary. Purity is beautiful, but we're better off asymptotically approaching it than we are living in a
world where it's the only option.
</p>
</div>
</div>

<div id='post-2012.0217-syntax-as-a-constraint'>
  <span class='date'>2012.0217</span>
  <span class='permalink'><a href='posts/2012.0217.syntax-as-a-constraint.html'>permalink</a></span>
  <div class='section level1'>
  <h1>Syntax as a constraint</h1>
  <p>Someone at some point said something like "constraints breed creativity." It's an interesting thing to say considering that constraints also limit your options. But sometimes the burden of
choice is much more significant than the flexibility it provides.</p>
  <p>I'm running into this with <a href='http://github.com/spencertipping/mulholland' target='_blank'>Mulholland</a> and its very complex operator precedence model. The language doesn't present
enough of an opinion to guide library design, and as a result I'm not sure what to do with it. <a href='http://caterwauljs.org' target='_blank'>Caterwaul</a> didn't have this problem because
working inside Javascript's syntax was very limiting; there was rarely more than one way to do something. And it's one of the most useful (to me) things I've written. The necessary compromises
haven't held it back much at all.</p>
  <p>Put differently, syntax should be friendly both to library designers and to library users. Users, obviously, should be able to write what they mean and have that translated into something
useful. But more subtly, designers should have a set of constructive constraints so they aren't making decisions in a vacuum.
</p>
</div>
</div>

<div id='post-2012.0215-software-reliability'>
  <span class='date'>2012.0215</span>
  <span class='permalink'><a href='posts/2012.0215.software-reliability.html'>permalink</a></span>
  <div class='section level1'>
  <h1>Software reliability</h1>
  <p>When I was working for startups, it seemed like something was always burning down. The database would spontaneously become read-only, the middleware would sponataneously fail, or something
similarly catastrophic, and everyone would be in red-alert mode to try to fix the problem. It isn't hard to see why, either: we used brand-new technologies that weren't mature.</p>
  <p>Big companies don't seem to do it this way, and it isn't hard to see why. They can't afford the risk. (Using immature technologies is a huge risk, by the way; when we used Tokyo Tyrant, for
example, it would have started silently losing our data after we put more than 40GB into it.) Startups are lured into making risky choices by the promise of more rapid software development.</p>
  <p>At the same time, though, I wonder how many startups fail because they jumped the gun and tried to be more technologically savvy (in the use-what's-cool way) than their competitors, only to
end up with a technology Jenga tower that collapsed at some crucial moment (or worse, a development team whose performance was crippled by fighting fires). The ideal risk isn't blind, it's
calculated.
</p>
</div>
</div>

<div id='post-2012.0209-not-invented-here'>
  <span class='date'>2012.0209</span>
  <span class='permalink'><a href='posts/2012.0209.not-invented-here.html'>permalink</a></span>
  <div class='section level1'>
  <h1>Not invented here</h1>
  <p>I have a terrible case of NIH. This means I reimplement stuff that other people have written because I think I can do a better job (or based on other shaky reasoning). It does end somewhere; I
haven't yet written an operating system, browser, terminal emulator, machine-code compiler, or even a replacement for jQuery. But I have written a couple of programming languages, data
structure implementations, serialization formats, and other stuff that I could have gotten for free with open-source software.</p>
  <p>Strangely enough, I'm not sure I want to outgrow this bad habit just yet. I've learned a lot by reinventing the wheel. It's also been productive in some cases; when I find a problem in my
stack I can fix it quickly and move on.
</p>
</div>
</div>

<div id='post-2012.0207-occams-razor'>
  <span class='date'>2012.0207</span>
  <span class='permalink'><a href='posts/2012.0207.occams-razor.html'>permalink</a></span>
  <div class='section level1'>
  <h1>Occam's Razor</h1>
  <p>In real life, true facts are often both counterintuitive and simplifying. Finding out that the earth is round is a significant mental leap considering that it looks flat from every angle. But
it simplifies our perception of deeper questions like gravity, and it explains how airplanes can keep going west and end up where they started.</p>
  <p>The same is true of great platforms and frameworks. Rather than obscuring things or creating noise, they use a less-than-obvious presentation of something that ends up making your world a
simpler place.
</p>
</div>
</div>

<div id='post-2012.0205-great-abstractions'>
  <span class='date'>2012.0205</span>
  <span class='permalink'><a href='posts/2012.0205.great-abstractions.html'>permalink</a></span>
  <div class='section level1'>
  <h1>Great abstractions</h1>
  <p>jQuery didn't take long to become the dominant Javascript library, and it's easy to see why. For someone who already knows DOM programming, it's trivial to learn and provides great ways to get
stuff done with less work. jQuery also managed to achieve a kind of minimalism; you can't remove much without changing something fundamental. And for many purposes, it has replaced the DOM.</p>
  <p>Another platform like this is the C programming language. It allows you to write assembly-level code far faster than you could in assembly, and it conveniently obscures the details of
architecture/platform-specific instructions and ABIs. The vast majority of C programmers feel no need to look underneath the hood of GCC, the linker, the calling conventions, the standard C
library, or any number of other complex pieces of C's infrastructure.</p>
  <p>Each of these abstractions has an interesting property: people who use them rarely find the need to work around them. Put differently, these abstractions don't leak. Most abstractions, of
course, aren't like this. For instance, X11 implementations use direct-memory rendering for local connections to provide hardware acceleration. All of the rendering could be done over its
network protocol, but it would be dog-slow and nobody would use it.</p>
  <div class='section level2'>
    <h2>Good abstractions vanish</h2>
    <p>  CPU-bound programs written in Perl or Ruby usually take much longer to run than the same programs written in C. As such, there's a case to be made against, for example, writing ray-tracers
  or programming language interpreters in Perl. C, on the other hand, is not appreciably slower than assembly language for the vast majority of tasks. For most purposes, you'd never know the
  result wasn't written in assembly to begin with, except that C is so cool that nobody would do that. (Actually, this isn't true. C imposes a lot of structure on the resulting assembly that
  makes it easy to detect. But none of this structure impedes the program's functionality/performance very much.)</p>
    <p>  Like C, jQuery also doesn't add much overhead. Last time I <a target='_blank' href='http://spencertipping.com/js-instabench'>measured it</a>, the cost of creating a Javascript object is 1%
  of the cost of creating an HTML element; although jQuery isn't erased per se, it is such a thin layer, and it's so aggressively optimized, that jQuery itself is rarely the cause of
  performance problems.</p>
    <p>  Here's where things get slightly counterintuitive: both jQuery and C will generally result in a net performance <em>increase</em> despite each creating some overhead over the perfect
  hand-coded solution. Not only do the abstractions vanish, but they result in a faster end product. And we use these libraries because low performance is one of the most harmful side-effects
  that an application can have.</p>
    <p>  Put differently, asking the question, <em>is using this abstraction making my application slow</em> is just as problematic as asking, <em>is my app failing because this abstraction has a
  bug</em>.</p>
  </div>
  <div class='section level2'>
    <h2>Good abstractions are culturally accessible</h2>
    <p>  jQuery uses CSS syntax to select things, and while it did invent (as far as I know) its own accessor/mutator convention, this was so unsurprising and easy to use that things like Java's
  getter/setter pattern looked clunky and outdated by comparison. C allowed programmers to keep doing the kinds of cool stuff you could do in assembly (pointer typecasting, computed jumps),
  but made it easier and less error-prone to write programs with consistent structure.</p>
    <p>  Also, and just as importantly, jQuery didn't present some grand unified replacement for the DOM. Instead, it leveraged one of the DOM's core properties (the structured node hierarchy) and
  made it accessible in a reliable, cross-browser way. C didn't try to manage memory, create a new paradigm, or ignore the fact that you're ultimately writing machine language. Instead, it
  embraced these things and made them work consistently across every major platform (at least as far as the end-programmer is concerned).</p>
    <p>  The last, and perhaps most important, component of accessibility is ergonomics. C is much terser than assembly language for common use cases, just as jQuery is often much terser than direct
  DOM programming.</p>
    <p>  C and jQuery aren't the only libraries that have great ergonomics, of course. The UNIX filesystem and shell are also so useful that there isn't a decisively better alternative. Ditto for
  text editors as IDE components, despite how non-textual most programs are. Whatever design flaws these systems have, their ease of use is so compelling that we don't want to switch away.</p>
  </div>
  <div class='section level2'>
    <h2>Great abstractions withstand adaptation</h2>
    <p>  Adaptation comes in two ways. One is when the abstraction author changes something, often breaking code that uses the abstraction. This happened with Ruby; 1.9.x isn't backwards-compatible
  with 1.8.x, yielding workarounds like the RVM. Perl and Javascript are examples of the opposite; they have preserved horrible design flaws throughout their evolution so that old programs
  would keep working without modification.</p>
    <p>  The other, and more interesting, form of adaptation is when people start misusing something. A great example of this is the C++ template system, which was probably in no way designed with
  the idea that people would be using it for general-purpose metaprogramming. The fact that this misuse is so reliable that it has become commonplace is a significant compliment to C++
  templates. They have held up to unforeseen use where a lesser system would have broken down. The Web is perhaps the greatest example of misuse; what started as a simple linked document
  management system has ended up nearly replacing desktop applications.
</p>
  </div>
</div>
</div>


<!-- Generated by SDoc -->


</div>
</body>
</html>
